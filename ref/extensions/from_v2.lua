--[[
1. 楼主只负责将身份局武将的原技能引入国战，对部分国战无法实现或者不符合国战情况的技能（如觉醒技、高上限、焚心）做了修改，对部分可能导致bug组合的技能（如黄盖吴国太、黄盖新周泰、孔融袁术）做了调整，其余技能原封不动。部分武将/组合强度过高或过低的情况概不负责（bug级组合除外）。
2. 因为楼主学会做AI是开更后一段时间的事情，所以早期的一将、二将及很多SP暂无AI，以后有空会补上。
3. 由于楼主不会制图，因此大部分武将牌全部采用身份局武将牌图片，还请见谅。（感谢 @语湖谷2 制作部分国战武将牌）
4. 楼主自己加了部分珠联璧合，需要追加珠联璧合的请回复。
5. 技能描述综合了日神描述、OL描述和规则集描述，尽可能做到在简洁明了的同时不失准确性。
6. 关于神武将的说明：由于游戏内核原因，神将默认势力即为野心家，在选将界面可以选择两个神将组合，亮将后自动成为野心家。
	不过由于这样太破坏游戏体验感，因此本扩展给出了另一种选神将的方式：开局时选对应的普通武将（曹操、关羽、诸葛亮……），游戏开始前会提示是否替换为神将，势力与原势力相同。
7. 以下武将的代码为基本从国战Lua技能手册复制，感谢手册维护者：
（界限突破）曹操、司马懿、吕蒙
（神）神吕蒙、神周瑜
（一将成名2011）曹植、法正、吴国太（补益）
（一将成名2012）步练师（安恤）、王异
（一将成名2013）虞翻
以下武将的代码参考了5楼 @涅槃的喵 的扩展，特别感谢：
（界限突破）夏侯惇、许褚、赵云（涯角）、黄盖、周瑜、华佗
（一将成名2012）步练师（追忆）、廖化、刘表
（一将成名2013）伏皇后、关平、李儒、潘璋马忠
（一将成名2014）蔡夫人
（SP）星彩、祖茂
以下武将的代码参考了 @youko1316 的扩展，特别感谢：
（界限突破）刘备
（神话再临·界）魏延（奇谋）
（原创之魂2016）张让
（SP）诸葛诞
（OL专属）关索、李通、糜竺（资援）、步骘、董白
以下武将的代码参考了 @找不出名字 的扩展，特别感谢：
（OL修订）曹真、周仓、祖茂
以下武将的代码参考了 @b0020028 的扩展，特别感谢：
（新标风）周泰
（OL修订）SP蔡文姬
以下武将的代码参考了 @涅槃的喵 的扩展，特别感谢：
（一将成名2015）曹叡
（OL专属）王基

部分武将的特殊说明：
	身份与国战技能完全不同的武将（界陆逊、于吉/界于吉、马谡、徐盛；不包括董卓）：将身份局技能也加入本扩展（于吉只保留界突）。
	技能无法原型移植至国战的武将（钟会、华雄、刘虞、灵雎、诸葛瑾、诸葛诞、袁术(新标)、神诸葛亮、神吕布、神司马懿、神赵云、界SP孙尚香、界SP关羽、界SP姜维、界SP赵云、兀突骨）：觉醒技大部分改为主将副将技，高上限处理大部分可参考李傕郭汜（而且为啥都是群雄……），其他敬请期待。
	一将系列修订过的武将：优先制作新版，旧版有空再说。
	线上线下有多个版本的武将（徐盛、于禁、步练师、刘表、马岱、王异、曹叡、曹休、全琮、袁术、星彩、孙鲁育、刘备、新标张角）：优先制作线下版，OL版有空再说。
		（改势力后在OL又改技能的SP武将除外）
	公孙瓒：SP、桌游志贴纸取消，直接采用界限突破。
	华雄：只保留一个武将，但综合二将与新标的效果。
	SP关羽：直接采用界SP（怒斩）。
	诸葛瑾：在3v3的基础上调整技能。
	刘协：桌游志贴纸取消，直接采用SP。
	士燮、马云禄：既然是OL专属，那就直接用最新的OL版（礼下锁定、凤魄第一张杀）。
	爆料的神话再临界限突破武将：在确认之前暂不考虑。
]]--

sgs.LoadTranslationTable{  --通用函数
	["tarmod_show"] = "使用牌增益技能",  --源码漏掉的翻译
	["CancelOtherTargets"] = "取消除你外的目标",
	
	--通用LogMessage
	["$BecomeTarget"] = "%from 成为了 %card 的目标",
	["#BecomeTarget"] = "%from 成为了【%arg】的目标",
	
	["CancelFightTogether"] = "取消使用【勠力同心】",
	["#CancelFightTogether"] = "由于 %from 不能使用锦囊牌，取消使用此【<font color=\"yellow\"><b>勠力同心</b></font>】",
}
sgs.LoadTranslationTable{  --新标风
	["Renew"] = "新标风",
----------------------------------------------------------------------------------------------------
	["#CaoRen_13"] = "大将军",
	["CaoRen_13"] = "曹仁-13新",
	["&CaoRen_13"] = "曹仁",
	["illustrator:CaoRen_13"] = "Ccat",
	["~CaoRen_13"] = "长江以南再无王土矣……",
	
	["Jushou13"] = "据守",
	[":Jushou13"] = "结束阶段开始时，你可以摸一张牌，然后叠置。",
	["#Jushou-turn"] = "据守",
	["$Jushou13"] = "兵精粮足，守土一方。",
	
	["Jiewei"] = "解围",
	[":Jiewei"] = "当你的武将牌叠置后，你可以摸一张牌，然后你可以使用一张锦囊牌或装备牌，若如此做，你可以弃置场上一张与之类别相同的牌。",
	["@Jiewei"] = "你可以使用一张锦囊牌或装备牌",
	--["@Jiewei-discard"] = "你可以弃置一名角色场上与你使用的牌同类型的牌",
	["@Jiewei-discard"] = "你可以弃置场上的一张 %arg",
	["$Jiewei"] = "坚壁清野，以锉敌锐！",
----------------------------------------------------------------------------------------------------
	["#ZhouTai_13"] = "历战之驱",
	["ZhouTai_13"] = "周泰-13新",
	["&ZhouTai_13"] = "周泰",
	["illustrator:ZhouTai_13"] = "Thinking",
	["~ZhouTai_13"] = "敌众我寡，无力回天……",
	
	["BuquRenew_ZhouTai_13"] = "不屈",
	[":BuquRenew"] = "锁定技，当你处于濒死状态时，你将牌堆顶的一张牌置于武将牌上，称为“创”，然后若此“创”与其他“创”点数均不同，你将体力回复至1点，否则你移去此“创”（你的回合内每回合限一次）；若有“创”，你的手牌上限等于“创”的数量。",
	["#BuquRenew-showmaxcards_ZhouTai_13"] = "不屈（手牌上限）",
	["chuang_ZhouTai_13"] = "创",
	["#BuquRenew-showmaxcards_ZhouTai_13:keep"] = "你可发动“不屈”令你的手牌上限为 %arg",
	["$BuquRenew_ZhouTai_131"] = "哼，这点小伤算什么！",
	["$BuquRenew_ZhouTai_132"] = "战如熊虎，不惜屈命！",
	
	["Fenji"] = "奋激",
	[":Fenji"] = "当一名角色因另一名角色的弃置或获得而失去手牌后，你可以失去1点体力，令该失去手牌的角色摸两张牌。",
	["$Fenji1"] = "两肋插刀，愿负此屈！",
	["$Fenji2"] = "百战之身，奋勇驱前！",
----------------------------------------------------------------------------------------------------
	["#HuaXiong"] = "飞扬跋扈",
	["HuaXiong"] = "华雄",
	["illustrator:HuaXiong"] = "地狱许",
	["cv:HuaXiong"] = "官方",
	["~HuaXiong"] = "这……怎么可能！",
	
	["Yaowu"] = "耀武",
	[":Yaowu"] = "锁定技，当你首次明置此武将牌后，你加2点体力上限，然后回复2点体力；当你受到红色【杀】造成的伤害后，你令来源选择一项：1．回复1点体力；2．摸一张牌；3. 令你减1点体力上限。",
	["Yaowu:recover"] = "回复1点体力",
	["Yaowu:draw"] = "摸一张牌",
	["Yaowu:maxhp"] = "令华雄减1点体力上限",
	["$Yaowu1"] = "哼！先让你尝点儿甜头",
	["$Yaowu2"] = "大人有大量，不和你计较",
----------------------------------------------------------------------------------------------------
	["#YuanShu_Renew"] = "野心渐增",
	["YuanShu_Renew"] = "袁术-标",
	["&YuanShu_Renew"] = "袁术",
	["illustrator:YuanShu_Renew"] = "LiuHeng",
	["~YuanShu_Renew"] = "把玉玺..还给我！",
	
	["Wangzun_YuanShu_Renew"] = "妄尊",
	[":Wangzun"] = "一名大势力角色的准备阶段开始时，你可以摸一张牌，然后本回合其手牌上限-1，且你于下回合开始之前不能发动“妄尊”。",
	["$Wangzun_YuanShu_Renew1"] = "真命天子，八方拜服",
	["$Wangzun_YuanShu_Renew2"] = "归顺于我，封爵赏地",
	
	["Tongji"] = "同疾",
	[":Tongji"] = "锁定技，当攻击范围内含有你的角色使用【杀】指定目标时，若你的手牌数大于你的体力值，你取消除你外的目标。",
	["$Tongji1"] = "弑君之罪，当诛九族",
	["$Tongji2"] = "你..你这是反了",
----------------------------------------------------------------------------------------------------
	["#CaoRen_15"] = "大将军",
	["CaoRen_15"] = "曹仁-15新",
	["&CaoRen_15"] = "曹仁",
	["illustrator:CaoRen_15"] = "Ccat",
	["~CaoRen_15"] = "长江以南再无王土矣……",
	
	["Jushou15"] = "据守",
	[":Jushou15"] = "结束阶段开始时，你可以摸一张牌，然后叠置；当你以此法叠置或于回合开始前叠置后，你可以摸一张牌，然后你可以使用一张锦囊牌或装备牌，若如此做，你可以弃置场上一张与之类别相同的牌。",
	["Jushou15:draw"] = "你因“据守”或于回合开始前叠置，可摸一张牌",
	["$Jushou151"] = "兵精粮足，守土一方。",
	["$Jushou152"] = "坚壁清野，以锉敌锐！",
----------------------------------------------------------------------------------------------------
	["#ZhouTai_15"] = "历战之驱",
	["ZhouTai_15"] = "周泰-15新",
	["&ZhouTai_15"] = "周泰",
	["illustrator:ZhouTai_15"] = "Thinking",
	["~ZhouTai_15"] = "敌众我寡，无力回天……",
	
	["BuquRenew_ZhouTai_15"] = "不屈",
	["chuang_ZhouTai_15"] = "创",
	["#BuquRenew-showmaxcards_ZhouTai_15"] = "不屈（手牌上限）",
	["#BuquRenew-showmaxcards_ZhouTai_15:keep"] = "你可发动“不屈”令你的手牌上限为 %arg",
	["$BuquRenew_ZhouTai_151"] = "哼，这点小伤算什么！",
	["$BuquRenew_ZhouTai_152"] = "战如熊虎，不惜屈命！",
	
	["Fenji15"] = "奋激",
	[":Fenji15"] = "当一名角色因另一名角色的弃置或获得而失去手牌后，你可以弃置一张牌，失去1点体力，然后令该失去手牌的角色摸两张牌。",
	["@Fenji15"] = "你可以弃置一张牌发动“奋激”",
	["$Fenji151"] = "两肋插刀，愿负此屈！",
	["$Fenji152"] = "百战之身，奋勇驱前！",
}
sgs.LoadTranslationTable{  --界限突破
	["LimitBreaking"] = "界限突破",
----------------------------------------------------------------------------------------------------
	["#CaoCao_LB"] = "魏武帝",
	["CaoCao_LB"] = "曹操-界",
	["&CaoCao_LB"] = "曹操",
	["illustrator:CaoCao_LB"] = "青骑士",
	["~CaoCao_LB"] = "华佗何在……",
	
	["JianxiongLB"] = "奸雄",
	[":JianxiongLB"] = "当你受到伤害后，你可以选择一项：1. 摸一张牌；2. 获得造成此伤害的牌。",
	["JianxiongLB:obtain"] = "获得对你造成伤害的牌",
	["JianxiongLB:draw"] = "摸一张牌",
	["$JianxiongLB1"] = "燕雀安知鸿鹄之志！",
	["$JianxiongLB2"] = "夫英雄者，胸怀大志，腹有良谋。",
----------------------------------------------------------------------------------------------------
	["#SiMaYi_LB"] = "狼顾之鬼",
	["SiMaYi_LB"] = "司马懿-界",
	["&SiMaYi_LB"] = "司马懿",
	["illustrator:SiMaYi_LB"] = "木美人",
	["~SiMaYi_LB"] = "我的气数就到这里了吗？",
	
	["FankuiLB"] = "反馈",
	[":FankuiLB"] = "当你受到1点伤害后，你可以获得伤害来源的一张牌。",
	["$FankuiLB1"] = "哼！自作孽，不可活。",
	["$FankuiLB2"] = "哼，正中下怀。",
	
	["GuicaiLB"] = "鬼才",
	[":GuicaiLB"] = "当一名角色的判定牌生效前，你可以打出一张牌代替之。",
	--["@GuicaiLB-card"] = CommonTranslationTable["@askforretrial"],
	["@GuicaiLB-card"] = "请使用“%dest”来修改 %src 的 %arg 判定",
	["~GuicaiLB"] = "选择一张牌→点击确定",
	["$GuicaiLB1"] = "天命难违？哈哈哈哈哈哈哈哈……",
	["$GuicaiLB2"] = "才通天地，逆天改命！",
----------------------------------------------------------------------------------------------------
	["#XiaHouDun_LB"] = "独眼的罗刹",
	["XiaHouDun_LB"] = "夏侯惇-界",
	["&XiaHouDun_LB"] = "夏侯惇",
	["illustrator:XiaHouDun_LB"] = "DH",
	["~XiaHouDun_LB"] = "诸多败绩，有负丞相重托",
	
	["GanglieLB_XiaHouDun_LB"] = "刚烈",
	[":GanglieLB"] = "当你受到1点伤害后，你可以进行判定，若结果为：红色，你对伤害来源造成1点伤害；黑色，你弃置伤害来源的一张牌。",
	["$GanglieLB_XiaHouDun_LB1"] = "伤我者，十倍奉还",
	["$GanglieLB_XiaHouDun_LB2"] = "哪个敢动我",
	
	["Qingjian"] = "清俭",
	[":Qingjian"] = "当你于摸牌阶段外获得牌后，你可以将其中至少一张牌交给其他角色。",
	["@Qingjian-distribute1"] = "你须发动“清俭”将 %arg 张牌任意分配给其他角色",
	["@Qingjian-distribute2"] = "你可以发动“清俭”将 %arg 张牌任意分配给其他角色",
	["~Qingjian"] = "选择至少一张牌→选择一名其他角色→点击确定",
	["$Qingjian1"] = "钱财乃身外之物",
	["$Qingjian2"] = "福生于清俭，德生于卑退",
----------------------------------------------------------------------------------------------------
	["#ZhangLiao_LB"] = "前将军",
	["ZhangLiao_LB"] = "张辽-界",
	["&ZhangLiao_LB"] = "张辽",
	["illustrator:ZhangLiao_LB"] = "张帅",
	["~ZhangLiao_LB"] = "被敌人占了先机……呃……",
	
	["TuxiLB"] = "突袭",
	[":TuxiLB"] = "摸牌阶段，你可以少摸至少一张牌并选择等量的有手牌且手牌不少于你的其他角色，获得这些角色的各一张手牌。",
	["#TuxiLB-act"] = "突袭（获得目标角色的手牌）",
	["@TuxiLB-card"] = "你可以发动“突袭”选择至多 %arg 名其他角色",
	["~TuxiLB"] = "选择若干名其他角色→点击确定",
	["$TuxiLB1"] = "快马突袭，占尽先机！",
	["$TuxiLB2"] = "马似飞影，枪如霹雳！",
----------------------------------------------------------------------------------------------------
	["#XuChu_LB"] = "虎痴",
	["XuChu_LB"] = "许褚-界",
	["&XuChu_LB"] = "许褚",
	["illustrator:XuChu_LB"] = "巴萨小马",
	["~XuChu_LB"] = "丞相，末将尽力了……",
	
	["LuoyiLB"] = "裸衣",
	[":LuoyiLB"] = "你可以跳过摸牌阶段，若如此做，你亮出牌堆顶的三张牌，然后获得其中的基本牌、武器牌与【决斗】，将其余的牌置入弃牌堆，若如此做，直到你的下回合开始时，你为伤害来源的【杀】或【决斗】造成伤害时，你令此伤害+1。",
	["#LuoyiLB-damage"] = "裸衣（伤害+1）",
	["$LuoyiLB1"] = "过来打一架！对，就是你！",
	["$LuoyiLB2"] = "废话少说，放马过来吧！",
----------------------------------------------------------------------------------------------------
	["#GuoJia_LB"] = "早终的先知",
	["GuoJia_LB"] = "郭嘉-界",
	["&GuoJia_LB"] = "郭嘉",
	["illustrator:GuoJia_LB"] = "木美人",
	["~GuoJia_LB"] = "咳咳咳...",
	
	["tiandu_GuoJia_LB"] = "天妒",
	["$tiandu_GuoJia_LB1"] = "天意如此吧",
	["$tiandu_GuoJia_LB2"] = "那...就这样吧",
	
	["YijiLB"] = "遗计",
	[":YijiLB"] = "当你受到1点伤害后，你可以摸两张牌，然后你可以在至多两名其他角色的武将牌旁分别扣置一至两张手牌，若如此做，这些角色各于下个摸牌阶段开始时获得所有“遗计牌”。",
	["#YijiLB-obtain"] = "遗计（获得所有“遗计牌”）",
	["@YijiLB"] = "你可以选择至多两名角色扣置“遗计牌”",
	["YijiLBGive"] = "请在 %dest 武将牌旁扣置至多 %arg 张手牌",
	--["~YijiLB"] = "选择一至两名角色→点击确定",
	--["@YijiLB"] = "你可以选择至多两名角色扣置一至两张“遗计牌”",
	--["~YijiLB"] = "选择一至两张牌→选择一名其他角色→点击确定",
	["$YijiLB1"] = "依此计行，辽东可定",
	["$YijiLB2"] = "锦囊妙策，终定社稷",
----------------------------------------------------------------------------------------------------
	["#LiuBei_LB"] = "乱世的枭雄",
	["LiuBei_LB"] = "刘备-界",
	["&LiuBei_LB"] = "刘备",
	["illustrator:LiuBei_LB"] = "木美人",
	["~LiuBei_LB"] = "汉室未兴，祖宗未耀，朕实不忍此时西去……", 
	
	["RendeLB"] = "仁德",
	[":RendeLB"] = "出牌阶段，你可以将至少一张手牌交给一名本阶段未获得过“仁德”牌的其他角色，若你以此法交给其他角色的手牌数不小于2，你可以视为使用任意一张基本牌。",
	["@RendeLB"] = "请选择【%arg】的目标",
	["~RendeLB"] = "选择目标角色→点击确定",
	["$RendeLB1"] = "施仁布泽，乃我大汉立国之本。", 
	["$RendeLB2"] = "同心同德，救困扶危！", 
----------------------------------------------------------------------------------------------------
	["#GuanYu_LB"] = "美髯公",
	["GuanYu_LB"] = "关羽-界",
	["&GuanYu_LB"] = "关羽",
	["illustrator:GuanYu_LB"] = "俊西JUNC",
	["~GuanYu_LB"] = "桃园一拜，恩义常在。",
	
	["wusheng_GuanYu_LB"] = "武圣",
	["$wusheng_GuanYu_LB1"] = "逆贼，哪里走！",
	["$wusheng_GuanYu_LB2"] = "刀锋所向，战无不克！",
	
	["Yijue"] = "义绝",
	[":Yijue"] = "出牌阶段限一次，你可以与一名角色拼点：若你赢，该角色不能使用或打出手牌且你选择的其一张武将牌的非锁定技无效，直到回合结束；若你没赢，你可以令该角色回复1点体力。",
	["YijueRecover"] = "义绝（回复体力）",
	["YijueRecover:recover"] = "令目标角色回复1点体力",
	["#NonCompulsoryInvalidityHead"] = "受到“%arg”的影响，本回合 %to 主将 %arg2 的非锁定技无效",
	["#NonCompulsoryInvalidityDeputy"] = "受到“%arg”的影响，本回合 %to 副将 %arg2 的非锁定技无效",
	["$Yijue1"] = "恩已断，义当绝。",
	["$Yijue2"] = "关某向来恩怨分明。",
----------------------------------------------------------------------------------------------------
	["#ZhangFei_LB"] = "万夫不当",
	["ZhangFei_LB"] = "张飞-界",
	["&ZhangFei_LB"] = "张飞",
	["illustrator:ZhangFei_LB"] = "SONGQIJIN",
	["~ZhangFei_LB"] = "桃园一拜，此生无憾……",
	
	["paoxiao_ZhangFei_LB"] = "咆哮",
	["#paoxiao-null_ZhangFei_LB"] = "咆哮（无视防具）",
	["$paoxiao_ZhangFei_LB1"] = "喝啊~~~",
	["$paoxiao_ZhangFei_LB2"] = "今必斩汝马下！",
	
	["Tishen"] = "替身",
	[":Tishen"] = "限定技，准备阶段开始时，你可以将体力值回复至等同于你上回合结束时的体力值，摸X张牌（X为你以此法回复的体力数）。",
	["$Tishen1"] = "谁还敢过来一战！",
	["$Tishen2"] = "欺我无谋，定要尔等血偿！",
----------------------------------------------------------------------------------------------------
	["#ZhaoYun_LB"] = "虎威将军",
	["ZhaoYun_LB"] = "赵云-界",
	["&ZhaoYun_LB"] = "赵云",
	["illustrator:ZhaoYun_LB"] = "DH",
	["~ZhaoYun_LB"] = "你们谁……还敢再上？",
	
	["longdan_ZhaoYun_LB"] = "龙胆",
	["$longdan_ZhaoYun_LB1"] = "龙威虎胆，斩敌破阵！",
	["$longdan_ZhaoYun_LB2"] = "进退自如，游刃有余！",
	
	["Yajiao"] = "涯角",
	[":Yajiao"] = "当你于回合外使用或打出手牌时，你可以展示牌堆顶的一张牌，若这两张牌的类别：相同，你可以将展示的牌交给一名角色；不同，你可以将之置入弃牌堆。",
	["@Yajiao-give"] = "你可以令一名角色获得 %arg[%arg2]",
	["YajiaoDiscard:throw"] = "你可以将 %arg[%arg2] 置入弃牌堆",
	["$Yajiao1"] = "策马趋前，斩敌当先！",
	["$Yajiao2"] = "遍寻天下，但求一败！",
----------------------------------------------------------------------------------------------------
	["#MaChao_LB"] = "一骑当千",
	["MaChao_LB"] = "马超-界",
	["&MaChao_LB"] = "马超",
	["illustrator:MaChao_LB"] = "KayaK, 木美人, 张帅",
	["~MaChao_LB"] = "请将我葬在西凉……",
	
	["mashu_MaChao_LB"] = "马术",
	
	["TieqiLB"] = "铁骑",
	[":TieqiLB"] = "当你使用【杀】指定一个目标后，你可以令你选择的其一张武将牌的非锁定技于此回合内无效，然后进行判定，令其选择一项：1. 弃置与结果花色相同的一张牌；2. 不能使用【闪】响应此【杀】。\n\n" .. 
		"#“五虎将大旗”\n" .. 
		"当你使用【杀】指定一个目标后，你可以令其非锁定技于此回合内无效，然后进行判定，令其选择一项：1. 弃置与结果花色相同的一张牌；2. 不能使用【闪】响应此【杀】。",
	["@TieqiLB-discard"] = "请弃置一张 %arg 牌，否则你不能使用【闪】响应此【杀】",
	["#SuperTieqiLBInvalidity"] = "受到“%arg”及“%arg2”的影响，本回合 %to 的所有非锁定技无效",
	["$TieqiLB1"] = "目标敌阵，全军突击！",
	["$TieqiLB2"] = "敌人阵型已乱，随我杀~~~",
----------------------------------------------------------------------------------------------------
	["#XuShu_LB"] = "化剑为犁",
	["XuShu_LB"] = "徐庶-界",
	["&XuShu_LB"] = "徐庶",
	["illustrator:XuShu_LB"] = "MSNZero",
	["~XuShu_LB"] = "母亲……孩儿尽孝来了……",
	
	["Zhuhai"] = "诛害",
	[":Zhuhai"] = "其他角色的结束阶段开始时，若该角色于此回合内造成过伤害，你可以对其使用一张【杀】（无距离限制）。",
	["@Zhuhai-slash"] = "你可以发动“诛害”对 %dest 使用一张【杀】",
	["$Zhuhai1"] = "善恶有报，天道轮回！",
	["$Zhuhai2"] = "早知今日，何必当初？",
	
	["Jianyan"] = "荐言",
	[":Jianyan"] = "主将技，此武将牌上单独的阴阳鱼个数-1；出牌阶段限一次，你可以选择一种牌的类别或颜色，然后依次亮出牌堆顶的牌直到与你的选择相符，然后你令一名男性角色获得此牌，再将亮出的其余牌置入弃牌堆。",
	["@Jianyan-give"] = "你可以令一名男性角色获得 %arg[%arg2]",
	["#JianyanChoice"] = "%from 选择了 %arg",
	["$Jianyan1"] = "开言纳谏，社稷之福。",
	["$Jianyan2"] = "如此如此，敌军自破。",
	
	["Qianxin"] = "潜心",
	[":Qianxin"] = "副将技，当你使用【杀】对目标角色造成伤害后，若你已受伤，你可以摸一张牌，若如此做，你于此回合内不能使用或打出手牌。",
	["$Qianxin1"] = "既遇明主，天下可图！",
	["$Qianxin2"] = "弃武从文，安邦卫国！",
----------------------------------------------------------------------------------------------------
	["#GanNing_LB"] = "锦帆游侠",
	["GanNing_LB"] = "甘宁-界",
	["&GanNing_LB"] = "甘宁",
	["illustrator:GanNing_LB"] = "巴萨小马",
	["~GanNing_LB"] = "别管我……继续杀……",
	
	["qixi_GanNing_LB"] = "奇袭",
	["$qixi_GanNing_LB1"] = "你用不了这么多了！",
	["$qixi_GanNing_LB2"] = "弟兄们，准备动手！",
	
	["Fenwei"] = "奋威",
	[":Fenwei"] = "限定技，当一张锦囊牌指定至少两名目标后，你可以令此牌对至少一名目标角色无效。",
	["@Fenwei-card"] = "你可以发动“奋威”",
	["$Fenwei1"] = "哼，敢欺我东吴无人？",
	["$Fenwei2"] = "奋勇当先，威名远扬！",
----------------------------------------------------------------------------------------------------
	["#LyuMeng_LB"] = "士别三日",
	["LyuMeng_LB"] = "吕蒙-界",
	["&LyuMeng_LB"] = "吕蒙",
	["illustrator:LyuMeng_LB"] = "樱花闪乱",
	["~LyuMeng_LB"] = "你……给我等着！",
	
	["keji_LyuMeng_LB"] = "克己",
	["$keji_LyuMeng_LB1"] = "最好的机会还在等着我。",
	["$keji_LyuMeng_LB2"] = "蓄力待时，不争首功。",
	
	["Gongxin_LyuMeng_LB"] = "攻心",
	[":Gongxin"] = "出牌阶段限一次，你可以观看一名其他角色的手牌并可展示其中的一张红桃牌，然后选择一项：1. 弃置之；2. 将之置于牌堆顶。",
	["$Gongxin_LyuMeng_LB1"] = "哼，早知如此！",
	["$Gongxin_LyuMeng_LB2"] = "洞若观火，运筹帷幄。",
	["Gongxin_LyuMeng_LB:discard"] = "弃置",
	["Gongxin_LyuMeng_LB:put"] = "置于牌堆顶",
----------------------------------------------------------------------------------------------------
	["#HuangGai_LB"] = "轻身为国",
	["HuangGai_LB"] = "黄盖-界",
	["&HuangGai_LB"] = "黄盖",
	["illustrator:HuangGai_LB"] = "G.G.G.",
	["~HuangGai_LB"] = "盖……有负公瑾重托……",
	
	["KurouLB"] = "苦肉",
	[":KurouLB"] = "出牌阶段限一次，你可以弃置一张牌，失去1点体力。",
	["$KurouLB1"] = "我这把老骨头不算什么！",
	["$KurouLB2"] = "为成大义，死不足惜！",
	
	["Zhaxiang"] = "诈降",
	[":Zhaxiang"] = "锁定技，当你失去1点体力后，你摸三张牌，然后若此时在你的出牌阶段内，你本回合使用红色【杀】无距离限制且目标角色不能使用【闪】响应你使用的红色【杀】，且你可以多使用一张【杀】。",
	["#Zhaxiang-slash"] = "诈降（不可响应红【杀】）",
	["$Zhaxiang1"] = "铁索连舟而行，东吴水师可破。",
	["$Zhaxiang2"] = "两军阵前，不斩降将！",
----------------------------------------------------------------------------------------------------
	["#ZhouYu_LB"] = "大都督",
	["ZhouYu_LB"] = "周瑜-界",
	["&ZhouYu_LB"] = "周瑜",
	["~ZhouYu_LB"] = "既生瑜，何生亮……既生瑜，何生亮！",
	
	["YingziLB"] = "英姿",
	[":YingziLB"] = "锁定技，摸牌阶段，你多摸一张牌；你的手牌上限为X（X为你的体力上限）。",
	["#YingziLB-showmaxcards"] = "英姿（手牌上限）",
	["#YingziLB-showmaxcards:keep"] = "你可发动“英姿”令你的手牌上限为 %arg",
	["$YingziLB1"] = "哈哈哈哈哈哈哈哈……",
	["$YingziLB2"] = "伯符，且看我这一手！",
	
	["FanjianLB"] = "反间",
	[":FanjianLB"] = "出牌阶段限一次，你可以展示一张手牌并将之交给一名角色，令其选择一项：1. 展示所有手牌并弃置所有为此花色的牌；2. 失去1点体力。",
	["FanjianLB_discard:prompt"] = "你可以展示所有手牌并弃置所有 %arg 牌",
	["$FanjianLB1"] = "与我为敌，就当这般生不如死！",
	["$FanjianLB2"] = "抉择吧，在苦与痛的地狱中！",
----------------------------------------------------------------------------------------------------
	["#DaQiao_LB"] = "矜持之花",
	["DaQiao_LB"] = "大乔-界",
	["&DaQiao_LB"] = "大乔",
	["illustrator:DaQiao_LB"] = "DH",
	["~DaQiao_LB"] = "伯符，再也没人能欺负我了……",
	
	["GuoseLB"] = "国色",
	[":GuoseLB"] = "出牌阶段限一次，你可以选择一项：1.将一张方块牌当【乐不思蜀】使用；2.弃置一张方块牌，弃置场上的一张【乐不思蜀】。若如此做，你摸一张牌。",
	["$GuoseLB1"] = "旅途劳顿，请下马休整吧。",
	["$GuoseLB2"] = "还没到休息的时候！",
	
	["liuli_DaQiao_LB"] = "流离",
	["~liuli_DaQiao_LB"] = "选择一张牌→选择一名其他角色→点击确定",
	["$liuli_DaQiao_LB1"] = "伯符不在身边，我要自己保重",
	["$liuli_DaQiao_LB2"] = "帮帮人家嘛",
----------------------------------------------------------------------------------------------------
	["#LuXun_LB"] = "儒生雄才",
	["LuXun_LB"] = "陆逊-界",
	["&LuXun_LB"] = "陆逊",
	["illustrator:LuXun_LB"] = "depp",
	["~LuXun_LB"] = "我的未尽之业",
	
	["QianxunLB"] = "谦逊",
	[":QianxunLB"] = "当延时锦囊牌或其他角色使用的普通锦囊牌生效时，若你是此牌唯一的目标，你可以将所有手牌扣置于武将牌上，若如此做，当前回合结束后，你获得所有“谦逊牌”。",
	["#QianxunLB-return"] = "谦逊（获得“谦逊牌”）",
	["$QianxunLB1"] = "谦谦君子，温润如玉",
	["$QianxunLB2"] = "满招损，谦受益",
	
	["Lianying"] = "连营",
	[":Lianying"] = "当你失去手牌后，若你没有手牌，你可以令一至X名角色各摸一张牌（X为你此次失去的手牌数）。",
	["@Lianying-card"] = "你可以发动“连营”令至多 %arg 名角色各摸一张牌",
	["$Lianying1"] = "失之淡然，得之坦然",
	["$Lianying2"] = "生生不息，源源不绝",
----------------------------------------------------------------------------------------------------
	["#HuaTuo_LB"] = "神医",
	["HuaTuo_LB"] = "华佗-界",
	["&HuaTuo_LB"] = "华佗",
	["illustrator:HuaTuo_LB"] = "琛·美弟奇",
	["~HuaTuo_LB"] = "生老病死，命不可违。",
	
	["Chuli"] = "除疠",
	[":Chuli"] = "出牌阶段限一次，若你有牌，你可以选择至少一名势力各不相同的有牌的其他角色，弃置你和这些角色的各一张牌，然后以此法被弃置黑桃牌的角色各摸一张牌。",
	["@ChuliSelfDiscard"] = "请弃置 1 张牌，包括装备区的牌",
	["$Chuli1"] = "病入膏肓，需下猛药。",
	["$Chuli2"] = "病去，如抽丝。",
	
	["jijiu_HuaTuo_LB"] = "急救",
	["$jijiu_HuaTuo_LB1"] = "妙手仁心，药到病除。",
	["$jijiu_HuaTuo_LB2"] = "救死扶伤，悬壶济世。",
----------------------------------------------------------------------------------------------------
	["#LyuBu_LB"] = "武的化身",
	["LyuBu_LB"] = "吕布-界",
	["&LyuBu_LB"] = "吕布",
	["illustrator:LyuBu_LB"] = "张帅",
	["~LyuBu_LB"] = "我竟然输了，不可能！",
	
	["wushuang_LyuBu_LB"] = "无双",
	["$wushuang_LyuBu_LB1"] = "三个齐上也不是我的对手！",
	["$wushuang_LyuBu_LB2"] = "还有哪个敢挑战我？",
	
	["Liyu"] = "利驭",
	[":Liyu"] = "当你使用的【杀】对一名其他角色造成伤害后，该角色可以令你获得其一张牌，若如此做，你视为对其选择的另一名角色使用一张【决斗】。",
	["Liyu:Liyu_invoke"] = "你要发动 %src 的技能“<font color=\"yellow\"><b>利驭</b></font>”吗？",
	["@Liyu"] = "请选择一名其他角色视为 %src 对其使用一张【决斗】",
	["$Liyu1"] = "人不为己，天诛地灭。",
	["$Liyu2"] = "大丈夫相时而动。",
----------------------------------------------------------------------------------------------------
	["#GongSunZan"] = "白马将军",
	["GongSunZan"] = "公孙瓒",
	["illustrator:GongSunZan"] = "Vincent",
	["~GongSunZan"] = "皇图霸业梦，付之一炬中……",
	
	["Qiaomeng"] = "趫猛",
	[":Qiaomeng"] = "当你使用的黑色【杀】对一名角色造成伤害后，你可以弃置其装备区的一张牌，当此牌置入弃牌堆后，若此牌为坐骑牌，你获得之。",
	["#Qiaomeng-obtain"] = "趫猛（获得坐骑牌）",
	["$Qiaomeng1"] = "秣马厉兵，整戈待战。",
	["$Qiaomeng2"] = "夺敌辎重，以为己用。",
	
	["YicongGongSunZan"] = "义从",
	[":YicongGongSunZan"] = "锁定技，若你的体力值大于2，你与其他角色的距离-1；若你的体力值不大于2，其他角色与你的距离+1。",
	["#YicongGongSunZan-dist"] = "义从",
	["YicongGongSunZan:defend"] = "你可发动“义从”令其他角色与你的距离+1",
	["YicongGongSunZan:attack"] = "你可发动“义从”令你与其他角色的距离-1",
	["$YicongGongSunZan1"] = "列阵锋矢，直取要害！", -- +1 -> -1
	["$YicongGongSunZan2"] = "变阵冲厄，以守待攻！", -- -1 -> +1
}
sgs.LoadTranslationTable{  --神话再临·界
	["LegendLB"] = "神话再临·界",
----------------------------------------------------------------------------------------------------
	["#HuangZhong_LB"] = "老当益壮",
	["HuangZhong_LB"] = "黄忠-界",
	["&HuangZhong_LB"] = "黄忠",
	["~HuangZhong_LB"] = "不得不服老了……",
	
	["LiegongLB"] = "烈弓",
	[":LiegongLB"] = "你使用【杀】可以选择距离不大于此【杀】点数的角色为目标；当你使用【杀】指定一个目标后，你可以根据下列条件执行相应的效果：1. 若其手牌数不大于你，你可以令其不能使用【闪】响应此【杀】；2. 若其体力值不小于你，你可以令此【杀】对其造成的伤害+1。",
	["#LiegongLB-adddamage"] = "烈弓（伤害值+1）",
	["LiegongLB:noJink"] = "令其不能使用【闪】响应此【杀】",
	["LiegongLB:damage"] = "令此【杀】对其造成的伤害+1",
	["$LiegongLBInvoke"] = "%from 令 %card 对 %to 造成的伤害+1",
	["#LiegongLBInvoke"] = "%from 令【%arg】对 %to 造成的伤害+1",
	["#LiegongLBBuff"] = "%from 执行了“<font color=\"yellow\"><b>烈弓</b></font>”的效果，伤害从 %arg 点增加至 %arg2 点",
	["$LiegongLB1"] = "中！",
	["$LiegongLB2"] = "百步穿杨！",
----------------------------------------------------------------------------------------------------
	["#WeiYan_LB"] = "嗜血的独狼",
	["WeiYan_LB"] = "魏延-界",
	["&WeiYan_LB"] = "魏延",
	["illustrator:WeiYan_LB"] = "SoniaTang",
	["~WeiYan_LB"] = "",
	
	["KuangguLB"] = "狂骨",
	[":KuangguLB"] = "当你对距离1以内的一名角色造成1点伤害后，你可以选择一项：1. 回复1点体力；2. 摸一张牌。",
	["KuangguLB:recover"] = "回复1点体力",
	["KuangguLB:draw"] = "摸一张牌",
	["$KuangguLB1"] = "哼，也不看看我是何人。",
	["$KuangguLB2"] = "嗯哈哈哈哈，赢你还不容易。",
	
	["Qimou"] = "奇谋",
	[":Qimou"] = "限定技，出牌阶段，你可以失去X点体力，令你于此回合内与其他角色的距离-X且可以多使用X张【杀】。（X至多为你的体力值）",
	["Qimou_hp"] = "奇谋失去体力数",
	["$Qimou1"] = "成王败寇怎可有勇无谋。",
	["$Qimou2"] = "切不要因为暂时的得失而胆怯。",
}
sgs.LoadTranslationTable{  --神
	["God"] = "神",
----------------------------------------------------------------------------------------------------
	["#ShenGuanYu"] = "鬼神再临",
	["ShenGuanYu"] = "神关羽",
	
	["Wushen"] = "武神",
	[":Wushen"] = "锁定技，你的红桃手牌视为【杀】；你使用红桃【杀】无距离限制。",
	["$Wushen1"] = "还不速速领死！",
	["$Wushen2"] = "取汝狗头，犹如探囊取物！",
	
	["Wuhun"] = "武魂",
	[":Wuhun"] = "锁定技，当你受到1点伤害后，你令伤害来源获得1枚“梦魇”标记；当你死亡时，你令一名拥有最多“梦魇”标记的其他角色进行判定，若结果不为【桃】或【桃园结义】，该角色死亡。",
	["@Wuhun-revenge"] = "请选择“梦魇”标记最多的一名其他角色",
	["@nightmare"] = "梦魇",
	["#WuhunRevenge"] = "%from 的“%arg2”被触发，拥有最多“梦魇”标记的角色 %to（%arg个）死亡",
	["$Wuhun1"] = "拿命来！",
	["$Wuhun2"] = "谁来与我同去！",
----------------------------------------------------------------------------------------------------
	["#ShenLyuMeng"] = "圣光之国士",
	["ShenLyuMeng"] = "神吕蒙",
	["~ShenLyuMeng"] = "劫数难逃，我们别无选择……",
	
	["Shelie"] = "涉猎",
	[":Shelie"] = "摸牌阶段开始时，你可以放弃摸牌，亮出牌堆顶的五张牌，然后获得其中每种花色的牌各一张，将其余的牌置入弃牌堆。",
	["Shelie#up"] = "置入弃牌堆",
	["Shelie#down"] = "获得",
	["@Shelie"] = "请选择花色各不同的卡牌",
	["$Shelie1"] = "略懂，略懂。",
	["$Shelie2"] = "什么都略懂一点，生活更多彩一些！",
	
	["Gongxin_ShenLyuMeng"] = "攻心",
	["Gongxin_ShenLyuMeng:discard"] = "弃置",
	["Gongxin_ShenLyuMeng:put"] = "置于牌堆顶",
	["$Gongxin_ShenLyuMeng1"] = "攻城为下，攻心为上。",
	["$Gongxin_ShenLyuMeng2"] = "我替施主把把脉。",
----------------------------------------------------------------------------------------------------
	["#ShenZhouYu"] = "赤壁的火神",
	["ShenZhouYu"] = "神周瑜",
	["~ShenZhouYu"] = "逝者不死，浴火重生……",
	
	["Qinyin"] = "琴音",
	[":Qinyin"] = "弃牌阶段结束时，若你于此阶段内弃置过你的至少两张手牌，你可以选择一项：1. 令所有角色各回复1点体力；2. 令所有角色各失去1点体力。",
	["Qinyin:up"] = "所有角色回复1点体力",
	["Qinyin:down"] = "所有角色失去1点体力",
	["$Qinyin1"] = "（杂乱琴音）",
	["$Qinyin2"] = "（舒缓琴音）",
	
	["Yeyan"] = "业炎",
	[":Yeyan"] = "限定技，出牌阶段，你可以对一至三名角色各造成1点火焰伤害，或弃置四张花色各不相同的手牌并选择一至两名角色，失去3点体力，然后对这些角色造成共计至多3点火焰伤害且对其中一名角色造成至少2点火焰伤害。",
	["greatyeyan"] = "业炎",
	["smallyeyan"] = "业炎",
	["$Yeyan1"] = "聆听吧，这献给你的镇魂曲！",
	["$Yeyan2"] = "让这熊熊业火，焚尽你的罪恶！",
----------------------------------------------------------------------------------------------------
	["#ShenZhuGeLiang"] = "赤壁的妖术师",
	["ShenZhuGeLiang"] = "神诸葛亮",
	["~ShenZhuGeLiang"] = "今当远离，临表涕零，不知所言……",
	
	["Qixing"] = "七星",
	[":Qixing"] = "当你首次明置此武将牌后，你摸七张牌，然后将七张手牌扣置于武将牌旁，称为“星”；摸牌阶段结束时，你可以用至少一张手牌替换等量的“星”。",
	["#Qixing-show"] = "七星（摸七张牌）",
	["stars"] = "星",
	["@Qixing-exchange"] = "请选择牌用于交换",
	["~Qixing"] = "选择的牌将成为“星”",
	["#QixingExchange"] = "%from 发动了“%arg2”，交换了 %arg 张手牌",
	["$Qixing1"] = "祈星辰之力，佑我蜀汉！",
	["$Qixing2"] = "伏忘天恩，誓讨汉贼！",
	
	["Kuangfeng"] = "狂风",
	[":Kuangfeng"] = "结束阶段开始时，你可以移去一张“星”并选择一名角色，若如此做，直到你的回合开始之前，当其受到的火焰伤害结算开始时，你令此伤害+1。",
	["#Kuangfeng-effect"] = "狂风（伤害+1）",
	["@gale_ShenZhuGeLiang"] = "狂风",
	["@Kuangfeng-card"] = "你可以发动“狂风”",
	["~Kuangfeng"] = "选择一张“星”→选择一名角色→点击确定",
	["$Kuangfeng1"] = "万事俱备，只欠业火。",
	["$Kuangfeng2"] = "风——起！！",
	
	["Dawu"] = "大雾",
	[":Dawu"] = "结束阶段开始时，你可以移去至少一张“星”并选择等量的角色，若如此做，直到你的回合开始之前，当其受到的非雷电伤害结算开始时，你防止此伤害。",
	["#Dawu-effect"] = "大雾（防止伤害）",
	["@fog_ShenZhuGeLiang"] = "大雾",
	["@Dawu-card"] = "你可以发动“大雾”",
	["~Dawu"] = "选择若干名张“星”→选择等量的角色→点击确定",
	["$Dawu1"] = "此非万全之策，唯惧天雷。",
	["$Dawu2"] = "此计，可保你一时平安。",
----------------------------------------------------------------------------------------------------
	["#ShenCaoCao"] = "超世之英杰",
	["ShenCaoCao"] = "神曹操",
	["~ShenCaoCao"] = "腾蛇乘雾，终为土灰。",
	
	["Guixin"] = "归心",
	[":Guixin"] = "当你受到1点伤害后，你可以获得每名其他角色区域内的一张牌，然后叠置。",
	["$Guixin1"] = "山不厌高，海不厌深。",
	["$Guixin2"] = "周公吐哺，天下归心。",
	
	["feiying_ShenCaoCao"] = "飞影",
----------------------------------------------------------------------------------------------------
	["#ShenLyuBu"] = "修罗之道",
	["ShenLyuBu"] = "神吕布",
	["~ShenLyuBu"] = "我在修罗炼狱等着你们，喝哈哈哈哈……",
	
	["Kuangbao"] = "狂暴",
	[":Kuangbao"] = "锁定技，当你首次明置此武将牌后，你获得2枚“暴怒”标记；当你造成或受到1点伤害后，你获得1枚“暴怒”标记。",
	["@wrath"] = "暴怒",
	["$Kuangbao1"] = "嗯——！！",
	["$Kuangbao2"] = "哼！",
	
	["Wumou"] = "无谋",
	[":Wumou"] = "锁定技，当你使用普通锦囊牌时，你选择一项：失去1点体力，或弃1枚“暴怒”标记。",
	["Wumou:discard"] = "弃1枚“暴怒”标记",
	["Wumou:losehp"] = "失去1点体力",
	["$Wumou1"] = "哪个说我有勇无谋！？",
	["$Wumou2"] = "不管这些了！",
	
	["Wuqian"] = "无前",
	[":Wuqian"] = "出牌阶段，你可以弃2枚“暴怒”标记并选择一名角色，你拥有“无双”且其防具无效，直到回合结束。",
	["$Wuqian1"] = "天王老子也保不住你！",
	["$Wuqian2"] = "看我神威，无坚不摧！",
	["wushuang_ShenLyuBu"] = "无双",
	["$wushuang_ShenLyuBu1"] = "谁能挡我！",
	["$wushuang_ShenLyuBu2"] = "神挡杀神，佛挡杀佛！",
	
	["Shenfen"] = "神愤",
	[":Shenfen"] = "出牌阶段限一次，你可以弃6枚“暴怒”标记，对所有其他角色各造成1点伤害，然后这些角色先各弃置装备区的所有牌再弃置四张手牌，最后你叠置。",
	["$Shenfen1"] = "这，才是活生生的地狱！",
	["$Shenfen2"] = "凡人们，颤抖吧，这是神之怒火！",
----------------------------------------------------------------------------------------------------
	["#ShenZhaoYun"] = "神威如龙",
	["ShenZhaoYun"] = "神赵云",
	["~ShenZhaoYun"] = "龙身虽死，魂魄不灭！",
	
	["Juejing"] = "绝境",
	[":Juejing"] = "锁定技，当你首次明置此武将牌后，你减1点体力上限；摸牌阶段，若你已受伤，你多摸X张牌（X为你已损失的体力值）；你的手牌上限+2。",
	["#Juejing"] = "%from 的“%arg2”被触发，额外摸了 %arg 张牌",
	["#Juejing-showmaxcards"] = "绝境（手牌上限）",
	["#Juejing-showmaxcards:keep"] = "你可发动“绝境”令你的手牌上限 + 2",
	["$Juejing1"] = "置于死地，方能后生！",
	["$Juejing2"] = "背水一战，不胜便死！",
	
	["Longhun"] = "龙魂",
	[":Longhun"] = "你可以将X张花色相同的牌按以下规则使用或打出：红桃当【桃】，方块当火【杀】，黑桃当【无懈可击】，梅花当【闪】（X为你的体力值且至少为1）。",
	["$Longhun1"] = "常山赵子龙在此！",
	["$Longhun2"] = "能屈能伸，才是大丈夫！",
----------------------------------------------------------------------------------------------------
	["#ShenSiMaYi"] = "晋国之祖",
	["ShenSiMaYi"] = "神司马懿", 
	["~ShenSiMaYi"] = "鼎足三分已成梦，一切都结束了……",
	
	["Renjie"] = "忍戒",
	[":Renjie"] = "锁定技，当你受到1点伤害后或于弃牌阶段内因弃置而失去一张手牌后，你获得1枚“忍”标记。",
	["@bear"] = "忍",
	["$Renjie1"] = "忍一时，风平浪静。",
	["$Renjie2"] = "退一步，海阔天空。",
	
	["Jilyue"] = "极略",
	[":Jilyue"] = "若你的“忍”标记数不小于势力数，你可以弃1枚“忍”标记，发动以下技能之一：“鬼才”、“放逐”、“集智”、“制衡”、“完杀”。",
	["@Jilyue-zhiheng"] = "请发动“制衡”",
	["~Jilyue"] = "选择需要弃置的牌→点击确定",
	["$Jilyue1"] = "老夫，即是天命！", -- 鬼才
	["$Jilyue2"] = "赦你死罪，你去吧。", -- 放逐
	["$Jilyue3"] = "天要亡你，谁人能救？", -- 完杀
	["$Jilyue4"] = "天之道，轮回也。", -- 制衡
	["$Jilyue5"] = "顺应天意，得道多助。", -- 集智
	
	["Lianpo"] = "连破",
	[":Lianpo"] = "一名角色的回合结束后，若你于此回合内杀死过至少一名角色，你可以获得一个额外的回合。",
	["#LianpoCanInvoke"] = "%from 在本回合内杀死了 %arg 名角色，将获得一个额外的回合",
	["#LianpoRecord"] = "%from 杀死了 %to，可在 %arg 回合结束后进行一个额外的回合",
	["$Lianpo1"] = "一鼓作气，破敌制胜！",
	["$Lianpo2"] = "受命于天，既寿永昌！",
}
sgs.LoadTranslationTable{  --一将成名
	["YJCM"] = "一将成名",
----------------------------------------------------------------------------------------------------
	["#CaoZhi"] = "八斗之才",
	["CaoZhi"] = "曹植",
	["designer:CaoZhi"] = "Foxear",
	["illustrator:CaoZhi"] = "木美人",
	["~CaoZhi"] = "本是同根生，相煎何太急……",
	
	["Luoying"] = "落英",
	[":Luoying"] = "当其他角色的牌因判定或弃置而置入弃牌堆后，你可以获得其中至少一张梅花牌。",
	["@Luoying-get"] = "你可发动“落英”获得至少一张梅花牌",
	["#Luoying"] = "落英",
	["$Luoying1"] = "这些都是我的。",
	["$Luoying2"] = "别着急哟，给我就好。",
	
	["Jiushi"] = "酒诗",
	[":Jiushi"] = "当你需要使用【酒】时，若你处于平置状态，你可以叠置，视为使用一张【酒】；当你受到伤害扣减体力前，若你处于叠置状态，你可以于伤害结算后将武将牌改为平置状态。",
	["$Jiushi1"] = "置酒高殿上，亲友从我游。",
	["$Jiushi2"] = "走马行酒礼，驱车布鱼肉。",
----------------------------------------------------------------------------------------------------
	["#ChenGong"] = "刚直壮烈",
	["ChenGong"] = "陈宫",
	["designer:ChenGong"] = "Kaycent",
	["illustrator:ChenGong"] = "黑月乱",
	["~ChenGong"] = "请出就戮！",
	
	["Mingce"] = "明策",
	[":Mingce"] = "出牌阶段限一次，你可以将一张装备牌或【杀】交给一名其他角色，若如此做，该角色可以视为对其攻击范围内你选择的一名角色使用【杀】，否则其摸一张牌。",
	["Mingce:use"] = "对攻击范围内的一名角色使用一张【杀】",
	["Mingce:draw"] = "摸一张牌",
	["$Mingce1"] = "如此，霸业可图也！",
	["$Mingce2"] = "如此，一击可擒也！",
	
	["Zhichi"] = "智迟",
	[":Zhichi"] = "锁定技，当你于回合外受到伤害后，【杀】和普通锦囊牌对你无效，直到回合结束。",
	["#Zhichi-protect"] = "智迟（令【杀】和普通锦囊牌无效）",
	["#ZhichiDamaged"] = "%from 受到了伤害，本回合内【<font color=\"yellow\"><b>杀</b></font>】和普通锦囊牌都将对其无效",
	["#ZhichiAvoid"] = "%from 的“%arg”被触发，【<font color=\"yellow\"><b>杀</b></font>】和普通锦囊牌对其无效",
	["$Zhichi1"] = "如今之计，唯有退守，再做决断！",
	["$Zhichi2"] = "若吾早知如此。",
----------------------------------------------------------------------------------------------------
	["#FaZheng"] = "蜀汉的辅翼",
	["FaZheng"] = "法正",
	["designer:FaZheng"] = "Michael_Lee",
	["illustrator:FaZheng"] = "L",
	["~FaZheng"] = "汉室复兴，我是看不到了……",
	
	["Enyuan"] = "恩怨",
	[":Enyuan"] = "当你获得一名其他角色的两张或更多的牌后，你可以令其摸一张牌；当你受到1点伤害后，你可以令伤害来源选择一项：1. 将一张手牌交给你；2. 失去1点体力。",
	["EnyuanGive"] = "请交给 %dest %arg 张手牌",
	["$Enyuan1"] = "报之以李，还之以桃。",
	["$Enyuan2"] = "伤了我，休想全身而退！",
	
	["Xuanhuo"] = "眩惑",
	[":Xuanhuo"] = "摸牌阶段开始时，你可以放弃摸牌并选择一名其他角色，令其摸两张牌，然后该角色可以对其攻击范围内由你选择的一名角色使用一张【杀】，否则你获得其两张牌。",
	["Xuanhuo-invoke"] = "你可以发动“眩惑”<br/> <b>操作提示</b>: 选择一名其他角色→点击确定<br/>",
	["Xuanhuo_slash"] = "眩惑",
	["Xuanhuo-slash"] = "请对 %dest 使用一张【杀】",
	["$Xuanhuo1"] = "收人钱财，替人消灾。", -- 令其他角色摸牌
	["$Xuanhuo2"] = "哼，叫你十倍奉还！", -- 获得牌
----------------------------------------------------------------------------------------------------
	["#GaoShun"] = "攻无不克",
	["GaoShun"] = "高顺",
	["designer:GaoShun"] = "羽柴文理",
	["illustrator:GaoShun"] = "鄧Sir",
	["~GaoShun"] = "生死有命……",
	
	["Xianzhen"] = "陷阵",
	[":Xianzhen"] = "出牌阶段限一次，你可以与一名其他角色拼点：若你赢，本回合，该角色的防具无效，你无视与该角色的距离，你对该角色使用【杀】无次数限制；若你没赢，你不能使用【杀】，直到回合结束。",
	["$Xianzhen1"] = "攻无不克，战无不胜。",
	["$Xianzhen2"] = "破阵斩将，易如反掌。",
	
	["Jinjiu"] = "禁酒",
	[":Jinjiu"] = "锁定技，你的【酒】视为【杀】。",
	["$Jinjiu1"] = "贬酒阙色，所以无污。",
	["$Jinjiu2"] = "避嫌远疑，所以无误。",
----------------------------------------------------------------------------------------------------
	["#MaSu_YJ"] = "怀才自负",
	["MaSu_YJ"] = "马谡-一将",
	["&MaSu_YJ"] = "马谡",
	["designer:MaSu_YJ"] = "点点",
	["illustrator:MaSu_YJ"] = "张帅",
	
	["Xinzhan"] = "心战",
	[":Xinzhan"] = "出牌阶段限一次，若你的手牌数大于你的体力上限，你可以观看牌堆顶的三张牌，然后你可以展示并获得其中至少一张红桃牌，然后将其余的牌置于牌堆顶。",
	["@Xinzhan"] = "你可获得任意数量的红桃牌",
	["Xinzhan#up"] = "置于牌堆顶",
	["Xinzhan#down"] = "获得",
	["$Xinzhan"] = "吾通晓兵法，世人皆知。",
	
	["Huilei"] = "挥泪",
	[":Huilei"] = "锁定技，当你死亡时，你令杀死你的角色弃置其所有牌。",
	["#HuileiThrow"] = "%from 的“%arg”被触发，伤害来源 %to 弃置所有牌",
	["$Huilei1"] = "丞相视某如子，某以丞相为父。",
	["$Huilei2"] = "谡愿以死安大局。",
----------------------------------------------------------------------------------------------------
	["#WuGuoTai"] = "武烈皇后",
	["WuGuoTai"] = "吴国太",
	["designer:WuGuoTai"] = "章鱼咬你哦",
	["illustrator:WuGuoTai"] = "zoo",
	["~WuGuoTai"] = "卿等务必用心辅佐仲谋……",
	
	["Ganlu"] = "甘露",
	[":Ganlu"] = "出牌阶段限一次，你可以令装备区的牌数之差不大于你已损失体力值的两名角色交换他们装备区的牌。",
	["#GanluSwap"] = "%from 交换了 %to 的装备",
	["$Ganlu1"] = "男婚女嫁，需当交换文定之物。",
	["$Ganlu2"] = "此真乃吴之佳婿也。",
	
	["Buyi"] = "补益",
	[":Buyi"] = "当一名角色于其回合外进入濒死状态时，你可以展示其一张手牌，若此牌不为基本牌，该角色弃置此牌，然后回复1点体力。",
	["$BuyiCannotDiscard"] = "%from 无法弃置 %card，因此不能执行“<font color=\"yellow\"><b>补益</b></font>”的效果",
	["$Buyi1"] = "吾乃吴国之母，何人敢造次。",
	["$Buyi2"] = "有老身在，汝等尽可放心。",
----------------------------------------------------------------------------------------------------
	["#XuSheng_YJ"] = "江东的铁壁",
	["XuSheng_YJ"] = "徐盛-一将",
	["&XuSheng_YJ"] = "徐盛",
	["designer:XuSheng_YJ"] = "阿江",
	["illustrator:XuSheng_YJ"] = "天空之城",
	["~XuSheng_YJ"] = "盛不能奋身出命，不亦辱乎。",
	
	["Pojun"] = "破军",
	[":Pojun"] = "当你使用【杀】对目标角色造成伤害后，你可以令其摸X张牌（X为其体力值且至多为5），然后其叠置。",
	["$Pojun1"] = "大军在此！汝等休想前进一步！",
	["$Pojun2"] = "敬请养精蓄锐！",
----------------------------------------------------------------------------------------------------
	["#XuShu_YJ"] = "忠孝的侠士",
	["XuShu_YJ"] = "徐庶-一将",
	["&XuShu_YJ"] = "徐庶",
	["illustrator:XuShu_YJ"] = "XINA",
	["~XuShu_YJ"] = "忠孝不能两全，孩儿……",
	
	["Wuyan"] = "无言",
	[":Wuyan"] = "锁定技，当你因锦囊牌造成伤害时，你防止此伤害；当你受到锦囊牌造成的伤害时，你防止此伤害。",
	["#WuyanBad"] = "%from 的“%arg2”被触发，本次伤害被防止",
	["#WuyanGood"] = "%from 的“%arg2”被触发，防止了本次伤害",
	["$Wuyan1"] = "吾誓不为汉贼献一策！", -- 造成伤害
	["$Wuyan2"] = "汝有良策，何必问我。", -- 受到伤害
	
	["Jujian"] = "举荐",
	[":Jujian"] = "结束阶段开始时，你可以弃置一张非基本牌并选择一名其他角色，令其选择一项：1. 摸两张牌；2. 回复1点体力；3. 复原武将牌。",
	["@Jujian-Card"] = "你可以发动“举荐”",
	["~Jujian"] = "选择一张非基本牌→选择一名其他角色→点击确定",
	["Jujian:draw"] = "摸两张牌",
	["Jujian:recover"] = "回复1点体力",
	["Jujian:reset"] = "重置并翻至正面朝上",
	["$Jujian1"] = "天下大任，望君莫辞。",
	["$Jujian2"] = "卧龙之才远胜于吾。", -- 诸葛亮
----------------------------------------------------------------------------------------------------
	["#YuJin"] = "魏武之刚",
	["YuJin"] = "于禁",
	["designer:YuJin"] = "城管无畏",
	["illustrator:YuJin"] = "Yi章",
	["~YuJin"] = "我…无颜面对丞相了……",
	
	["Yizhong"] = "毅重",
	[":Yizhong"] = "锁定技，若你的装备区没有防具牌，黑色【杀】对你无效。",
	["$Yizhong1"] = "不先为备，何以待敌。",
	["$Yizhong2"] = "稳重行军，百战不殆！",
----------------------------------------------------------------------------------------------------
	["#ZhangChunHua"] = "冷血皇后",
	["ZhangChunHua"] = "张春华",
	["designer:ZhangChunHua"] = "JZHIEI",
	["illustrator:ZhangChunHua"] = "樱花闪乱",
	["~ZhangChunHua"] = "怎能如此对我……",
	
	["Jueqing"] = "绝情",
	[":Jueqing"] = "锁定技，当你造成的伤害结算开始前，你将此伤害视为失去体力。",
	["$Jueqing1"] = "你的死活与我何干？",
	["$Jueqing2"] = "无来无去，不悔不怨。",
	
	["Shangshi"] = "伤逝",
	[":Shangshi"] = "当你的手牌数、体力值或体力上限变化后，若你的手牌数小于X，你可以将手牌补至X张（X为你已损失的体力值且至多为2）。\n" .. 
					"★你以此法获得牌时不能发动“清俭”。",
	["$Shangshi1"] = "无情者伤人，有情者自伤。",
	["$Shangshi2"] = "自损八百，可伤敌一千！",
----------------------------------------------------------------------------------------------------
	["#ZhongHui"] = "桀骜的野心家",
	["ZhongHui"] = "钟会",
	["illustrator:ZhongHui"] = "雪君S",
	["~ZhongHui"] = "伯约，让你失望了……",
	
	["Quanji"] = "权计",
	[":Quanji"] = "当你受到1点伤害后，你可以摸一张牌，然后将一张手牌置于武将牌上，称为“权”；你的手牌上限+X（X为“权”数）。",
	["QuanjiPush"] = "请将一张手牌置于武将牌上",
	["power"] = "权",
	["$Quanji1"] = "这仇，我记下了。",
	["$Quanji2"] = "先让你得意几天。",
	
	["Paiyi"] = "排异",
	[":Paiyi"] = "主将技，此武将牌上单独的阴阳鱼个数-1；出牌阶段限一次，你可以移去一张“权”并选择一名角色，令其摸两张牌，然后若其手牌多于你，你对其造成1点伤害。",
	["$Paiyi1"] = "妨碍我的人，都得死！",
	["$Paiyi2"] = "此地，容不下你！",
	
	["Jieao"] = "桀骜",
	[":Jieao"] = "副将技，一名角色的准备阶段开始时，你可将一张“权”置入其一个区域，然后若此区域不为手牌区，你摸一张牌。",
	["@Jieao"] = "你可以对 %src 发动“桀骜”<br/> <b>操作提示</b>: 选择一张“权”→点击确定→然后在对话框中选择目标区域",
	["Jieao:hand"] = "手牌区",
	["Jieao:equip"] = "装备区",
	["Jieao:judge"] = "判定区",
	["$JieaoPut"] = "%from 将 %card 置入 %to 的 %arg",
	["$Jieao1"] = "时机已到，今日起兵！",
	["$Jieao2"] = "欲取天下，当在此时！",
}
sgs.LoadTranslationTable{  --一将成名2012
	["YJCM2012"] = "一将成名2012",
----------------------------------------------------------------------------------------------------
	["#BuLianShi"] = "无冕之后",
	["BuLianShi"] = "步练师",
	["designer:BuLianShi"] = "Anais",
	["illustrator:BuLianShi"] = "勺子妞",
	["~BuLianShi"] = "江之永矣，不可方思……",
	
	["Anxu"] = "安恤",
	[":Anxu"] = "出牌阶段限一次，你可以选择两名手牌数不同的其他角色，令其中手牌少的角色先获得手牌多的角色的一张手牌再展示之，然后若以此法展示的牌不为黑桃，你摸一张牌。",
	["$Anxu1"] = "和鸾雍雍，万福攸同。",
	["$Anxu2"] = "君子乐胥，万邦之屏。",
	
	["Zhuiyi_BuLianShi"] = "追忆",
	[":Zhuiyi"] = "当你死亡时，你可以令一名其他角色（杀死你的角色除外）摸三张牌，然后其回复1点体力。",
	["Zhuiyi-invoke"] = "你可以发动“追忆”<br/> <b>操作提示</b>: 选择一名其他角色→点击确定<br/>",
	["Zhuiyi-invokex"] = "你可以发动“追忆”<br/> <b>操作提示</b>: 选择除 %src 外的一名其他角色→点击确定<br/>",
	["$Zhuiyi_BuLianShi1"] = "终其永怀，恋心殷殷。",
	["$Zhuiyi_BuLianShi2"] = "妾心所系，如月之恒。",
----------------------------------------------------------------------------------------------------
	["#CaoZhang"] = "黄须儿",
	["CaoZhang"] = "曹彰",
	["designer:CaoZhang"] = "潜龙勿用",
	["illustrator:CaoZhang"] = "Yi章",
	["~CaoZhang"] = "子桓，你害我！",
	
	["Jiangchi"] = "将驰",
	[":Jiangchi"] = "摸牌阶段，你可以选择一项：1. 少摸一张牌，然后本回合你使用【杀】无距离限制且可以多使用一张【杀】；2. 多摸一张牌，然后你于此回合内不能使用或打出【杀】。",
	["#Jiangchi-effect"] = "将驰（获得相应效果）",
	["#Jiangchi1"] = "%from 多摸了 <font color=\"yellow\"><b>1</b></font> 张牌",
	["#Jiangchi2"] = "%from 少摸了 <font color=\"yellow\"><b>1</b></font> 张牌",
	["Jiangchi:jiang"] = "额外摸一张牌",
	["Jiangchi:chi"] = "少摸一张牌",
	["$Jiangchi1"] = "谨遵父训，不可称匹夫之勇。",
	["$Jiangchi2"] = "吾定当身先士卒，振魏武雄风！",
----------------------------------------------------------------------------------------------------
	["#ChengPu"] = "三朝虎臣",
	["ChengPu"] = "程普",
	["designer:ChengPu"] = "Michael_Lee",
	["illustrator:ChengPu"] = "G.G.G.",
	["~ChengPu"] = "没，没有酒了……",
	
	["Lihuo"] = "疠火",
	[":Lihuo"] = "你可以将一张普通【杀】当火【杀】使用，若此【杀】造成过伤害，你失去1点体力；你使用火【杀】可以多选择一名目标。",
	["#Lihuo-losehp"] = "疠火（失去体力）",
	["$Lihuo1"] = "将士们，引火对敌！",
	["$Lihuo2"] = "和我同归于尽吧！",
	
	["Chunlao"] = "醇醪",
	[":Chunlao"] = "结束阶段开始时，若你没有“醇”，你可以将至少一张【杀】置于武将牌上，称为“醇”；当一名角色处于濒死状态时，你可以移去一张“醇”，视为该角色使用一张【酒】。",
	["wine"] = "醇",
	["@Chunlao"] = "你可以发动“醇醪”将至少一张【杀】置于武将牌上",
	["@Chunlao-wine"] = "你可以发动“醇醪”令 %src 视为使用一张【酒】",
	["~Chunlao"] = "选择一张“醇”→点击确定",
	["$Chunlao1"] = "无碍，且饮一杯。",
	["$Chunlao2"] = "诶！帐中不可无酒啊！",
----------------------------------------------------------------------------------------------------
	["#GuanXingZhangBao"] = "将门虎子",
	["GuanXingZhangBao"] = "关兴＆张苞",
	["&GuanXingZhangBao"] = "关兴张苞",
	["illustrator:GuanXingZhangBao"] = "HOOO",
	["~GuanXingZhangBao"] = "未能手刃仇敌，愧对先父！",
	
	["Fuhun"] = "父魂",
	[":Fuhun"] = "你可以将两张手牌当【杀】使用或打出；当你于出牌阶段内以此法使用【杀】造成伤害后，你拥有“武圣”和“咆哮”，直到回合结束。",
	["#Fuhun-acquire"] = "父魂（获得“武圣”“咆哮”）",
	["$Fuhun1"] = "光复汉室，重任在肩！",
	["$Fuhun2"] = "将门虎子，承我父志！",
	--["wusheng_GuanXingZhangBao"] = sgs.Sanguosha:translate("wusheng"),
	--["paoxiao_GuanXingZhangBao"] = sgs.Sanguosha:translate("paoxiao"),
	--["#paoxiao-null_GuanXingZhangBao"] = sgs.Sanguosha:translate("#paoxiao-null"),  --dk why cannot
	["wusheng_GuanXingZhangBao"] = "武圣",
	["paoxiao_GuanXingZhangBao"] = "咆哮",
	["#paoxiao-null_GuanXingZhangBao"] = "咆哮（无视防具）",
	["$wusheng_GuanXingZhangBao"] = "一夫当关，万夫莫当！",
	["$paoxiao_GuanXingZhangBao"] = "喝啊！",
----------------------------------------------------------------------------------------------------
	["#HanDang"] = "石城侯",
	["HanDang"] = "韩当",
	["illustrator:HanDang"] = "DH",
	["~HanDang"] = "今后只能靠你了……",
	
	["Gongqi"] = "弓骑",
	[":Gongqi"] = "出牌阶段限一次，你可以弃置一张牌，令你的攻击范围于此回合内无限，然后若你以此法弃置的牌为装备牌，你可以弃置一名其他角色的一张牌。",
	["@Gongqi-discard"] = "你可以弃置一名其他角色的一张牌",
	["$Gongqi1"] = "鼠辈，哪里走！",
	["$Gongqi2"] = "吃我一箭！",
	
	["Jiefan"] = "解烦",
	[":Jiefan"] = "限定技，出牌阶段，你可以选择一名角色，令攻击范围内含有该角色的所有角色各一项：1. 弃置一张武器牌；2. 令其摸一张牌。",
	["@Jiefan-discard"] = "请弃置一张武器牌，否则 %dest 摸一张牌",
	["$Jiefan1"] = "休想趁人之危！",
	["$Jiefan2"] = "退后，这里交给我！",
----------------------------------------------------------------------------------------------------
	["#LiaoHua"] = "历尽沧桑",
	["LiaoHua"] = "廖化",
	["designer:LiaoHua"] = "桃花僧",
	["illustrator:LiaoHua"] = "天空之城",
	["~LiaoHua"] = "今后就靠你们了…….",
	
	["Dangxian_LiaoHua"] = "当先",
	[":Dangxian"] = "锁定技，回合开始时，你执行一个额外的出牌阶段。",
	["$Dangxian_LiaoHua1"] = "先锋就由老夫来当！",
	["$Dangxian_LiaoHua2"] = "看我先行破敌！",
	
	["Fuli"] = "伏枥",
	[":Fuli"] = "限定技，当你处于濒死状态时，你可以将体力值回复至X点（X为势力数），然后叠置。",
	["$Fuli1"] = "今天是个拼命的好日子，哈哈哈哈！",
	["$Fuli2"] = "有老夫在，蜀汉就不会倒下！",
----------------------------------------------------------------------------------------------------
	["#LiuBiao"] = "跨蹈汉南",
	["LiuBiao"] = "刘表",
	["designer:LiuBiao"] = "管乐",
	["illustrator:LiuBiao"] = "关东煮",
	["~LiuBiao"] = "优柔寡断，要不得啊……",
	
	["Zishou"] = "自守",
	[":Zishou"] = "摸牌阶段，若你已受伤，你可以多摸X张牌（X为你已损失的体力值），然后跳过出牌阶段。",
	["$Zishou1"] = "荆襄之地，固若金汤。",
	["$Zishou2"] = "江河霸主，何惧之有！",
	
	["Zongshi_LiuBiao"] = "宗室",
	[":Zongshi"] = "锁定技，你的手牌上限+X（X为势力数）。",
----------------------------------------------------------------------------------------------------
	["#WangYi"] = "决意的巾帼",
	["WangYi"] = "王异",
	["illustrator:WangYi"] = "木美人",
	["~WangYi"] = "月儿，不要责怪你爹爹……",
	
	["Zhenlie_WangYi"] = "贞烈",
	[":Zhenlie"] = "当你成为其他角色使用【杀】或普通锦囊牌的目标后，你可以失去1点体力，令此牌对你无效，然后你弃置其一张牌。",
	["$Zhenlie_WangYi1"] = "虽是妇人，亦当奋身一搏！",
	["$Zhenlie_WangYi2"] = "为雪前耻，不惜吾身！",
	
	["Miji"] = "秘计",
	[":Miji"] = "结束阶段开始时，若你已受伤，你可以摸一至X张牌（X为你已损失的体力值），然后将等量的手牌交给其他角色。",
	["Miji_draw"] = "秘计摸牌数",
	["@Miji"] = "秘计：你须将 %arg 张手牌分配给其他角色",
	["~Miji"] = "选择至少一张手牌→选择一名其他角色→点击确定",
	["$Miji1"] = "此计，可歼敌精锐！",
	["$Miji2"] = "此举，可破敌之围！",
}
sgs.LoadTranslationTable{  --一将成名2013
	["YJCM2013"] = "一将成名2013",
----------------------------------------------------------------------------------------------------
	["#CaoChong"] = "仁爱的神童",
	["CaoChong"] = "曹冲",
	["illustrator:CaoChong"] = "Amo",
	["~CaoChong"] = "子桓哥哥……",
	
	["Chengxiang"] = "称象",
	[":Chengxiang"] = "当你受到伤害后，你可以亮出牌堆顶的四张牌，然后获得其中至少一张点数之和不大于13的牌，并将其余的牌置入弃牌堆。",
	["@Chengxiang"] = "请选择至少一张点数之和<=13的牌",
	["Chengxiang#up"] = "置入弃牌堆",
	["Chengxiang#down"] = "获得",
	["$Chengxiang1"] = "依我看，小事一桩。",
	["$Chengxiang2"] = "孰重孰轻，一称便知。",
	
	["Renxin"] = "仁心",
	[":Renxin"] = "当其他角色受到伤害时，若其体力值为1，你可以弃置一张装备牌，叠置，然后防止此伤害。",
	["@Renxin-card"] = "你可以弃置一张装备牌发动“仁心”防止 %src 受到的伤害",
	["#Renxin"] = "%from 受到的伤害由于“%arg”效果被防止",
	["$Renxin1"] = "仁者爱人，人恒爱之。",
	["$Renxin2"] = "有我在，别怕。",
----------------------------------------------------------------------------------------------------
	["#FuHuangHou"] = "孤注一掷",
	["FuHuangHou"] = "伏皇后",
	["illustrator:FuHuangHou"] = "小莘",
	["~FuHuangHou"] = "陛下为何不救臣妾……",
	
	["Zhuikong"] = "惴恐",
	[":Zhuikong"] = "其他角色的回合开始时，若你已受伤，你可以与其拼点：若你赢，当其于此回合内使用牌时，其取消除其外的目标；若你没赢，该角色无视与你的距离，直到回合结束。",
	["#CancelOtherTargets_Zhuikong"] = "惴恐（取消除你外的目标）",
	["$Zhuikong1"] = "诚惶诚恐，夜不能寐。",
	["$Zhuikong2"] = "嘘，隔墙有耳。",
	
	["Qiuyuan"] = "求援",
	[":Qiuyuan"] = "当你成为【杀】的目标时，你可以令一名除此【杀】使用者外的的其他角色交给你一张【闪】，否则该角色也成为此【杀】的目标。",
	["Qiuyuan-invoke"] = "你可以发动“求援”<br/> <b>操作提示</b>: 选择除此【杀】使用者外的一名其他角色→点击确定<br/>",
	["@Qiuyuan-give"] = "请交给 %src 一张【闪】",
	["$Qiuyuan1"] = "逆贼逞凶，卿可灭之。",
	["$Qiuyuan2"] = "求父亲救救大汉江山吧！", -- 对伏完
----------------------------------------------------------------------------------------------------
	["#GuanPing"] = "忠臣孝子",
	["GuanPing"] = "关平",
	["designer:GuanPing"] = "昂翼天使",
	["illustrator:GuanPing"] = "樱花闪乱",
	["~GuanPing"] = "父亲快走，孩儿断后……",
	
	["Longyin"] = "龙吟",
	[":Longyin"] = "当一名角色于出牌阶段内使用【杀】时，你可以弃置一张牌，令此【杀】不计入次数限制，然后若此【杀】为红色，你摸一张牌。",
	["@Longyin"] = "你可以弃置一张牌发动“龙吟”",
	["$Longyin1"] = "破阵杀敌，愿献犬马之劳！",
	["$Longyin2"] = "虎啸既响，龙吟当附！", -- 红杀
----------------------------------------------------------------------------------------------------
	["#GuoHuai"] = "垂问秦雍",
	["GuoHuai"] = "郭淮",
	["designer:GuoHuai"] = "雪•五月",
	["illustrator:GuoHuai"] = "DH",
	["~GuoHuai"] = "姜维小儿，竟然……",
	
	["Jingce"] = "精策",
	[":Jingce"] = "出牌阶段结束时，若你于此回合内使用过的牌数不小于你的体力值，你可以摸两张牌。",
	["$Jingce1"] = "方策精详，有备无患。",
	["$Jingce2"] = "精兵据敌，策守如山。",
----------------------------------------------------------------------------------------------------
	["#JianYong"] = "优游风议",
	["JianYong"] = "简雍",
	["designer:JianYong"] = "Nocihoo",
	["illustrator:JianYong"] = "Thinking",
	["~JianYong"] = "两国交战……不斩……",
	
	["Qiaoshui"] = "巧说",
	[":Qiaoshui"] = "出牌阶段开始时，你可以与一名其他角色拼点：若你赢，本回合你使用的下一张基本牌或普通锦囊牌可以额外（无距离限制）或少选择一个目标；若你没赢，你不能使用锦囊牌，直到回合结束。",
	["Qiaoshui:add"] = "增加一名目标",
	["Qiaoshui:remove"] = "减少一名目标",
	["@Qiaoshui"] = "你可以发动“巧说”",
	["@Qiaoshui-add"] = "请选择【%arg】的额外目标",
	["@Qiaoshui-remove"] = "请选择【%arg】减少的目标",
	--["~Qiaoshui1"] = "选择一名其他角色→点击确定",
	["~Qiaoshui"] = "选择【借刀杀人】的目标角色→选择【杀】的目标角色→点击确定",
	["$QiaoshuiAdd"] = "%from 发动了“%arg”为 %card 增加了额外目标 %to",
	["#QiaoshuiAdd"] = "%from 发动了“%arg”为【%arg2】增加了额外目标 %to",
	["$QiaoshuiRemove"] = "%from 发动了“%arg”为 %card 减少了目标 %to",
	["#QiaoshuiRemove"] = "%from 发动了“%arg”为【%arg2】减少了目标 %to",
	["$Qiaoshui1"] = "合则两利，斗则两伤。",
	["$Qiaoshui2"] = "君且安坐，听我一言。",
	
	["ZongshiJY"] = "纵适",
	[":ZongshiJY"] = "当你拼点赢后，你可以获得两张拼点的牌中点数小的一张；当你拼点没赢后，你可以获得你拼点的牌。",
	["$ZongshiJY1"] = "买卖不成，情义还在。",
	["$ZongshiJY2"] = "此等小事，何须挂耳？",
----------------------------------------------------------------------------------------------------
	["#LiRu"] = "魔仕",
	["LiRu"] = "李儒",
	["illustrator:LiRu"] = "MSNZero",
	["~LiRu"] = "如遇明主，大业必成……",
	
	["Juece"] = "绝策",
	[":Juece"] = "结束阶段开始时，你可以对一名没有手牌的角色造成1点伤害。",
	["@Juece"] = "你可以发动“绝策”<br/> <b>操作提示</b>: 选择一名没有手牌的角色→点击确定<br/>",
	["$Juece1"] = "哼，你走投无路了。",
	["$Juece2"] = "无用之人，死！",
	
	["Mieji"] = "灭计",
	[":Mieji"] = "出牌阶段限一次，你可以将一张黑色锦囊牌置于牌堆顶并选择一名有手牌的其他角色，该角色弃置一张锦囊牌，否则弃置两张非锦囊牌。",
	["@Mieji-discard"] = "请弃置一张锦囊牌或两张非锦囊牌",
	["~MiejiDiscard"] = "选择一张锦囊牌或两张非锦囊牌→点击确定",
	["$Mieji1"] = "宁错杀，毋放过！",
	["$Mieji2"] = "你能逃得出我的手掌心吗？",
	
	["Fencheng"] = "焚城",
	[":Fencheng"] = "限定技，出牌阶段，你可以令所有其他角色选择一项：1. 弃置至少X张牌（X为上一名进行选择的角色以此法弃置的牌数+1）；2. 受到你造成的2点火焰伤害。",
	["@Fencheng"] = "请弃置至少 %arg 张牌，包括装备区的牌",
	["$Fencheng1"] = "我得不到的，你们也别想得到！",
	["$Fencheng2"] = "让这一切都灰飞烟灭吧！哼哼哼……",
----------------------------------------------------------------------------------------------------
	["#LiuFeng"] = "骑虎之殇",
	["LiuFeng"] = "刘封",
	["designer:LiuFeng"] = "香蒲神殇",
	["illustrator:LiuFeng"] = "Thinking",
	["~LiuFeng"] = "父亲，为什么……",
	
	["Xiansi"] = "陷嗣",
	[":Xiansi"] = "准备阶段开始时，你可以选择一至两名有牌的角色，将这些角色的各一张牌置于武将牌上，称为“逆”；当一名角色需要对你使用【杀】时，其可以移去两张“逆”，视为对你使用【杀】（有距离限制且计入次数限制）。",
	["@Xiansi-card"] = "你可以发动“陷嗣”",
	["~Xiansi"] = "选择 1-2 名角色→点击确定",
	["Xiansi_slash"] = "陷嗣(杀)",
	["counter"] = "逆",
	["$Xiansi1"] = "袭人于不意，溃敌于无形!",
	["$Xiansi2"] = "破敌军阵，父亲定会刮目相看!",
	["$Xiansi3"] = "此乃孟达之计，非我所愿！", -- 被杀
	["$Xiansi4"] = "我有何罪？！", -- 被杀
----------------------------------------------------------------------------------------------------
	["#ManChong"] = "政法兵谋",
	["ManChong"] = "满宠",
	["designer:ManChong"] = "SamRosen",
	["illustrator:ManChong"] = "Aimer彩三",
	["~ManChong"] = "援军为何迟迟未到……",
	
	["Junxing"] = "峻刑",
	[":Junxing"] = "出牌阶段限一次，你可以弃置至少一张手牌并选择一名其他角色：令其选择一项：1. 弃置一张与你弃置的牌类型均不同的手牌；2. 叠置，然后摸等量的牌。",
	["@Junxing-discard"] = "请弃置一张与“峻刑”弃牌类型均不同的手牌",
	["$Junxing1"] = "严刑峻法，以破奸诡之胆。",
	["$Junxing2"] = "你招还是不招？",
	
	["Yuce"] = "御策",
	[":Yuce"] = "当你受到伤害后，你可以展示一张手牌，若如此做且此伤害有来源，伤害来源须弃置一张与此牌类型不同的手牌，否则你回复1点体力。",
	["@Yuce-show"] = "你可以发动“御策”展示一张手牌",
	["@Yuce-discard"] = "%src 发动了“御策”，请弃置一张 %arg 或 %arg2",
	["$Yuce1"] = "御敌之策，成竹在胸。",
	["$Yuce2"] = "以缓制急，不战屈兵。",
----------------------------------------------------------------------------------------------------
	["#PanZhangMaZhong"] = "擒龙伏虎",
	["PanZhangMaZhong"] = "潘璋＆马忠",
	["&PanZhangMaZhong"] = "潘璋马忠",
	["designer:PanZhangMaZhong"] = "風残葉落",
	["illustrator:PanZhangMaZhong"] = "zzyzzyy",
	["~PanZhangMaZhong"] = "怎么可能，我明明亲手将你……",
	
	["Duodao"] = "夺刀",
	[":Duodao"] = "当你受到【杀】造成的伤害后，你可以弃置一张牌，获得伤害来源装备区里的武器牌。",
	["@Duodao-get"] = "你可以弃置一张牌发动“夺刀”",
	["$Duodao1"] = "这刀岂是你配用的？",
	["$Duodao2"] = "夺敌兵刃，如断其臂！",
	
	["Anjian"] = "暗箭",
	[":Anjian"] = "锁定技，当你使用【杀】对目标角色造成伤害时，若你不在其攻击范围内，你令此伤害+1。",
	["#AnjianBuff"] = "%from 的“<font color=\"yellow\"><b>暗箭</b></font>”效果被触发，伤害从 %arg 点增加至 %arg2 点",
	["$Anjian1"] = "击其懈怠，攻其不备！",
	["$Anjian2"] = "哼，你满身都是破绽！",
----------------------------------------------------------------------------------------------------
	["#YuFan"] = "狂直之士",
	["YuFan"] = "虞翻",
	["designer:YuFan"] = "幻岛",
	["illustrator:YuFan"] = "L",
	["~YuFan"] = "我枉称东方朔再世……",
	
	["Zongxuan"] = "纵玄",
	[":Zongxuan"] = "当你的牌因弃置而置入弃牌堆后，你可以将其中至少一张牌置于牌堆顶。",
	["@Zongxuan"] = "请选择至少一张牌置于牌堆顶", 
	["Zongxuan#up"] = "弃置",
	["Zongxuan#down"] = "置于牌堆顶",
	["$Zongxuan1"] = "依易设象，以占吉凶。",
	["$Zongxuan2"] = "世间万物皆有定数。",
	
	["Zhiyan"] = "直言",
	[":Zhiyan"] = "结束阶段开始时，你可以令一名角色摸一张牌并展示之，若此牌为装备牌，该角色使用之，然后其回复1点体力。",
	["Zhiyan-invoke"] = "你可以发动“直言”<br/> <b>操作提示</b>: 选择一名角色→点击确定<br/>",
	["$Zhiyan1"] = "志节分明，折而不屈。",
	["$Zhiyan2"] = "直言劝谏，不惧祸否。",
----------------------------------------------------------------------------------------------------
	["#ZhuRan"] = "不动之督",
	["ZhuRan"] = "朱然",
	["illustrator:ZhuRan"] = "Ccat",
	["~ZhuRan"] = "何人..竟有如此之胆、" ,
	
	["Danshou"] = "胆守",
	[":Danshou"] = "出牌阶段，你可以弃置X张牌并选择攻击范围内的一名角色，若X：为1，你弃置其一张牌；为2，其将一张牌交给你；为3，你对其造成1伤害；不小于4，你与其各摸两张牌。（X为你于此阶段内已发动“胆守”的次数+1）",
	["@Danshou-give"] = "请交给 %dest 一张牌",
	["$Danshou1"] = "到此为止了",
	["$Danshou2"] = "以胆为守，扼敌咽喉",
}
sgs.LoadTranslationTable{  --一将成名2014
	["YJCM2014"] = "一将成名2014",
----------------------------------------------------------------------------------------------------
	["#CaiFuRen"] = "襄江的蒲苇",
	["CaiFuRen"] = "蔡夫人",
	["illustrator:CaiFuRen"] = "Dream彼端",
	["designer:CaiFuRen"] = "B.LEE",
	["~CaiFuRen"] = "孤儿寡母，何必赶尽杀绝呢" ,
	
	["Qieting"] = "窃听",
	[":Qieting"] = "其他角色的回合结束后，若其未于此回合内使用过牌指定除其外的角色为目标，你可以选择一项：1. 将其装备区里的一张牌置入你的装备区；2. 摸一张牌。",
	["Qieting:0"] = "移动武器牌",
	["Qieting:1"] = "移动防具牌",
	["Qieting:2"] = "移动+1坐骑",
	["Qieting:3"] = "移动-1坐骑",
	["Qieting:4"] = "移动宝物牌",
	["Qieting:draw"] = "摸一张牌",
	["$Qieting1"] = "此人不露锋芒，断不可留",
	["$Qieting2"] = "想削我蔡氏，痴心妄想",
	
	["Xianzhou"] = "献州",
	[":Xianzhou"] = "限定技，出牌阶段，你可以将装备区里的所有牌交给一名其他角色，令其选择一项：1. 令你回复X点体力；2. 对其攻击范围内的一至X名角色各造成1点伤害。（X为你以此法交给该角色的牌数）",
	["@Xianzhou-damage"] = "请对攻击范围内的 1 至 %arg 名角色各造成 1 点伤害，或点“取消”令 %src 回复 %arg 点体力",
	["@Xianzhou-damage2"] = "请对攻击范围内的 1 至 %arg 名角色各造成 1 点伤害",
	["~Xianzhou"] = "选择若干名角色→点击确定",
	["$Xianzhou1"] = "丞相挟天威而至，吾等安敢不降",
	["$Xianzhou2"] = "献荆襄九郡，图一世之安",
}
sgs.LoadTranslationTable{  --一将成名2015
	["YJCM2015"] = "一将成名2015",
----------------------------------------------------------------------------------------------------
	["#CaoRui"] = "天姿的明君",
	["CaoRui"] = "曹叡",
	["designer:CaoRui"] = "Ptolemy_M7",
	["illustrator:CaoRui"] = "Thinking",
	["~CaoRui"] ="悔不该沉于逸乐，致有今日。",
	
	["Huituo_CaoRui"] = "恢拓",
	[":Huituo"] = "当你受到伤害后，你可以选择一名角色，亮出牌堆顶的一张牌，若此牌为：红色，该角色回复1点体力；黑色，该角色摸X张牌（X为此次伤害的伤害数）。最后你将此牌置入弃牌堆。",
    ["Huituo-select"] = "你可以发动“恢拓”<br/> <b>操作提示</b>: 选择一名角色→点击确定<br/>",
	["$Huituo_CaoRui1"] = "大展宏图就在今日。",
	["$Huituo_CaoRui2"] = "富我大魏，扬我国威。",
	
	["Mingjian"] = "明鉴",
	[":Mingjian"] = "你可以跳过出牌阶段并将所有手牌交给一名其他角色，若如此做，你结束此回合，然后该角色进行一个额外的出牌阶段。",
	["#Mingjian-give"] = "明鉴（进行额外的出牌阶段）",
    ["Mingjian-give"] = "你可以发动“明鉴”<br/> <b>操作提示</b>: 选择一名其他角色→点击确定<br/>",
	["$Mingjian1"] = "你我推心置腹，岂能相负。",
	["$Mingjian2"] = "孰忠孰奸，朕尚能明辨。",
----------------------------------------------------------------------------------------------------
	["#ZhangNi"] = "通壮逾古",
	["ZhangNi"] = "张嶷",
	["designer:ZhangNi"] = "桃花僧",
	["illustrator:ZhangNi"] = "livsinno",
	["~ZhangNi"] ="大丈夫当战死沙场，马革裹尸而还。",
	
	["Wurong"] = "怃戎",
	[":Wurong"] = "出牌阶段限一次，你可以令一名其他角色与你同时展示一张手牌，然后若你展示的牌是【杀】且该角色展示的牌不是【闪】，你弃置此【杀】，对其造成1点伤害；若你展示的牌不是【杀】且该角色展示的牌是【闪】，你弃置你展示的牌，获得其一张牌。",
	["@Wurong-show"] = "<font color=\"yellow\">抚戎</font> 请展示一张手牌" ,
	["$Wurong1"] = "兵不血刃，亦可先声夺人。。",
	["$Wurong2"] = "从，则安之，犯，则诛之。",
	
    ["Shizhi"] = "矢志",
	[":Shizhi"] = "锁定技，若你的体力值为1，你的【闪】视为【杀】。",
}
sgs.LoadTranslationTable{  --原创之魂2016
	["YCZH2016"] = "原创之魂2016",
----------------------------------------------------------------------------------------------------
	["#ZhangRang"] = "窃幸绝禋", 
	["ZhangRang"] = "张让", 
	["illustrator:ZhangRang"] = "蚂蚁君",
	["~ZhangRang"] = "臣等殄灭，唯陛下自爱~~~噗......",
	
	["Taoluan"] = "滔乱", 
	[":Taoluan"] = "当你需要使用基本牌或普通锦囊牌时，你可以视为使用此牌（不能是你以此法使用过的牌），若如此做，你令一名其他角色选择一项：1. 将与此牌类别不同的一张牌交给你；2. 令你失去1点体力。", 
	["#Taoluan-ask"] = "滔乱（令一名其他角色选择一项）",
	["@Taoluan-ask"] = "请选择一名其他角色执行“滔乱”的效果",
	["@Taoluan-give"] = "请将一张 %arg 或 %arg2 交给 %src，否则其将失去1点体力",
	["#TaoluanAsk"] = "%from 执行了“%arg”的效果，目标是 %to",
	["Taoluan_saveself"] = "“滔乱”【桃】或【酒】",
	["Taoluan_slash"] = "“滔乱”【杀】",
	["Taoluan_nullification"] = "“滔乱”【无懈可击】",
	["normal_slash"] = "普通杀",
	["$Taoluan1"] = "睁开你的眼睛看看，现在，是谁说了算", 
	["$Taoluan2"] = "国家承平，神器稳固，陛下勿忧~", 
}
sgs.LoadTranslationTable{  --SP
	["SPGenerals"] = "SP",  --与其他luaer的“SP”包重名
----------------------------------------------------------------------------------------------------
	["#XingCai"] = "敬哀皇后",
	["XingCai"] = "星彩",
	["illustrator:XingCai"] = "depp",
	["~XingCai"] = "复兴汉室之路，臣妾再也不能陪伴左右。" ,
	
	["Shenxian"] = "甚贤",
	[":Shenxian"] = "你的回合外，当其他角色因弃置而失去基本牌后，你可以摸一张牌。",
	["$Shenxian1"] = "抚慰军心，以安国事。" ,
	["$Shenxian2"] = "愿尽己力，为君分忧。" ,
	
	["Qiangwu"] = "枪舞",
	["Qiangwu_XingCai"] = "枪舞",
	[":Qiangwu"] = "出牌阶段限一次，你可以进行判定，然后本回合，你使用点数小于判定结果的【杀】无距离限制，你使用点数大于判定结果的【杀】不计入次数限制。",
	["$Qiangwu_XingCai1"] = "咆哮沙场，万夫不敌！" ,
	["$Qiangwu_XingCai2"] = "父亲未竟之业，由我继续！" ,
----------------------------------------------------------------------------------------------------
	["#ZuMao"] = "碧血染赤帻",
	["ZuMao"] = "祖茂",
	["illustrator:ZuMao"] = "DH",
	["~ZuMao"] = "孙将军，已经安全了吧。" ,
	
	["Yinbing_ZuMao"] = "引兵",
	[":Yinbing"] = "结束阶段开始时，你可以将至少一张非基本牌置于武将牌上；当你受到【杀】或【决斗】的伤害后，你移去一张“引兵”牌。",
	["#Yinbing-throw_ZuMao"] = "引兵（移去一张“引兵”牌）",
	["@Yinbing"] = "你可以发动“引兵”将至少一张非基本牌置于武将牌上",
	["@Yinbing-throw"] = "请移去一张“引兵”牌",
	["@Yinbing-throw-noncomp"] = "你可以移去一张“引兵”牌",
	["$Yinbing_ZuMao1"] = "将军走此小道，追兵教我应付！" ,
	["$Yinbing_ZuMao2"] = "追兵凶芒，末将断后！" ,
	
	["Juedi"] = "绝地",
	[":Juedi"] = "准备阶段开始时，若你有“引兵”牌，你可以选择一项：1. 移去“引兵”牌，然后摸等量的牌；2. 令一名体力值不大于你且已受伤的其他角色回复1点体力，然后其获得“引兵”牌。",
	["Juedi-invoke"] = "你可以发动“绝地”<br/> <b>操作提示</b>: 选择你或一名体力值不大于你的其他角色→点击确定",
	["$Juedi1"] = "提起武器，最后一搏！" ,
	["$Juedi2"] = "困兽之斗，以诠忠义！" ,
----------------------------------------------------------------------------------------------------
	["#ZhuGeDan"] = "薤露蒿里",
	["ZhuGeDan"] = "诸葛诞",
	["illustrator:ZhuGeDan"] = "雪君S",
	["~ZhuGeDan"] = "诸葛一氏定会为我复仇！" ,
	
	["Gongao"] = "功獒",
	[":Gongao"] = "锁定技，当其他角色死亡后，你加1点体力上限，然后回复1点体力。",
	["$Gongao1"] = "恪尽职守，忠心侍主。" ,
	["$Gongao2"] = "攻城拔寨，建功立业。" ,
	
	["Weizhong"] = "威重",
	[":Weizhong"] = "主将技，锁定技，当你加/减体力上限后，你摸一张牌；主将技，锁定技，你拥有“崩坏”。",
	["#benghuai_ZhuGeDan"] = "崩坏",
	["$Weizhong1"] = "司马氏篡权，我当替天伐之！" ,
	["$Weizhong2"] = "定当夷司马氏三族！" ,
	["$benghuai_ZhuGeDan"] = "咳咳咳...",
----------------------------------------------------------------------------------------------------
	["#ChengYu"] = "泰山捧日",
	["ChengYu"] = "程昱",
	["&ChengYu"] = "程昱",
	["illustrator:ChengYu"] = "GH",
	["~ChengYu"] = "此诚报效国家之时，吾却休矣……" ,
	
	["Shefu"] = "设伏",
	[":Shefu"] = "结束阶段开始时，你可以将一张手牌扣置于武将牌旁，称为“伏兵”，并为该牌记录一张基本牌或锦囊牌的牌名（与其他“伏兵”均不相同）；你的回合外，当其他角色使用手牌时，若此牌的牌名与一张“伏兵”的记录相同，你可以将此“伏兵”置入弃牌堆，令此牌无效。",
	["ambush"] = "伏兵",
	["@Shefu-prompt"] = "你可以发动“设伏”<br/> <b>操作提示</b>: 点击右下角绿色按钮→在对话框中选择牌名→选择一张手牌→点击确定<br/>",
	--["~Shefu"] = "在对话框中选择牌名→选择一张手牌→点击确定",
	["#Shefu-cancel"] = "设伏（令牌无效）",
	["#Shefu-cancel-jink"] = "设伏（闪无效）",
	["Shefu_cancel:data"] = "你可以发动“设伏”令【%arg】无效<br/> <b>注</b>: 若你无对应牌名的“伏兵”则没有任何效果",
	["$ShefuRecord"] = "%from 为 %card 记录牌名【%arg】",
	["#ShefuEffect"] = "%from 发动了“%arg2”，%to 使用的【%arg】无效",
	["Shefu:ShefuAskAll"] = "所有牌均询问",
	["Shefu:ShefuAskNecessary"] = "只询问被记录的牌",
	["$Shefu1"] = "圈套已设，埋伏已完，只等敌军进来。" ,
	["$Shefu2"] = "如此天网，谅你插翅也难逃！" ,
	
	["Benyu"] = "贲育",
	[":Benyu"] = "当你受到伤害后，若伤害来源存活且你的手牌数：小于X，你可以将手牌补至X（至多为5）张；大于X，你可以弃置至少X+1张手牌，对伤害来源造成1点伤害。（X为伤害来源的手牌数）",
	["@Benyu-discard"] = "你可以发动“贲育”弃置至少 %arg 张手牌对 %dest 造成1点伤害",
	["~Benyu"] = "选择足量的手牌→点击确定",
	["$Benyu1"] = "天下大乱，群雄并起，必有命示。" ,
	["$Benyu2"] = "曹公智略，乃上天所授。" ,
}
sgs.LoadTranslationTable{  --界限突破SP
	["JSP"] = "界限突破SP",
----------------------------------------------------------------------------------------------------
	["#GuanYu_JSP"] = "汉寿亭侯",
	["GuanYu_JSP"] = "关羽-界SP",
	["&GuanYu_JSP"] = "关羽",
	["illustrator:GuanYu_JSP"] = "Zero",
	["~GuanYu_JSP"] = "樊城一去，死亦无惧。",
	
	["wusheng_GuanYu_JSP"] = "武圣",
	["$wusheng_GuanYu_JSP1"] = "义经逆流！吾按礼数！",
	["$wusheng_GuanYu_JSP2"] = "以义传魂，以武入圣！",
	
	["Zhongyi"] = "忠义",
	[":Zhongyi"] = "主将技，限定技，出牌阶段，你可以将一张红色手牌置于武将牌上，若如此做，准备阶段开始时，你将“忠义”牌置入弃牌堆；当与你势力相同的角色使用【杀】对目标角色造成伤害时，若你有“忠义”牌，你令此伤害+1。",
	["loyal"] = "忠义",
	["#Zhongyi-action"] = "忠义（伤害+1）",
	["#Zhongyi-clear"] = "忠义（将“忠义”牌置入弃牌堆）",
	["#ZhongyiBuff"] = "%from 的“<font color=\"yellow\"><b>忠义</b></font>”效果被触发，伤害从 %arg 点增加至 %arg2 点",
	["$Zhongyi1"] = "为国尽忠，天经地义！",
	["$Zhongyi2"] = "忠义是为将之本！",
	
	["Mashu_GuanYu_JSP"] = "马术",
	[":Mashu"] = "副将技，锁定技，你与其他角色的距离-1。",
	
	["Nuzhan"] = "怒斩",
	[":Nuzhan"] = "副将技，锁定技，你使用的由一张锦囊牌转化的【杀】不计入限制的使用次数；锁定技，你使用的由一张装备牌转化的【杀】的伤害值基数+1。",
	["Nuzhan:trick"] = "你可以发动“怒斩”令此【杀】不计入限制的使用次数",
	["Nuzhan:equip"] = "你可以发动“怒斩”令此【杀】的伤害值基数+1",
	["#NuzhanBuff"] = "%from 的“<font color=\"yellow\"><b>怒斩</b></font>”效果被触发，伤害从 %arg 点增加至 %arg2 点",
	["$Nuzhan1"] = "单骑护嫂千里，只为桃园之义！",
	["$Nuzhan2"] = "孤身远涉，赤心归国！",
}
sgs.LoadTranslationTable{  --RE修订武将
	["RE"] = "RE修订武将",
----------------------------------------------------------------------------------------------------
	["#YuJin_RE"] = "魏武之刚",
	["YuJin_RE"] = "于禁-RE",
	["&YuJin_RE"] = "于禁",
	["illustrator:YuJin_RE"] = "Yi章",
	["~YuJin_RE"] = "忍辱偷生，无颜以面丞相厚恩……" ,
	
	["Jieyue"] = "节钺",
	[":Jieyue"] = "结束阶段开始时，你可以弃置一张手牌并选择一名其他角色，令其选择一项：将一张牌置于你的武将牌上；或令你弃置其一张牌。若你有“节钺”牌，你可以将红色手牌当【闪】、黑色的手牌当【无懈可击】使用或打出；准备阶段开始时，你获得“节钺”牌。",
	["#Jieyue-obtain"] = "节钺（获得“节钺”牌）",
	["@Jieyue"] = "你可以发动“<font color=\"yellow\"><b>节钺</b></font>”",
	["~Jieyue"] = "选择一张手牌并选择一名目标角色→点击确定",
	["@Jieyue-put"] = "%src 对你发动了“<font color=\"yellow\"><b>节钺</b></font>”，请将一张牌置于其武将牌上，或点“取消”令其弃置你的一张牌",
	["Jieyue_pile"] = "节钺",
	["$JieyueObtain"] = "%from 触发“<font color=\"yellow\"><b>节钺</b></font>”，获得了武将牌上的 %card",
	["$Jieyue1"] = "安营驻寨，严守城防！" ,
	["$Jieyue2"] = "诸军严整，敌军自乱！" ,
----------------------------------------------------------------------------------------------------
	["#MaDai_RE"] = "临危受命",
	["MaDai_RE"] = "马岱-RE",
	["&MaDai_RE"] = "马岱",
	["illustrator:MaDai_RE"] = "琛·美弟奇",
	["~MaDai_RE"] = "我怎么会死在这里……",
	
	["QianxiRE"] = "潜袭",
	[":QianxiRE"] = "准备阶段开始时，你可以摸一张牌，然后弃置一张牌，若如此做，你令距离为1的一名角色于此回合内不能使用或打出与你以此法弃置的牌颜色相同的手牌。",
	["@QianxiRE"] = "请弃置 1 张牌，包括装备区的牌",
	["$QianxiRE1"] = "喊什么喊，我敢杀你。",
	["$QianxiRE2"] = "笑什么笑，叫你得意。",
	
	["mashu_MaDai_RE"] = "马术",
----------------------------------------------------------------------------------------------------
	["#XuSheng_RE"] = "江东的铁壁",
	["XuSheng_RE"] = "徐盛-RE",
	["&XuSheng_RE"] = "徐盛",
	["illustrator:XuSheng_RE"] = "天空之城",
	["~XuSheng_RE"] = "盛不能奋身出命，不亦辱乎。",
	
	["PojunRE"] = "破军",
	[":PojunRE"] = "当你于出牌阶段内使用【杀】指定一个目标后，你可以将其一至X张牌扣置于其武将牌旁（X为其体力值），若如此做，当前回合结束后，其获得这些牌。",
	["#PojunRE-return"] = "破军（获得“破军牌”）",
	["PojunRE_num"] = "破军扣置牌数",
	["$PojunRE1"] = "大军在此！汝等休想前进一步！",
	["$PojunRE2"] = "敬请养精蓄锐！",
}
sgs.LoadTranslationTable{  --OL专属
	["OL"] = "OL专属",
----------------------------------------------------------------------------------------------------
	["#MaYunLu"] = "剑胆琴心",
	["MaYunLu"] = "马云禄",
	["illustrator:MaYunLu"] = "木美人",
	["~MaYunLu"] = "呜呜呜~~~是你们欺负人" ,
	
	["Fengpo"] = "凤魄", 
	[":Fengpo"] = "当你于出牌阶段内使用第一张【杀】或【决斗】指定目标后，若目标数为1，你可以选择一项：1. 摸X张牌；2. 此牌伤害值+X（X为目标角色手牌中的方块牌数）。", 
	["#Fengpo-adddamage"] = "凤魄（伤害值+X）", 
	["Fengpo:drawCards"] = "摸X张牌", 
	["Fengpo:addDamage"] = "此牌伤害值+X", 
	["$FengpoInvoke"] = "%from 令 %card 的伤害值+X",
	["#FengpoInvoke"] = "%from 令【%arg】的伤害值+X",
	["#FengpoBuff"] = "%from 执行了“<font color=\"yellow\"><b>凤魄</b></font>”的效果，伤害从 %arg 点增加至 %arg2 点",
	["$Fengpo1"] = "等我提枪上马，打你个落花流水。", 
	["$Fengpo2"] = "对付你，用不着我家哥哥亲自上阵。", 
	
	["mashu_MaYunLu"] = "马术",
----------------------------------------------------------------------------------------------------
	["#WuTuGu"] = "霸体金刚",
	["WuTuGu"] = "兀突骨",
	["illustrator:WuTuGu"] = "biou09&KayaK",
	["~WuTuGu"] = "撤..快撤！",
	
	["Ranshang"] = "燃殇", 
	[":Ranshang"] = "锁定技，当你首次明置此武将牌后，你加X点体力上限，然后回复X点体力（X为15-你的体力上限）；当你受到1点火焰伤害后，你获得1枚“燃”标记；结束阶段开始时，你失去Y点体力（Y为“燃”标记数）。", 
	["@ranshang"] = "燃",
	["$Ranshang1"] = "战火燃尽英雄胆~",
	["$Ranshang2"] = "尔等竟如此歹毒！",
	
	["Hanyong"] = "悍勇", 
	[":Hanyong"] = "当你使用【南蛮入侵】或【万箭齐发】时，若你的体力值小于轮数，你可以令此牌的伤害值基数+1。", 
	["#Hanyong-adddamage"] = "悍勇（令伤害值+1）", 
	["#HanyongBuff"] = "%from 执行了“<font color=\"yellow\"><b>悍勇</b></font>”的效果，伤害从 %arg 点增加至 %arg2 点",
	["$Hanyong1"] = "犯我者，杀！",
	["$Hanyong2"] = "藤甲军从无对手，不服来战！",
----------------------------------------------------------------------------------------------------
	["#WangJi"] = "经行合一",
	["WangJi"] = "王基",
	["illustrator:WangJi"] = "雪君S",
	["~WangJi"] = "天下之事，必归大魏，可恨未能得见啊……",
	
	["Qizhi"] = "奇制",
	[":Qizhi"] = "当你于回合内使用基本牌或锦囊牌指定目标后，你可以选择一名不是此牌目标的角色，弃置其一张牌，然后其摸一张牌。",
	["Qizhi-choice"] = "你可以发动“奇制”<br/> <b>操作提示</b>: 选择一名不是此【%arg】目标的角色→点击确定<br/>",
	["$Qizhi1"] = "声东击西，敌寇，一网成擒！",
	["$Qizhi2"] = "吾意不在此地，已遣别部出发。",
	
	["Jinqu"] = "进趋",
	[":Jinqu"] = "结束阶段开始时，你可以摸两张牌，然后将手牌弃置至X张（X为此回合内你发动“奇制”的次数）。",
	["Jinqu:HandNumMax"] = "你可以发动“进趋”摸两张牌，然后将手牌弃置至 %arg 张",
	["$Jinqu1"] = "建上昶水城，以逼夏口！",
	["$Jinqu2"] = "通川聚粮，伐吴之业，当步步为营。",
----------------------------------------------------------------------------------------------------
	["#TaDun"] = "北狄王", 
	["TaDun"] = "蹋顿", 
	["illustrator:TaDun"] = "未知",
	["~TaDun"] = "呃~不该~趟曹袁之争的浑水~", 
	
	["Luanzhan"] = "乱战", 
	[":Luanzhan"] = "当一名角色因受到伤害而扣减体力前，若来源为你，你获得1枚“乱战”标记；你使用【杀】或黑色普通锦囊牌可以多选择一至X名目标；当你使用【杀】或黑色普通锦囊牌指定目标后，若目标数小于X，你弃所有“乱战”标记。（X为“乱战”标记数）",
	["@luanz"] = "乱战",
	["#Luanzhan-mark"] = "乱战（获得标记）",
	["#Luanzhan-zero"] = "乱战（弃所有标记）",
	["Luanzhan:Mark"] = "你想发动“乱战”获得1枚“乱战”标记吗？",
	["@Luanzhan-add"] = "你可以发动“乱战”为【%arg】多选择至多 %arg2 名目标",
	["~Luanzhan1"] = "选择【借刀杀人】的目标角色→选择【杀】的目标角色→点击确定",
	["~Luanzhan2"] = "选择【联军盛宴】的目标角色（每势力仅需选择一名）→点击确定",
	["$LuanzhanAdd"] = "%from 发动了“%arg”为 %card 增加了额外目标 %to",
	["#LuanzhanAdd"] = "%from 发动了“%arg”为【%arg2】增加了额外目标 %to",
	["$LuanzhanRemove"] = "%from 发动了“%arg”为 %card 减少了目标 %to",
	["#LuanzhanRemove"] = "%from 发动了“%arg”为【%arg2】减少了目标 %to",
	["Luanzhan:Zero"] = "你想发动“乱战”弃所有“乱战”标记吗？",
	["$Luanzhan1"] = "现，正是我乌桓崛起之机！",
	["$Luanzhan2"] = "受袁氏大恩，当效死力！",
----------------------------------------------------------------------------------------------------
	["#YanBaiHu"] = "豺牙落涧", 
	["YanBaiHu"] = "严白虎", 
	["illustrator:YanBaiHu"] = "未知",
	["~YanBaiHu"] = "严舆吾弟，为兄来陪你了~", 
	
	["Zhidao"] = "雉盗", 
	[":Zhidao"] = "锁定技，当你于出牌阶段内对一名其他角色造成伤害后，若此伤害是你本回合造成的第一次伤害，且该角色的区域内有牌，你获得其所有区域内的各一张牌，若如此做，当你于此回合内使用牌时，你取消除你外的目标。", 
	["$Zhidao1"] = "谁有地盘，谁（就）是老大！", 
	["$Zhidao2"] = "乱世之中，能者为王！", 
	
	["JiliYBH"] = "寄篱", 
	[":JiliYBH"] = "锁定技，当其他角色成为红色基本牌或红色普通锦囊牌的目标时，若该角色与你的距离为1，且你不是此牌的使用者或目标，你也成为此牌的目标。",
	["@JiliYBHCollateral"] = "请选择 %src 使用【杀】的目标",
	["$JiliYBH1"] = "寄人篱下的日子，不好过啊~", 
	["$JiliYBH2"] = "这份恩德，白虎记下了~",  
----------------------------------------------------------------------------------------------------
	["#GuanSuo"] = "倜傥子侠", 
	["GuanSuo"] = "关索", 
	["illustrator:GuanSuo"] = "depp",
	["~GuanSuo"] = "只恨天下未平，空留遗志~", 
	
	["Zhengnan"] = "征南", 
	[":Zhengnan"] = "当其他角色死亡后，你可以摸三张牌，然后获得下列技能之一：“武圣”、“制蛮”、“当先”。", 
	["wusheng_GuanSuo"] = "武圣",
	["Zhiman_GuanSuo"] = "制蛮",
	["#Zhiman-second_GuanSuo"] = "制蛮（获得目标装备区或判定区里的一张牌）",
	["Dangxian_GuanSuo"] = "当先",
	["$Zhengnan"] = "末将愿承父志，随丞相出征~", 
	["$wusheng_GuanSuo"] = "逆贼！可识得关氏之勇！", 
	["$Zhiman_GuanSuo"] = "蛮夷可抚，不能剿。", 
	["$Dangxian_GuanSuo"] = "各位将军，且让小辈先行出战！", 
	
	["Xiefang"] = "撷芳", 
	[":Xiefang"] = "锁定技，你与其他角色的距离-X（X为女性角色数）。", 
----------------------------------------------------------------------------------------------------
	["WangLang"] = "王朗",
	["#WangLang"] = "凤鹛",
	["illustrator:WangLang"] = "銘zmy",
	["~WangLang"] = "你、你……啊……",
	
	["Gushe"] = "鼓舌",
	[":Gushe"] = "出牌阶段限一次，你可以用一张手牌与至多三名角色同时拼点，然后依次结算拼点结果，没赢的角色选择一项：1.弃置一张牌；2.令你摸一张牌。若拼点没赢的角色是你，你需先获得一个“饶舌”标记（你有7个饶舌标记时，你死亡）。",
	["#Gushe-punish"] = "鼓舌（弃牌或令王朗摸牌）",
	["@tongue"] = "饶舌",
	["@GusheDiscard"] = "请弃置一张牌，否则 %src 摸一张牌",
	["$Gushe1"] = "公既知天命，识时务，为何要兴无名之师？犯我疆界？", 
	["$Gushe2"] = "你若倒戈卸甲，以礼来降，仍不失封侯之位，国安民乐，岂不美哉？", 
	
	["Jici"] = "激词",
	[":Jici"] = "当你发动“鼓舌”拼点的牌亮出后，若此牌的点数：小于X，你可令此牌的点数于此次拼点中+X；等于X，你于此阶段内可以多发动一次“鼓舌”。（X为你的“饶舌”标记数）",
	["#Jici-increase"] = "激词（令点数+X）",
	["#Jici-extra"] = "激词（令鼓舌次数上限+1）",
	["Jici:Increase"] = "你可发动“激词”令你拼点的牌点数 + %arg",
	["#JiciIncrease"] = "%from 发动了“<font color=\"yellow\"><b>激词</b></font>”，拼点的牌点数增加为 %arg",
	["Jici:Extra"] = "你可发动“激词”令你可以多发动一次“鼓舌”",
	["#JiciExtra"] = "%from 拼点的牌点数为 %arg （与“饶舌”标记数相同），可以多发动一次“<font color=\"yellow\"><b>鼓舌</b></font>”",
	["$Jici1"] = "量尔等腐草之萤光，如何比得上天空之皓月~", 
	["$Jici2"] = "你……诸葛村夫，你敢……", 
----------------------------------------------------------------------------------------------------
	["#BuZhi"] = "积硅靖边",
	["BuZhi"] = "步骘",
	["illustrator:BuZhi"] = "sinno",
	["~BuZhi"] = "胶州已定，主公~尽可放心......",
	
	["Hongde"] = "弘德",
	[":Hongde"] = "当你获得或失去至少两张牌后，你可以令一名其他角色摸一张牌。每名角色的回合限四次。",
	["Hongde-invoke"] = "你可以发动“弘德”<br/> <b>操作提示</b>: 选择一名角色→点击确定<br/>",
	["$Hongde1"] = "德无单行，福必双至。",
	["$Hongde2"] = "江南重义，东吴尚德。",
	
	["Dingpan"] = "定叛",
	[":Dingpan"] = "出牌阶段限X次（X为大势力角色数且至少为1），你可以令一名装备区里有牌的角色摸一张牌，然后其选择一项：1.令你弃置其装备区里的一张牌；2.获得其装备区里的所有牌，若如此做，你对其造成1点伤害。",
	["Dingpan:discard"] = "令步骘弃置你装备区里的一张牌", 
	["Dingpan:damage"] = "你获得装备区里的所有牌，然后步骘对你造成1点伤害", 
	["$Dingpan1"] = "从孙者生，从刘者死！",
	["$Dingpan2"] = "多行不义，必自毙！",
----------------------------------------------------------------------------------------------------
	["#LiTong"] = "万亿吾独往",
	["LiTong"] = "李通",
	["illustrator:LiTong"] = "瞎子Ghe",
	["~LiTong"] = "战死沙场，快哉！",
	
	["Tuifeng"] = "推锋",
	[":Tuifeng"] = "当你受到1点伤害后，你可以将一张牌置于武将牌上，称为“锋”；准备阶段开始时，若你的武将牌上有“锋”，你移去所有“锋”，摸2X张牌，若如此做，你于此回合的出牌阶段内可以多使用X张【杀】（X为你此次移去的“锋”数）。",
	["#Tuifeng-throw"] = "推锋（移去所有“锋”）",
	["lead"] = "锋",
	["@lead"] = "锋",
	["TuifengPush"] = "你可以发动“推锋”<br/> <b>操作提示</b>: 选择一张牌→点击确定",
	["$Tuifeng1"] = "摧锋陷阵，以杀贼首！",
	["$Tuifeng2"] = "敌锋之锐，我已尽知。",
----------------------------------------------------------------------------------------------------
	["#MiZhu"] = "挥金追义",
	["MiZhu"] = "糜竺",
	["illustrator:MiZhu"] = "瞎子Ghe",
	["~MiZhu"] = "劣抵备主，我之罪也~",
	
	["Ziyuan"] = "资援",
	[":Ziyuan"] = "出牌阶段限一次，你可以将至少一张点数之和为13的手牌交给一名其他角色，令其回复1点体力。",
	["$Ziyuan1"] = "区区薄礼，万望使君笑纳~",
	["$Ziyuan2"] = "雪中送炭，以解君愁。",
	
	["Jugu"] = "巨贾",
	[":Jugu"] = "锁定技，你的手牌上限+X；当你首次明置此武将牌后，你摸X张牌。（X为你的体力上限）",
	["#Jugu-showmaxcards"] = "巨贾（手牌上限）",
	["#Jugu-showmaxcards:keep"] = "你可发动“巨贾”令你的手牌上限 + %arg",
	["$Jugu1"] = "钱~要多少有多少！",
	["$Jugu2"] = "君子爱财，取之有道~",
----------------------------------------------------------------------------------------------------
	["#DongBai"] = "魔姬",
	["DongBai"] = "董白",
	["illustrator:DongBai"] = "未知",
	["cv:DongBai"] = "暂无",
	
	["Lianzhu"] = "连诛",
	[":Lianzhu"] = "出牌阶段限一次，你可以展示一张牌并将之交给一名角色，若此牌为黑色，其选择是否弃置两张牌，若其选择否，你摸两张牌。",
	["@Lianzhu"] = "请弃置 2 张牌，否则 %src 摸 2 张牌",
	
	["Xiahui"] = "黠慧",
	[":Xiahui"] = "锁定技，你的黑色手牌于弃牌阶段内不计入手牌数且不能弃置；锁定技，当你的黑色牌被其他角色获得后，你令其于其扣减体力之前不能使用、打出或弃置之。",
	["#Xiahui-discard"] = "黠慧（令你的黑色手牌不计入手牌数）",
	["Xiahui:keep"] = "你可发动“黠慧”令你的黑色手牌不计入手牌数且不能被弃置",
	["#Xiahui"] = "由于“<font color=\"yellow\"><b>黠慧</b></font>”的效果，%from 的黑色手牌不计入手牌数",
	["$XiahuiLock"] = "%from 的“<font color=\"yellow\"><b>黠慧</b></font>”被触发，%to 于扣减体力前不能使用、打出或弃置 %card",
}
sgs.LoadTranslationTable{  --OL修订
	["OLRenew"] = "OL修订",
----------------------------------------------------------------------------------------------------
	["#ShenCaoCao_OL"] = "超世之英杰",
	["ShenCaoCao_OL"] = "神曹操-OL",
	["&ShenCaoCao_OL"] = "神曹操",
	["~ShenCaoCao_OL"] = "腾蛇乘雾，终为土灰。",
	
	["GuixinOL"] = "归心",
	[":GuixinOL"] = "当你受到1点伤害后，你可以选择一个区域的名称，随机获得每名其他角色此区域内的一张牌，然后叠置。\n" .. 
					"★若你不能从一名其他角色的此区域内获得牌，你按照以下规则随机获得该角色的其他区域内的一张牌：\n" .. 
					"选择手牌区，则依次考虑装备区→判定区；选择装备区，则依次考虑手牌区→判定区；选择判定区，则依次考虑手牌区→装备区。",
	["GuixinOL:h"] = "手牌区→装备区→判定区",
	["GuixinOL:e"] = "装备区→手牌区→判定区",
	["GuixinOL:j"] = "判定区→手牌区→装备区",
	["$GuixinOL1"] = "山不厌高，海不厌深。",
	["$GuixinOL2"] = "周公吐哺，天下归心。",
	
	["feiying_ShenCaoCao_OL"] = "飞影",
----------------------------------------------------------------------------------------------------
	["#WangYi_OL"] = "决意的巾帼",
	["WangYi_OL"] = "王异-OL",
	["&WangYi_OL"] = "王异",
	["illustrator:WangYi_OL"] = "团扇子大人",
	["~WangYi_OL"] = "月儿，不要责怪你爹爹……",
	
	["Zhenlie_WangYi_OL"] = "贞烈",
	["$Zhenlie_WangYi_OL1"] = "虽是妇人，亦当奋身一搏！",
	["$Zhenlie_WangYi_OL2"] = "为雪前耻，不惜吾身！",
	
	["MijiOL"] = "秘计",
	[":MijiOL"] = "结束阶段开始时，若你已受伤，你可以摸一至X张牌（X为你已损失的体力值），然后你可以将等量的手牌交给其他角色。",
	["MijiOL_draw"] = "秘计摸牌数",
	["@MijiOL"] = "秘计：你可以将 %arg 张手牌分配给其他角色",
	["@MijiOL2"] = "秘计：你须将 %arg 张手牌分配给其他角色",
	["~MijiOL"] = "选择至少一张手牌→选择一名其他角色→点击确定",
	["$MijiOL1"] = "此计，可歼敌精锐！",
	["$MijiOL2"] = "此举，可破敌之围！",
----------------------------------------------------------------------------------------------------
	["#CaoZhen_OL"] = "荷国天督", 
	["CaoZhen_OL"] = "曹真-OL", 
	["&CaoZhen_OL"] = "曹真",
	["illustrator:CaoZhen_OL"] = "Thinking",
	["~CaoZhen_OL"] = "秋雨凄迷，军心易乱",
	
	["SidiOL"] = "司敌", 
	[":SidiOL"] = "其他角色的出牌阶段开始时，你可以弃置一张与装备区里的牌颜色相同的非基本牌，令其本回合不能使用或打出与此装备牌颜色相同的牌，若如此做，此阶段结束时，若其未于此回合内使用过【杀】，你视为对其使用【杀】。", 
	["#SidiOL-slash"] = "司敌（视为使用【杀】）", 
	["#SidiOL"] = "由于“<font color=\"yellow\"><b>司敌</b></font>”效果，%from 本回合不能使用或打出 %arg 牌",
	["@SidiOL"] = "你可以对 %src 发动“司敌”<br/> <b>操作提示</b>: 选择装备区里的一张牌→点击确定",
	["$SidiOL1"] = "筑城固守，司敌备战！",
	["$SidiOL2"] = "徒手制敌，能奈我何？",
----------------------------------------------------------------------------------------------------
	["#ZhouCang_OL"] = "披肝沥胆", 
	["ZhouCang_OL"] = "周仓-OL", 
	["&ZhouCang_OL"] = "周仓",
	["illustrator:ZhouCang_OL"] = "Sky",
	["~ZhouCang_OL"] = "为将军操刀牵马，此生无憾",
	
	["ZhongyongOL"] = "忠勇",
	[":ZhongyongOL"] = "当你使用的【杀】结算结束后，你可以将此【杀】或目标角色使用的所有【闪】交给一名不为此【杀】目标的其他角色，以此法获得红色牌的角色可以对你攻击范围内的一名角色使用一张【杀】（无距离限制）。",
	["#ZhongyongOL"] = "忠勇",
	["@ZhongyongOL"] = "你可以发动“忠勇”",
	["~ZhongyongOL"] = "选择【杀】或所有【闪】→选择一名其他角色→点击确定",
	["@ZhongyongOL-slash"] = "你可以对 %src 攻击范围内的角色使用一张【杀】",
	["$ZhongyongOL1"] = "驱刀飞血，直取寇首",
	["$ZhongyongOL2"] = "为将军提刀携马，万死不辞",
----------------------------------------------------------------------------------------------------
	["#ZhangRang_OL"] = "窃幸绝禋", 
	["ZhangRang_OL"] = "张让-OL", 
	["&ZhangRang_OL"] = "张让",
	["illustrator:ZhangRang_OL"] = "蚂蚁君",
	["~ZhangRang_OL"] = "臣等殄灭，唯陛下自爱~~~噗......",
	
	["TaoluanOL"] = "滔乱", 
	[":TaoluanOL"] = "若没有角色处于濒死状态，你可将一张牌当任意一张基本牌或普通锦囊牌使用（不能是你以此法使用过的牌），若如此做，你令一名其他角色选择一项：1. 将与此牌类别不同的一张牌交给你；2. 令你失去1点体力，然后令“滔乱”于此回合内无效。", 
	["#TaoluanOL-ask"] = "滔乱（令一名其他角色选择一项）",
	["$TaoluanOL1"] = "睁开你的眼睛看看，现在，是谁说了算", 
	["$TaoluanOL2"] = "国家承平，神器稳固，陛下勿忧~", 
----------------------------------------------------------------------------------------------------
	["#CaiWenJi_OL"] = "金璧之才",
	["CaiWenJi_OL"] = "SP蔡文姬-OL",
	["&CaiWenJi_OL"] = "蔡文姬",
	["illustrator:CaiWenJi_OL"] = "木美人",
	["~CaiWenJi_OL"] = "命运……弄人……",  --【todo：待提取】
	
	["Chenqing"] = "陈情",
	[":Chenqing"] = "每轮限一次，当一名角色进入濒死状态时，你可以令另一名其他角色摸四张牌，然后弃置四张牌，若其以此法弃置的四张牌花色各不相同，则其视为对处于濒死状态的角色使用一张【桃】。",
	["@advise"] = "谏",  --Useless translation?
	["Chenqing-invoke"] = "你可以发动“陈情”<br/> <b>操作提示</b>: 选择除 %src 外的一名其他角色→点击确定<br/>",
	["@Chenqing-exchange"] = "%src 对你发动了“陈情”，请弃置四张牌。若你弃置的牌花色各不相同，视为你对 %dest 使用一张【桃】",
	["$Chenqing1"] = "陈生死离别之苦，悲乱世之跌宕。",
	["$Chenqing2"] = "乱世陈情，字字血泪。",
	
	["Mozhi"] = "默识",
	[":Mozhi"] = "结束阶段开始时，你可以将一张手牌当你出牌阶段内使用的第一张基本牌或普通锦囊牌使用，然后你可以将一张手牌当你出牌阶段内使用的第二张基本牌或普通锦囊牌使用。",
	["@Mozhi"] = "你可发动“默识”将一张手牌当【%arg】使用",
	["~Mozhi"] = "选择一张手牌→选择目标角色→点击确定",
	["$Mozhi1"] = "今日默书，方恨千卷诗书未能全记。",
	["$Mozhi2"] = "博文强识，不辱才女之名。",
----------------------------------------------------------------------------------------------------
	["#MaChao_OL"] = "西凉的猛狮",
	["MaChao_OL"] = "SP马超-OL",
	["&MaChao_OL"] = "马超",
	["illustrator:MaChao_OL"] = "天空之城",
	["~MaChao_OL"] = "西凉~~~回不去了……",
	
	["ZhuijiOL"] = "追击",
	[":ZhuijiOL"] = "锁定技，你与体力值不大于你的角色的距离视为1。",
	
	["Shichou"] = "誓仇",
	[":Shichou"] = "你使用【杀】可以多选择一至X名目标（X为你已损失的体力值）。",
	["$Shichou1"] = "灭族之恨，不共戴天！",
	["$Shichou2"] = "休想跑~",
----------------------------------------------------------------------------------------------------
	["#XingCai_OL"] = "敬哀皇后",
	["XingCai_OL"] = "星彩-OL",
	["&XingCai_OL"] = "星彩",
	["illustrator:XingCai_OL"] = "depp",
	["~XingCai_OL"] = "复兴汉室之路，臣妾再也不能陪伴左右。" ,
	
	["ShenxianOL"] = "甚贤",
	[":ShenxianOL"] = "每名其他角色的回合限一次，当其他角色因弃置而失去基本牌后，你可以摸一张牌。",
	["$ShenxianOL1"] = "抚慰军心，以安国事。" ,
	["$ShenxianOL2"] = "愿尽己力，为君分忧。" ,
	
	["Qiangwu_XingCai_OL"] = "枪舞",
	["$Qiangwu_XingCai_OL1"] = "咆哮沙场，万夫不敌！" ,
	["$Qiangwu_XingCai_OL2"] = "父亲未竟之业，由我继续！" ,
----------------------------------------------------------------------------------------------------
	["#ZuMao_OL"] = "碧血染赤帻",
	["ZuMao_OL"] = "祖茂-OL",
	["&ZuMao_OL"] = "祖茂",
	["illustrator:ZuMao_OL"] = "DH",
	["~ZuMao_OL"] = "孙将军，已经安全了吧。" ,
	
	["Yinbing_ZuMao_OL"] = "引兵",
	["#Yinbing-throw_ZuMao_OL"] = "引兵（移去一张“引兵”牌）",
	["$Yinbing_ZuMao_OL1"] = "将军走此小道，追兵教我应付！" ,
	["$Yinbing_ZuMao_OL2"] = "追兵凶芒，末将断后！" ,
	
	["JuediOL"] = "绝地",
	[":JuediOL"] = "锁定技，准备阶段开始时，你选择一项：1. 移去“引兵”牌，将手牌补至X张（X为你的体力上限）；2. 将“引兵”牌交给一名体力值不大于你的其他角色，若如此做，其回复1点体力，然后摸等量的牌。",
	["JuediOL-invoke"] = "请选择“绝地”的目标<br/> <b>操作提示</b>: 选择你或一名体力值不大于你的其他角色→点击确定",
	["JuediOL-invoke-noncomp"] = "你可以发动“绝地”<br/> <b>操作提示</b>: 选择你或一名体力值不大于你的其他角色→点击确定",
	["$JuediOL1"] = "提起武器，最后一搏！" ,
	["$JuediOL2"] = "困兽之斗，以诠忠义！" ,
}
sgs.LoadTranslationTable{  --手杀专属
	["Mobile"] = "手杀专属",
----------------------------------------------------------------------------------------------------
	["#MiHeng"] = "",
	["MiHeng"] = "祢衡",
	["illustrator:MiHeng"] = "未知",
	["cv:MiHeng"] = "(滑稽)",
	["~MiHeng"] = "另请高明吧！",
	
	["Kuangcai"] = "狂才",
	[":Kuangcai"] = "出牌阶段开始时，你可以令你此阶段内的出牌时间变为5秒，若如此做，你于此阶段内使用牌无距离限制且无次数限制，且当你于此阶段内使用牌时，你摸一张牌，然后出牌时间-1秒。\n" .. 
	"★注：由于程序实现问题，实际效果为：出牌读条时间依旧，但如果你出牌用时超过了规定时间，直接取消使用此牌并结束出牌阶段",
	["#Kuangcai-draw"] = "狂才（摸一张牌）",
	["#Kuangcai-cancel"] = "狂才（超时结束出牌阶段）",
	["#KuangcaiTerminate"] = "由于 %from 的出牌时间超过了时限（%arg 秒），%from 取消使用此牌并结束出牌阶段",
	["$Kuangcai1"] = "后来我就念了两句诗，",
	["$Kuangcai2"] = "苟利国家",
	["$Kuangcai3"] = "生死以，",
	["$Kuangcai4"] = "岂因",
	["$Kuangcai5"] = "祸福",
	["$Kuangcai6"] = "避趋之。",
	
	["Shejian"] = "舌剑",
	[":Shejian"] = "弃牌阶段结束时，若你于此阶段弃置过至少一张花色均不同的牌，你可弃置一名其他角色的一张牌。",
	["Shejian-invoke"] = "你可以发动“舌剑”<br/> <b>操作提示</b>: 选择一名其他角色→点击确定<br/>",
	["$Shejian1"] = "你们啊，不要喜欢弄个大新闻！",
	["$Shejian2"] = "你们啊，naive！",
}
sgs.LoadTranslationTable{  --☆SP
	["BGM"] = "☆SP",
----------------------------------------------------------------------------------------------------
	["#LyuMeng_BGM"] = "国士之风",
	["LyuMeng_BGM"] = "吕蒙-☆SP",
	["&LyuMeng_BGM"] = "吕蒙",
	["illustrator:LyuMeng_BGM"] = "YellowKiss",
	["designer:LyuMeng_BGM"] = "如水法师卞程",
	["cv:LyuMeng_BGM"] = "风叹息",
	["~LyuMeng_BGM"] = "未见吴之天下，怎敢轻生……",
	
	["Tanhu"] = "探虎",
	[":Tanhu"] = "出牌阶段限一次，你可以与一名其他角色拼点：若你赢，你与该角色的距离视为1，且你使用的对其结算的非延时类锦囊牌不能被【无懈可击】响应或抵消，直到回合结束。",
	["#Tanhu-cancel"] = "探虎（令此锦囊牌不能被【无懈可击】响应）",
	["#TanhuHegNullification"] = "由于“<font color=\"yellow\"><b>探虎</b></font>”的效果，此【%arg】不能抵消 %from 对 %to 的锦囊【%arg2】",
	["$Tanhu1"] = "不入虎穴，焉得虎子。",
	["$Tanhu2"] = "诈以欺敌，袭其空虚！", -- 赢
	["$Tanhu3"] = "反复之人，不可轻信！", -- 没赢
	
	["Mouduan"] = "谋断",
	[":Mouduan"] = "当你明置此武将牌后，你获得一枚“文/武”标记且“武”朝上；若你的手牌数不大于2，你的标记为“文”朝上；其他角色的回合开始时，若“文”朝上，你可以弃置一张牌，将标记翻至“武”朝上；若“武”朝上，你拥有“激昂”和“谦逊”；若“文”朝上，你拥有“英姿”和“克己”。",
	["#Mouduan-flip"] = "谋断（将标记翻至“文”）",
	["#Mouduan-flipback"] = "谋断（将标记翻至“武”）",
	["Mouduan:wen"] = "你可以发动“谋断”获得“文”标记",
	["@Mouduan"] = "你可以弃置一张牌将标记翻至“武”朝上（若你的手牌数不大于2则无事发生）",
	["@wen"] = "文",
	["@wu"] = "武",
	["$Mouduan"] = "士别三日，当刮目相待！",
	["jiang_LyuMeng_BGM"] = "激昂",
	["$jiang_LyuMeng_BGM1"] = "陈列赫然，兵人练习！", -- 攻
	["$jiang_LyuMeng_BGM2"] = "攻守兼备，进退自如！", -- 守
	["qianxun_LyuMeng_BGM"] = "谦逊",
	["$qianxun_LyuMeng_BGM1"] = "儒生脱尘，不为贪逸淫乐之事。",
	["$qianxun_LyuMeng_BGM2"] = "谦谦君子，不饮盗泉之水。",
	["yingzi_LyuMeng_BGM"] = "英姿",
	["$yingzi_LyuMeng_BGM1"] = "秉承遗志，树威立信。",
	["$yingzi_LyuMeng_BGM2"] = "明正军纪，路无拾遗！",
	["keji_LyuMeng_BGM"] = "克己",
	["$keji_LyuMeng_BGM1"] = "利在不战，长计制之。",
	["$keji_LyuMeng_BGM2"] = "容忍于心，深藏不露。",
}
sgs.LoadTranslationTable{  --怀旧
	["Nostalgia"] = "怀旧",
----------------------------------------------------------------------------------------------------
	["#GuanXingZhangBao_Nos"] = "将门虎子",
	["GuanXingZhangBao_Nos"] = "关兴＆张苞-旧",
	["&GuanXingZhangBao_Nos"] = "关兴张苞",
	["illustrator:GuanXingZhangBao_Nos"] = "HOOO",
	["~GuanXingZhangBao_Nos"] = "父亲，我来了！",
	
	["FuhunNos"] = "父魂",
	[":FuhunNos"] = "摸牌阶段开始时，你可以放弃摸牌，亮出牌堆顶的两张牌，然后获得之，若亮出的牌颜色不同，你拥有“武圣”和“咆哮”，直到回合结束。",
	["$FuhunNos1"] = "呐喊破敌，锐不可当！",
	["$FuhunNos2"] = "匹夫之勇，插标卖首！",
	["wusheng_GuanXingZhangBao_Nos"] = "武圣",
	["paoxiao_GuanXingZhangBao_Nos"] = "咆哮",
	["#paoxiao-null_GuanXingZhangBao_Nos"] = "咆哮（无视防具）",
	["$wusheng_GuanXingZhangBao_Nos1"] = "关羽在此，尔等受死！",
	["$wusheng_GuanXingZhangBao_Nos2"] = "看尔乃插标卖首！",
	["$paoxiao_GuanXingZhangBao_Nos1"] = "啊~~~",
	["$paoxiao_GuanXingZhangBao_Nos2"] = "燕人张飞在此！",
}
sgs.LoadTranslationTable{  --武将替换
	["from_v2"] = "武将替换",
	["sp_convert"] = "武将替换",
	["sp_convert:head"] = "你可以将主将替换为%arg",
	["sp_convert:deputy"] = "你可以将副将替换为%arg",
	["or"] = "或",
}
--[[priority倒序：
--一将系列
--SP（包括后期的一些伪SP）
--标准包（2013）：袁术、华雄
--标准包（界限突破）：徐庶、所有改版武将
--神话再临·风（2013）：周泰、张角、曹仁
--神武将
--☆SP
--界SP
--OL
--手杀
--铜雀台
--台湾一将成名
--其他
--桌游志贴纸
--倚天
--智包
--翼包]]
--适当用on_record代替can_trigger；注意on_record的效果如果是在技能发动前则需要global（防止半途中获得技能，参考左慈回合结束后化身可以连破）
--处理颂威类技能和效果（sgs1'songwei）->例如郡兵
--将#effects类全局技能改成global（见智迟制蛮）【划掉】
--技能与效果拆分，作用：1. 执行效果时技能选项能有提示（横江）；2. 防止点取消
--addRelateSkill（用于可以游戏中获得的技能，如崩坏）
--非锁定技但必须发动的技能（暗箭）：frequency必须是Compulsory（亮将机制，避免取消），套个空壳
--注意TargetConfirmed是对所有玩家发动
--国战中inMyAttackRange尚未改成不包括自己
--SkillCard的filter第四个参数是player，相当于sgs.Self
--变包需要处理：toGet；setActualGeneral；ViewHas；LuaProhibitSkill；convertForDIY（武将替换）；AttachedLordSkill（陷嗣）；距离技的SkillCard；HeadSkillList、DeputySkillList新语法；HeadActivedSkills（确定是否能亮将），且将inHeadSkills用getHeadActivedSkills替换；showGeneral改成showSkill；单独分出来的record类发动前记录的技能（如Jushou15Record，类似连破防左慈）可以合并回去了（新版本只要添加了TriggerSkill就会触发，旧版本需要global或者开局时在某个在场玩家身上）；优化askForChoice提示信息（可以添加参数了）；FilterSkill写法修改；EventAcquireSkill/EventLoseSkill的data被改，加了:head/:deputy
			--（看看VSSkill的in_pile干啥的）
								--【GeneralHidden需要将牌置入弃牌堆】
			
--乱七八糟的注：
--1. isAvailable内部判断了是否isCardLimited，但是需要去设置handling_method

----------------------------------------------通用函数----------------------------------------------

math.randomseed(os.time())
local json = require ("json")

function targetsTable2QList(thetable)
	local theqlist = sgs.PlayerList()
	for _, p in ipairs(thetable) do
		theqlist:append(p)
	end
	return theqlist
end
function targetsTable2QSPList(thetable)
	local theqlist = sgs.SPlayerList()
	for _, p in ipairs(thetable) do
		theqlist:append(p)
	end
	return theqlist
end

--[[检测杀是否需要亮TargetModSkill
	只要加入了这个技能，那么使用杀时在PreCardUsed就会自动判断杀的使用次数、目标数、距离限制是否受到了未亮出的TargerModSkill的影响
	如果是，则令玩家在未亮出的TargerModSkill中选一个，然后重复此流程，直到全部符合实际或者循环了100遍（这就是bug了）
	
	由于lua无法直接接触到TargetModSkill下面的判断函数，因此对于“一个TMskill是否改变了相关属性”的判断，是通过先令这个技能无效然后判断来实现的
	这样能使得hasSkill为false，进而实现对大多数技能的准确判断
	然而还有一类技能（如天义），它们【在hasSkill为false时返回值也不是0】
	因此有了下面定义的3个函数，它们的用途是手动枚举这类技能的返回值
	由此导致对于每个这类TMskill，都需要【把相关func重写一遍添加到这里面】
	（注意调用这些函数时是按照hasSkill为true来模拟的，因此如果hasSkill会影响返回值的话，在这里面的返回应该是两者之差
		例如，一个TMskill在有此技能时返回5，没有时返回3，那么在这个函数里应该返回5-3=2
		因为targetsTestWithout是按照hasSkill为false返回，因此会比targetsTestWith少3，而我们希望前者比后者少5
		当然需要判断一下玩家是否本来就有这技能，如果hasSkill一开始就是false那么在这里面自然就该返回0了）
		（但是，对于DistanceLimit和ExtraTarget，如果有没有此技能都会返回>=998，请务必在这里返回998
		因为对于无限的判断，是直接调用checkSpecialResidueSkills而不是求差）
		
	由于无法修改源码，这个函数的亮将时机实际会比源码中晚很多
	而源码中的TargetModSkill亮将都是包含在源码里的（slash:onUse），所以遇到这种情况系统会自动先亮源码
	然后在PreCardUsed，如果本技能判断出还不满足条件，再亮lua技能
	且源码的亮将判断有不少没有考虑lua的TargetMod效果，因此即使完全不需要亮，系统也可能亮出来
	（例如：小关张（明）-张飞（暗）用第二张杀，虽然小关张的lua咆哮已经允许了第二张杀，但还是会亮张飞）
	
	——为什么不把时机改成ChoiceMade？
	以现在lua对ChoiceMade的掌控程度（参考酒诗），是完全可以在ChoiceMade中读取详细的使用信息，进而提前亮将的
	但是ChoiceMade的最大问题就是，这个时机太早了，甚至在useCard之前
	这就导致useCard中重要的一步validate没有执行，进而导致傲才、奇策、陷嗣、滔乱等在on_validate中将技能卡转化为杀的技能会出错
	在源码中，除杀以外的牌亮TMskill的时机都是在useCard中，validate之后，也证明了validate之前是绝对不能读取卡牌信息的
	但很可惜，validate之后能接触到的第一个时机就是PreCardUsed了，而此时已经经历了诸如朱雀、方天、TMskill加目标、亮咆哮蒺藜短兵等多个步骤（在slash:onUse中）
	因此lua这边只能把亮将时机放到这些之后了
]]
function checkSpecialExtraTargetSkills(skill, use)  --用于统计不需要判断hasSkill就可触发的TargetMod
	local result = 0
	local from = use.from
	if not use.card:isKindOf("Slash") then return 0 end
	
	--[[if (skill == "halberd-target") and (from:hasFlag("HalberdUse")) then  --触发技能时已经没有HalberdUse这个flag
		result = result + from:getMark("halberd_count")
	end]]
	if (skill == "halberd-target") and use.card:hasFlag("halberd_slash") then
		local original_targets = 0
		local extra_targets = 0
		for _,to in sgs.qlist(use.to) do
			if to:hasFlag("forTM_HalberdSlashOriginalTargets") then
				original_targets = original_targets + 1
			end
			if to:hasFlag("forTM_HalberdSlashExtraTargets") then
				extra_targets = extra_targets + 1
			end
		end
		if original_targets > 0 then
			original_targets = original_targets - 1
		end
		result = result + original_targets + extra_targets
	end
	if (skill == "tianyi") and from:hasFlag("TianyiSuccess") then
		result = result + 1
	end
	
	return result
end
function checkSpecialDistLimitSkills(skill, use)
	local result = 0
	local from = use.from
	if not use.card:isKindOf("Slash") then return 0 end
	
	if (skill == "tianyi") and from:hasFlag("TianyiSuccess") then
		return 1000
	end
	if (skill == "Zhaxiang") and (from:getMark("Zhaxiang") > 0) and use.card:isRed() then
		return 1000
	end
	if (skill == "Jiangchi") and from:getMark("JiangchiInvoke") > 0 then
		return 1000
	end
	if (skill == "Qiaoshui") and from:hasFlag("QiaoshuiExtraTarget") then
		return 1000
	end
	if skill == "Qiangwu_XingCai" then
		if not (use.card:isVirtualCard() and use.card:subcardsLength() > 1) and use.card:getNumber() < from:getMark("QiangwuMax_XingCai") then return 1000 end
	end
	if skill == "Qiangwu_XingCai_OL" then
		if not (use.card:isVirtualCard() and use.card:subcardsLength() > 1) and use.card:getNumber() < from:getMark("QiangwuMax_XingCai_OL") then return 1000 end
	end
	if (skill == "Kuangcai") and from:hasFlag("KuangcaiInvoked") then
		return 1000
	end
	
	return result
end
function checkSpecialResidueSkills(skill, use)					--todo：判断司敌
	local result = 0
	local from = use.from
	if not use.card:isKindOf("Slash") then return 0 end
	
	if (skill == "tianyi") and from:hasFlag("TianyiSuccess") then
		result = result + 1
	end
	if (skill == "Zhaxiang") and (from:getMark("Zhaxiang") > 0) then
		result = result + from:getMark("Zhaxiang")
	end
	if (skill == "Qimou") and (from:getMark("@strategy_hp") > 0) then
		result = result + from:getMark("@strategy_hp")
	end
	if (skill == "Jiangchi") and from:getMark("JiangchiInvoke") > 0 then
		result = result + from:getMark("JiangchiInvoke")
	end
	if (skill == "Tuifeng") and (from:getMark("@lead") > 0) then
		result = result + from:getMark("@lead")
	end
	if (skill == "Kuangcai") and from:hasFlag("KuangcaiInvoked") then
		return 1000
	end
	
	return result
end
Slash_NDL_Skills = {"jgfengxing", "Mingce", "SidiOL"}  --跳过了ChoiceMade（包括askForUseSlashTo）及SlashNDL的TargetModSkill（如神速），直接靠useCard等方式使用杀的技能
function checkTargetModSkillShowForSlash(use, new_slash)  --出牌阶段使用杀不需要add_history的技能全都要写到这里！直接靠useCard使用杀的技能全都要写到这里！
	if not use.card or not use.card:isKindOf("Slash") then return "" end  --其他牌系统已经能自动处理
	new_slash = new_slash or false
	local skills_to_show = {}
	local skills_to_broadcast = {}
	local from = use.from
	local slash = use.card
	local room = from:getRoom()
	local tarmods = {}
	
	local invalidSkills_backup = from:property("invalid_skill_has"):toString():split("+")
	local invalidSkills_shown_backup = from:property("invalid_skill_shown"):toString():split("+")
	
	
	local function refreshTarMods()
		local tarmods = {}
		for _,skillName in ipairs(sgs.Sanguosha:getSkillNames()) do
			if sgs.Sanguosha:getSkill(skillName) and sgs.Sanguosha:getSkill(skillName):inherits("TargetModSkill") then--因getPattern在lua没法用，所以无法判断是不是仅仅对杀的技能
				local mainSkillName = skillName
				local mainSkill = sgs.Sanguosha:getMainSkill(skillName)
				if mainSkill ~= nil then
					mainSkillName = mainSkill:objectName()
				end
				table.insert(tarmods, mainSkillName)
			end
		end
		return tarmods
	end
	
	local function testCardTargetForSpecificSkill(tarmod_type, from, slash, skillName, isWithout, isOnly, initialInvSkills, initialInvSkillsShown)  --返回因此技能改变的数值
		initialInvSkills = initialInvSkills or invalidSkills_backup
		initialInvSkillsShown = initialInvSkillsShown or invalidSkills_shown_backup
		local invalidSkills = table.copyFrom(initialInvSkills)
		local invalidSkills_shown = table.copyFrom(initialInvSkillsShown)
		room:setPlayerProperty(from, "invalid_skill_has", sgs.QVariant(table.concat(invalidSkills, "+")))
		room:setPlayerProperty(from, "invalid_skill_shown", sgs.QVariant(table.concat(invalidSkills_shown, "+")))
		
		local targetsTestWith = sgs.Sanguosha:correctCardTarget(tarmod_type, from, slash)
		local targetsTestWithout = targetsTestWith
		
		if not table.contains(invalidSkills, skillName) or skillName == "none" then
			if isWithout then
				table.insert(invalidSkills, skillName)
				table.insert(invalidSkills_shown, skillName)
			elseif isOnly or skillName == "none" then
				for _,otherSkill in ipairs(tarmods) do
					if otherSkill ~= skillName and not table.contains(invalidSkills, otherSkill) then
						table.insert(invalidSkills, otherSkill)
						table.insert(invalidSkills_shown, otherSkill)
					end
				end
			end
			room:setPlayerProperty(from, "invalid_skill_has", sgs.QVariant(table.concat(invalidSkills, "+")))
			room:setPlayerProperty(from, "invalid_skill_shown", sgs.QVariant(table.concat(invalidSkills_shown, "+")))
			targetsTestWithout = sgs.Sanguosha:correctCardTarget(tarmod_type, from, slash)
		end
		room:setPlayerProperty(from, "invalid_skill_has", sgs.QVariant(table.concat(invalidSkills_backup, "+")))
		room:setPlayerProperty(from, "invalid_skill_shown", sgs.QVariant(table.concat(invalidSkills_shown_backup, "+")))
		
		if tarmod_type == sgs.TargetModSkill_ExtraTarget then
			targetsTestWithout = targetsTestWithout - checkSpecialExtraTargetSkills(skillName, use)
		elseif tarmod_type == sgs.TargetModSkill_DistanceLimit then
			targetsTestWithout = targetsTestWithout - checkSpecialDistLimitSkills(skillName, use)
		elseif tarmod_type == sgs.TargetModSkill_Residue then
			targetsTestWithout = targetsTestWithout - checkSpecialResidueSkills(skillName, use)
		end
		if isOnly then return targetsTestWithout end
		return targetsTestWith - targetsTestWithout
	end
	
	local function forTM_isSpecificAssignee(from, target, slash)  --基本重写isSpecificAssignee（原函数对lua不开放）
		if from:hasFlag("forTM_slashTargetFix") and target:hasFlag("forTM_SlashAssignee") then return true end
		if (from:getPhase() == sgs.Player_Play) and (sgs.Sanguosha:getCurrentCardUseReason() == sgs.CardUseStruct_CARD_USE_REASON_PLAY) --[[and not sgs.Slash_IsAvailable(from, slash, false)]] then  --去掉Slash_IsAvailable是因为此函数中考虑了TM，而我们不希望因为TM导致返回false
			local assignee_list = from:property("extra_slash_specific_assignee"):toString():split("+")
			if table.contains(assignee_list, target:objectName()) then
				return true
			end
		end
		return false
	end
	
	--Extra target						--已知bug：只能对hasSkill类技能判断（因为lua没法直接读取TargetModSkill里的函数），因此对用Flag之类的判断的技能（如天义）需要单独添加；下同
	tarmods = refreshTarMods()
	if use.to:length() >= 2 then
		local extra_targets = use.to:length() - 1
		local tarmods_copy = table.copyFrom(tarmods)
		for _,skillName in ipairs(tarmods_copy) do  --剔除无关的TargetModSkill
			if testCardTargetForSpecificSkill(sgs.TargetModSkill_ExtraTarget, from, slash, skillName, true) == 0 then
				table.removeOne(tarmods, skillName)
			end
		end
		
		local tarmods_copy = table.copyFrom(tarmods)
		for _,skillName in ipairs(tarmods_copy) do  --剔除已经明置的TargetModSkill及装备技能
			if from:hasShownSkill(skillName) or from:hasEquipSkill(skillName) or (skillName == "halberd-target") then  --源码没把halberd-target设成related。。。
				if extra_targets > 0 then table.insert(skills_to_broadcast, skillName) end
				extra_targets = extra_targets - testCardTargetForSpecificSkill(sgs.TargetModSkill_ExtraTarget, from, slash, skillName, true)
				table.removeOne(tarmods, skillName)
			end
		end
		--注：系统设置在所有TargetModSkill全用上以后，如果目标上限还是不够，就自动亮短兵
		--所以下面这段一般用在系统没自动亮短兵，而又可以亮的情况下（比如丁奉程普火杀一个距离1一个距离2，自己选择亮哪个）
		local canInvokeDuanbing = false
		if from:hasSkill("duanbing") then
			for _,p in sgs.qlist(use.to) do
				if from:distanceTo(p) == 1 then
					canInvokeDuanbing = true
					break
				end
			end
		end
		if canInvokeDuanbing then
			if not from:hasShownSkill("duanbing") then
				table.insert(tarmods, "duanbing")
			else
				if extra_targets > 0 then table.insert(skills_to_broadcast, "duanbing") end
				extra_targets = extra_targets - 1
			end
		end
		
		--此时tarmods存储了所有会导致目标数增加，但尚未亮出的技能
		--而extra_targets存储了（在不亮任何tarmods中的技能的情况下）超出上限的目标数
		if (#tarmods ~= 0) and (extra_targets > 0) then  --需要亮TargerMod
			table.insertTable(skills_to_show, tarmods)
		end
	end
	
	--Distance limit
	tarmods = refreshTarMods()
	if not from:hasFlag("forTM_slashNoDistanceLimit") then
		local distance_exceeded = 0
		
		local range_fix = 0
		local ids = sgs.IntList()
		if slash:isVirtualCard() then
			if slash:subcardsLength() > 0 then ids = slash:getSubcards() end
		else
			ids:append(slash:getEffectiveId())
		end
		if from:getWeapon() and ids:contains(from:getWeapon():getId()) then
			local weapon = from:getWeapon():getRealCard():toWeapon()
			range_fix = range_fix + weapon:getRange() - from:getAttackRange(false)
		elseif from:getOffensiveHorse() and ids:contains(from:getOffensiveHorse():getId()) then
			range_fix = range_fix + 1
		end
		local distance_max = 0
		for _,p in sgs.qlist(use.to) do
			distance_max = math.max(distance_max, from:distanceTo(p, range_fix))
		end
		distance_exceeded = distance_max - from:getAttackRange()
		
		if distance_exceeded > 0 and not table.contains(Slash_NDL_Skills, slash:getSkillName()) then
			local limitless_skills = {}  --记录返回了无限的技能
			local limitless_settled = false
			if sgs.Sanguosha:correctCardTarget(sgs.TargetModSkill_DistanceLimit, from, slash) >= 500 then
				--先处理靠flag返回998的
				for _,skillName in ipairs(tarmods) do
					if checkSpecialDistLimitSkills(skillName, use) >= 998 then
						if from:hasShownSkill(skillName) or from:hasEquipSkill(skillName) then  --继续简化代码，只要有亮出的998技能就不管暗置的了
							table.insert(skills_to_broadcast, skillName)
							limitless_settled = true
							break
						end
						table.insert(limitless_skills, skillName)
					end
				end
				if next(limitless_skills) and not limitless_settled then
					--一处比较纠结的简化代码，如果有靠flag返回998的暗置技能，则不考虑其他靠技能返回998的技能及所有返回非998的技能
					--因为如果放任这个技能不管，下面所有的correctCardTarget都会返回998，根本无法判断某个技能是否起了作用
					--目前来说没什么问题，因为flag大多数是在明置以后才会有（所以这里应该是空），但是怕的是给别人提供dist_limit的技能和各种DIY奇葩技能
					for _,skillName in ipairs(limitless_skills) do
						table.insert(skills_to_show, skillName)
					end
					limitless_settled = true
				end
				if not limitless_settled then
					if testCardTargetForSpecificSkill(sgs.TargetModSkill_DistanceLimit, from, slash, "none", false, true) >= 998 then
						room:writeToConsole("Error: Lua Distance Limit skills in other extensions using flags")
						return "", ""  --其他Lua扩展存在通过flag返回998的技能，无解
					end
					for _,skillName in ipairs(tarmods) do  --剩下的体制内技能都不会通过flag返回998了
						if testCardTargetForSpecificSkill(sgs.TargetModSkill_DistanceLimit, from, slash, skillName, false, true) >= 998 then
							if from:hasShownSkill(skillName) or from:hasEquipSkill(skillName) then
								table.insert(skills_to_broadcast, skillName)
								limitless_settled = true
								break
							end
							table.insert(limitless_skills, skillName)
						end
					end
				end
				if not limitless_settled and not next(limitless_skills) then
					room:writeToConsole("Error: Unknown error for checkTargetModSkillShowForSlash to return >=998")
					return "", ""
				end
			end
			if not limitless_settled then
				local invalidSkills_withLimit = table.copyFrom(invalidSkills_backup)
				local invalidSkills_shown_withLimit = table.copyFrom(invalidSkills_shown_backup)
				table.insertTable(invalidSkills_withLimit, limitless_skills)  --先将返回998的暗置技能无效掉，以确保下面的判断正确
				table.insertTable(invalidSkills_shown_withLimit, limitless_skills)
				table.removeTable(tarmods, limitless_skills)
				
				local tarmods_copy = table.copyFrom(tarmods)
				for _,skillName in ipairs(tarmods_copy) do  --剔除无关的TargetModSkill
					if testCardTargetForSpecificSkill(sgs.TargetModSkill_DistanceLimit, from, slash, skillName, true, false, invalidSkills_withLimit, invalidSkills_shown_withLimit) == 0 then
						table.removeOne(tarmods, skillName)
					end
				end
				
				local tarmods_copy = table.copyFrom(tarmods)
				for _,skillName in ipairs(tarmods_copy) do  --剔除已经明置的TargetModSkill及装备技能
					if from:hasShownSkill(skillName) or from:hasEquipSkill(skillName) then
						if distance_exceeded > 0 then table.insert(skills_to_broadcast, skillName) end
						distance_exceeded = distance_exceeded - testCardTargetForSpecificSkill(sgs.TargetModSkill_DistanceLimit, from, slash, skillName, true, false, invalidSkills_withLimit, invalidSkills_shown_withLimit)
						table.removeOne(tarmods, skillName)
					end
				end
				
				--此时tarmods存储了所有会导致上限增加（非998），但尚未亮出的技能
				--limitless_skills存储了所有会导致上限成为998，但尚未亮出的技能
				--而distance_exceeded存储了（在不亮任何tarmods中的技能的情况下）距离最远的目标超出距离上限的距离值
				if (#tarmods + #limitless_skills ~= 0) and (distance_exceeded > 0) then  --需要亮TargerMod
					table.insertTable(skills_to_show, tarmods)
					table.insertTable(skills_to_show, limitless_skills)
				end
			end
		end
	end
	
	--Residue
	tarmods = refreshTarMods()
	--[[（这个注释内容已作废）
	--源码中如果装备连弩或者TMskill的Residue返回值>500则直接不addHistory，因此需要手动判断实际上是否真的因为技能没有addHistory，还是只是因为TMskill的影响
	--（用源码的话解释，就是只判断add_history，不判断slash_not_record）
	local do_not_add_history_skills = {"shuangren", "Mingce"}  --本身就不addHistory的技能
	local addHistory = (from:getPhase() == sgs.Player_Play) and not table.contains(do_not_add_history_skills, use.card:getSkillName())
	if addHistory and (from:getSlashCount() > 1 or from:hasFlag("Global_MoreSlashInOneTurn")) then
	--上面这一行：如果CorrectCardTarget返回<=500，getSlashCount包括正在使用的这张（因为已经addHistory）
	--如果>500，在2.1.0中是不会addHistory的（slash_not_record为true），新版本中添加了对hasShownSkill的判断所以会加历史了
	--所以在旧版本中，只能靠Global_MoreSlashInOneTurn来判断是否是额外的杀（除非有天义、诸葛连弩、咆哮，否则这个flag不会被删）]]
	if (from:getPhase() == sgs.Player_Play) and from:hasFlag("Global_MoreSlashInOneTurn") then
		local extra_slash_count = from:getSlashCount() - 1
		local do_not_add_history_skills = {"shuangren", "Mingce"}  --本身就不addHistory的技能
		local addHistory = not table.contains(do_not_add_history_skills, use.card:getSkillName())
		if new_slash and (from:getPhase() == sgs.Player_Play) and addHistory and sgs.Sanguosha:correctCardTarget(sgs.TargetModSkill_Residue, from, slash) > 500 then  --（用new_slash防止此段代码对同一张杀调用2次）
			--extra_slash_count = extra_slash_count + 1  --2.1.0中，如果CorrectCardTarget返回>500是不会addHistory的（slash_not_record为true），这是bug
													   --因此只能这样手动判断，是否实际上使用了这张杀但是没加history
													   --新版本中添加了对hasShownSkill的判断（即未明置的话还会addHistory），所以会加历史了
													   --当然，如果返回值>500的技能已经被明置，这张杀本来也不应该加入slash_count，而这个if判断里会加
													   --但是这种情况在下面处理>=998的那段会被break掉，所以扯平了（加ExtraSlashCount也没关系，每次都会break）
													   --（todo：新版本修复，取消这整个if判断，理由见上面第3行）
			room:addPlayerHistory(from, "forTM_ExtraSlashCount")  --因为上面那个+1无法累加，类似诈降咆哮双将用的杀就永远会视为第二张（todo：新版本同样可删）
		end
		extra_slash_count = extra_slash_count + from:usedTimes("forTM_ExtraSlashCount")
		
		repeat
			local isCrossbow = false
			local ids = sgs.IntList()
			if slash:isVirtualCard() then
				if slash:subcardsLength() > 0 then ids = slash:getSubcards() end
			else
				ids:append(slash:getEffectiveId())
			end
			local has_weapon = from:hasWeapon("Crossbow") and ids:contains(from:getWeapon():getEffectiveId())
			isCrossbow = (not has_weapon and from:hasWeapon("Crossbow"))
			if isCrossbow then
				table.insert(skills_to_broadcast, "Crossbow")
				break  --为了简化代码，只要装备连弩就视为发动了连弩而不是TMskill
			end
			
			local all_specific_assignees = true
			for _,target in sgs.qlist(use.to) do
				if not forTM_isSpecificAssignee(from, target, slash) then all_specific_assignees = false break end
			end
			if all_specific_assignees then break end
			
			--对Residue需要注意的是，只要有一个技能返回>=998，最终返回结果就会是这个值而不是累加
			--所以需要把每个技能单独摘出来判断一遍，也不能像ExtraTarget那样判断一个TMskill是否无关
			local limitless_skills = {}  --判断是否有技能返回了无限
			if sgs.Sanguosha:correctCardTarget(sgs.TargetModSkill_Residue, from, slash) >= 998 then  --应该不会有两个“可以多使用499张杀”的技能，因此不是累加
				local limitless_settled = false
				
				--先处理靠flag返回998的
				for _,skillName in ipairs(tarmods) do
					if checkSpecialResidueSkills(skillName, use) >= 998 then
						if from:hasShownSkill(skillName) or from:hasEquipSkill(skillName) then  --继续简化代码，只要有亮出的998技能就不管暗置的了
							table.insert(skills_to_broadcast, skillName)
							limitless_settled = true
							break
						end
						table.insert(limitless_skills, skillName)
					end
				end
				if next(limitless_skills) and not limitless_settled then
					--一处比较纠结的简化代码，如果有靠flag返回998的暗置技能，则不考虑其他靠技能返回998的技能及所有返回非998的技能
					--因为如果放任这个技能不管，下面所有的correctCardTarget都会返回998，根本无法判断某个技能是否起了作用
					--目前来说没什么问题，因为flag大多数是在明置以后才会有（所以这里应该是空），但是怕的是给别人提供residue的技能和各种DIY奇葩技能
					for _,skillName in ipairs(limitless_skills) do
						table.insert(skills_to_show, skillName)
					end
					limitless_settled = true
				end
				if not limitless_settled then
					if testCardTargetForSpecificSkill(sgs.TargetModSkill_Residue, from, slash, "none", false, true) >= 998 then
						room:writeToConsole("Error: Lua Residue skills in other extensions using flags")
						return "", ""  --其他Lua扩展存在通过flag返回998的技能，无解
					end
					for _,skillName in ipairs(tarmods) do  --剩下的体制内技能都不会通过flag返回998了
						if testCardTargetForSpecificSkill(sgs.TargetModSkill_Residue, from, slash, skillName, false, true) >= 998 then
							if from:hasShownSkill(skillName) or from:hasEquipSkill(skillName) then
								table.insert(skills_to_broadcast, skillName)
								limitless_settled = true
								break
							end
							table.insert(limitless_skills, skillName)
						end
					end
				end
				if not limitless_settled and not next(limitless_skills) then
					room:writeToConsole("Error: Unknown error for checkTargetModSkillShowForSlash to return >=998")
					return "", ""
				end
				if limitless_settled then break end
			end
			
			local invalidSkills_withLimit = table.copyFrom(invalidSkills_backup)
			local invalidSkills_shown_withLimit = table.copyFrom(invalidSkills_shown_backup)
			table.insertTable(invalidSkills_withLimit, limitless_skills)  --先将返回998的暗置技能无效掉，以确保下面的判断正确
			table.insertTable(invalidSkills_shown_withLimit, limitless_skills)
			table.removeTable(tarmods, limitless_skills)
			
			local tarmods_copy = table.copyFrom(tarmods)
			for _,skillName in ipairs(tarmods_copy) do  --剔除无关的TargetModSkill
				if testCardTargetForSpecificSkill(sgs.TargetModSkill_Residue, from, slash, skillName, true, false, invalidSkills_withLimit, invalidSkills_shown_withLimit) == 0 then
					table.removeOne(tarmods, skillName)
				end
			end
			
			local tarmods_copy = table.copyFrom(tarmods)
			for _,skillName in ipairs(tarmods_copy) do  --剔除已经明置的TargetModSkill及装备技能
				if from:hasShownSkill(skillName) or from:hasEquipSkill(skillName) then
					if extra_slash_count > 0 then table.insert(skills_to_broadcast, skillName) end
					extra_slash_count = extra_slash_count - testCardTargetForSpecificSkill(sgs.TargetModSkill_Residue, from, slash, skillName, true, false, invalidSkills_withLimit, invalidSkills_shown_withLimit)
					table.removeOne(tarmods, skillName)
				end
			end
			
			--此时tarmods存储了所有会导致上限增加（非998），但尚未亮出的技能
			--limitless_skills存储了所有会导致上限成为998，但尚未亮出的技能
			--而extra_slash_count存储了（在不亮任何tarmods中的技能的情况下）超出上限的使用数量
			if (#tarmods + #limitless_skills ~= 0) and (extra_slash_count > 0) then  --需要亮TargerMod
				table.insertTable(skills_to_show, tarmods)
				table.insertTable(skills_to_show, limitless_skills)
			end
		until true
	end
	
	return table.concat(skills_to_show, ","), table.concat(skills_to_broadcast, ",")
end
showTMSkillForSlash = sgs.CreateTriggerSkill{
	name = "showTMSkillForSlash",
	global = true,
	priority = 10,
	events = {sgs.PreCardUsed, sgs.ChoiceMade},  --系统实际亮将实际在room::useCard里，但是PreCardUsed是lua能触及到的最早时机
	on_record = function(self, event, room, player, data)
		if event == sgs.ChoiceMade then  --记录方天杀的目标；记录askForUseCard的几个flag
			if data:toString() == "" then  --只能这样判断是否为CardUseStruct
				local use = data:toCardUse()
				if (not use.card) or (not use.card:isKindOf("Slash")) then return end
				if player:hasFlag("HalberdUse") then
					for _,to in sgs.qlist(use.to) do
						room:setPlayerFlag(to, "forTM_HalberdSlashOriginalTargets")
					end
				end
				if player:hasFlag("slashNoDistanceLimit") then
					room:setPlayerFlag(player, "forTM_slashNoDistanceLimit")  --PreCardUsed应该不会再插入新的使用杀结算，所以应该不需要记录卡牌（何况还有羽扇)
				end
				if player:hasFlag("slashTargetFix") then
					room:setPlayerFlag(player, "forTM_slashTargetFix")
					for _,to in sgs.qlist(room:getAllPlayers()) do
						if to:hasFlag("SlashAssignee") then
							room:setPlayerFlag(to, "forTM_SlashAssignee")
						end
					end
				end
			elseif (data:toString() ~= "") then
				local arg = data:toString():split(":")
				if #arg == 3 and arg[1] == "playerChosen" and arg[2] == "Halberd" then
					for _,p in sgs.qlist(room:getAllPlayers()) do
						if p:objectName() == arg[3] then
							room:setPlayerFlag(p, "forTM_HalberdSlashExtraTargets")
							break
						end
					end
				end
			end
		end
		
		if event ~= sgs.PreCardUsed then return end
		local use = data:toCardUse()
		if not use.card:isKindOf("Slash") then return end
		
		
		local broadcasted_map = {}  --已经播放配音的技能
		local system_broadcast_skills = {"halberd-target", "tianyi", "duanbing", "paoxiao", "Crossbow", "shensu", "shuangren"}
		local specific_audio_index = {LiegongLB = 2, Jiangchi = 2, Lihuo = 1, Qiangwu_XingCai = 1, Tuifeng = 1, Qiangwu_XingCai_OL = 1}
		local function broadcastSkills(skills_to_broadcast)
			if skills_to_broadcast ~= "" then
				for _,skillName in ipairs(skills_to_broadcast:split(",")) do
					if skillName == "" then continue end
					if not broadcasted_map[skillName] then
						if not table.contains(system_broadcast_skills, skillName) and (not use.card:getSkillName() == skillName) then
							local index = specific_audio_index[skillName]
							if index then
								room:broadcastSkillInvoke(skillName, index, use.from)
							else
								room:broadcastSkillInvoke(skillName, use.from)
							end
							room:notifySkillInvoked(use.from, skillName)
						end
						broadcasted_map[skillName] = true
					end
				end
			end
		end
		
		local TMskills_to_show, TMskills_to_broadcast = checkTargetModSkillShowForSlash(use, true)
		local count = 0  --防死循环
		while TMskills_to_show ~= "" do
			broadcastSkills(TMskills_to_broadcast)
			local to_show = room:askForChoice(use.from, "tarmod_show", string.gsub(TMskills_to_show, ",", "+"), data)  --askForTriggerOrder对lua不开放
			if use.from:inHeadSkills(to_show) or use.from:inDeputySkills(to_show) then
				use.from:showGeneral(use.from:inHeadSkills(to_show))
				broadcastSkills(to_show)
			end
			TMskills_to_show, TMskills_to_broadcast = checkTargetModSkillShowForSlash(use, false)
			count = count + 1
			if count >= 20 then
				room:writeToConsole("Error: No TargetMod skills could be shown for target modifications")
				room:writeToConsole("Card: " .. use.card:toString())
				break
			end
		end
		broadcastSkills(TMskills_to_broadcast)
		
		if use.card:hasFlag("halberd_slash") then  --清除记录信息
			for _,p in sgs.qlist(room:getAllPlayers()) do
				room:setPlayerFlag(p, "-forTM_HalberdSlashOriginalTargets")
				room:setPlayerFlag(p, "-forTM_HalberdSlashExtraTargets")
			end
		end
		if player:hasFlag("forTM_slashNoDistanceLimit") then
			room:setPlayerFlag(player, "-forTM_slashNoDistanceLimit")
		end
		if player:hasFlag("forTM_slashTargetFix") then
			room:setPlayerFlag(player, "-forTM_slashTargetFix")
			for _,to in sgs.qlist(room:getAllPlayers()) do
				room:setPlayerFlag(to, "-forTM_SlashAssignee")
			end
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end
}
local skills = sgs.SkillList()
if not sgs.Sanguosha:getSkill("showTMSkillForSlash") then skills:append(showTMSkillForSlash) end
sgs.Sanguosha:addSkills(skills)

--势力数
function getKingdomCount(player)
	local players
	if type(player) == "ServerPlayer" then
		players = player:getRoom():getAllPlayers()
	else
		players = player:getAliveSiblings()
		players:append(player)
	end
	local kingdom_set = {}
	local careerists = 0
	for _, p in sgs.qlist(players) do
		local flag = true
		for _, k in ipairs(kingdom_set) do
			if p:getKingdom() == k then
				flag = false
				break
			end
		end
		if p:getRole() == "careerist" then  --野心家自己为一种实力（也就是说8人局势力数最大可以为7，死亡的君主以外的7个野心家）
			careerists = careerists + 1
		elseif p:hasShownOneGeneral() and p:getKingdom() ~= "god" and flag then 
			table.insert(kingdom_set, p:getKingdom())
		end 
	end
	return #kingdom_set + careerists
end

--不能选择其他角色为目标（临时用取消代替禁止技）
CancelOtherTargets = sgs.CreateTriggerSkill{
	name = "CancelOtherTargets",
	events = {sgs.CardUsed},
	global = true,
	priority = 10,
	can_trigger = function(self, event, room, player, data)
		if not player:hasFlag("DisableOtherTargets") then return "" end
		local use = data:toCardUse()
		if use.card and (use.card:getTypeId() ~= sgs.Card_TypeSkill) then
			for _,p in sgs.qlist(use.to) do
				if p:objectName() ~= player:objectName() then
					return self:objectName()
				end
			end
		end
		return ""
	end,
	on_effect = function(self, event, room, player, data)
		local use = data:toCardUse()
		local done = false
		while not done do
			done = true
			for _,p in sgs.qlist(use.to) do
				if p:objectName() ~= player:objectName() then
					sgs.Room_cancelTarget(use, p)
					done = false
					break
				end
			end
		end
		data:setValue(use)
		if use.to:isEmpty() then
			return true
		end
		return false
	end,
}
local skills = sgs.SkillList()
if not sgs.Sanguosha:getSkill("CancelOtherTargets") then skills:append(CancelOtherTargets) end
sgs.Sanguosha:addSkills(skills)

--[[对v2中InvaliditySkill的实现
	使用前定义一个类似isSkillValid的函数，参数为(self, player, skill, isHas)
	其中self为这个InvaliditySkill的技能对象（如武圣铁骑），虽然大多数时候它的意义仅仅是提供一个技能名，一般用个相关的可见触发技就行
	isHas表示这次判断是否为判断hasSkill，如果为false，说明这次判断的是hasShownSkill。通常技能可以直接无视
	注意此函数仅应判断因这一个InvaliditySkill导致无效的技能，不要画蛇添足帮其他技能去判断
	（例如武圣的isSkillValid函数只判断武圣就行了，不用判断铁骑，因为铁骑技能里会再调用一次updateSkillValidity）
	并且会传入此函数的skill仅包括可见技能，因为对不可见技能调用hasSkill/hasShownSkill是没有意义的（会自动跳转到主技能）
	
	在可能改变这个函数的值（即改变技能有效性）时调用updateSkillValidity(inv_skill, func, players)
	其中inv_skill为这个InvaliditySkill对象（如武圣铁骑，仅用于记录技能名及作为self传给isSkillValid），func为上面提到的这个isSkillValid函数
		（尽量不要对若干不同的isSkillValid函数用同一个inv_skill，会导致记录混乱）
	players为要刷新技能有效性的玩家（默认为所有玩家）
	（所以你要把InvaliditySkill当成触发技去写）
	按照v2，原则上这个定义的函数应该是在客户端执行；但是由于此处代码的实现方式，调用服务器中的内容也是没有问题的
 
	updateSkillValidity暂无返回值（远期计划：返回一个字符串，描述了因为这次扫描而对每名玩家添加或减少的技能）
								（此字符串的格式为：player1+skill1+skill2+skill3|player2+skill4|...）

	扫描时，会自动记录无效的技能是因为哪个InvaliditySkill而无效的
	此记录信息存储在property("invalid_skill_has_reasons")及property("invalid_skill_shown_reasons")中，格式为：skill1+reason1+reason2|skill2+reason3|...
	reason可以叠加，在技能恢复有效时会判断是否所有reason都恢复了，只有是才会恢复技能

	由于此函数视为技的特性（与v2不同），每次调用会自动为所有玩家进行一次filterCards和UPDATE_SKILL，所以技能代码中不用专门处理
	
	注意：此函数为全局效果，而且调用一次即可（除非players不为空，则仅对指定的玩家刷新）
]]
InvaliditySkills = {}  --调用updateSkillValidity时自动更新此table
InvaliditySkillFuncs = {}
function updateSkillValidity(inv_skill, func, players)
	local room = sgs.Sanguosha:currentRoom()
	if type(players) == "ServerPlayer" then
		local player_copy = players
		players = sgs.SPlayerList()
		players:append(player_copy)
	end
	players = players or room:getAllPlayers()
	for _,player in sgs.qlist(players) do
		local inv_skill_has = player:property("invalid_skill_has"):toString():split("+")  --可直接被源码读取
		table.removeAll(inv_skill_has, "")
		local inv_skill_has_reasons = player:property("invalid_skill_has_reasons"):toString():split("|")
		table.removeAll(inv_skill_has_reasons, "")
		local inv_skill_shown = player:property("invalid_skill_shown"):toString():split("+")  --可直接被源码读取
		table.removeAll(inv_skill_shown, "")
		local inv_skill_shown_reasons = player:property("invalid_skill_shown_reasons"):toString():split("|")
		table.removeAll(inv_skill_shown_reasons, "")
		local tobe_invalid_has, tobe_invalid_shown = {}, {}
		local tobe_valid_has, tobe_valid_shown = {}, {}
		
		local visible_skill_names = {}
		for _,skill in sgs.qlist(player:getVisibleSkillList()) do  --hasSkill/hasShownSkill的判断会自动跳转到主技能
			table.insert(visible_skill_names, skill:objectName())
			if func(inv_skill, player, skill, true) then  --valid_has
				table.insert(tobe_valid_has, skill:objectName())
			else
				table.insert(tobe_invalid_has, skill:objectName())
			end
			if func(inv_skill, player, skill, false) then  --valid_shown
				table.insert(tobe_valid_shown, skill:objectName())
			else
				table.insert(tobe_invalid_shown, skill:objectName())
			end
		end
		
		local reason = inv_skill:objectName()
		if sgs.Sanguosha:getMainSkill(inv_skill:objectName()) then
			reason = sgs.Sanguosha:getMainSkill(inv_skill:objectName()):objectName()
		end
		if not table.contains(InvaliditySkills, reason) then
			table.insert(InvaliditySkills, reason)
		end
		InvaliditySkillFuncs[reason] = func
		
		local hasRemoved = false  --for filterCards
		if #tobe_invalid_has > 0 then  --add
			for _,skillName in ipairs(tobe_invalid_has) do
				local existed = false
				for i, str in ipairs(inv_skill_has_reasons) do
					if str == "" then continue end
					local reasons = str:split("+")
					if reasons[1] == skillName then
						existed = true
						table.remove(reasons, 1)
						if not table.contains(reasons, reason) then
							table.insert(reasons, reason)
							inv_skill_has_reasons[i] = skillName .. "+" .. table.concat(reasons, "+")
						end
						break
					end
				end
				if not existed then
					table.insert(inv_skill_has, skillName)
					table.insert(inv_skill_has_reasons, skillName .. "+" .. reason)
				end
			end
		end
		if #tobe_valid_has > 0 then  --remove
			for _,skillName in ipairs(tobe_valid_has) do
				if table.contains(inv_skill_has, skillName) then
					local can_remove = true
					for i, str in ipairs(inv_skill_has_reasons) do
						if str == "" then continue end
						local reasons = str:split("+")
						if reasons[1] == skillName then
							table.remove(reasons, 1)
							if table.contains(reasons, reason) then
								table.removeAll(reasons, reason)
							end
							table.removeAll(reasons, "")
							if #reasons ~= 0 then 
								can_remove = false
								inv_skill_has_reasons[i] = skillName .. "+" .. table.concat(reasons, "+")
							else
								can_remove = true
								table.remove(inv_skill_has_reasons, i)
							end
							break
						end
					end
					if can_remove then
						table.removeAll(inv_skill_has, skillName)
						table.removeAll(inv_skill_has_reasons, "")
						hasRemoved = true
					end
				end
			end
		end
		
		if #tobe_invalid_shown > 0 then  --add
			for _,skillName in ipairs(tobe_invalid_shown) do
				local existed = false
				for i, str in ipairs(inv_skill_shown_reasons) do
					if str == "" then continue end
					local reasons = str:split("+")
					if reasons[1] == skillName then
						existed = true
						table.remove(reasons, 1)
						if not table.contains(reasons, reason) then
							table.insert(reasons, reason)
							inv_skill_shown_reasons[i] = skillName .. "+" .. table.concat(reasons, "+")
						end
						break
					end
				end
				if not existed then
					table.insert(inv_skill_shown, skillName)
					table.insert(inv_skill_shown_reasons, skillName .. "+" .. reason)
				end
			end
		end
		if #tobe_valid_shown > 0 then  --remove
			for _,skillName in ipairs(tobe_valid_shown) do
				if table.contains(inv_skill_shown, skillName) then
					local can_remove = true
					for i, str in ipairs(inv_skill_shown_reasons) do
						if str == "" then continue end
						local reasons = str:split("+")
						if reasons[1] == skillName then
							table.remove(reasons, 1)
							if table.contains(reasons, reason) then
								table.removeAll(reasons, reason)
							end
							table.removeAll(reasons, "")
							if #reasons ~= 0 then 
								can_remove = false
								inv_skill_shown_reasons[i] = skillName .. "+" .. table.concat(reasons, "+")
							else
								can_remove = true
								table.remove(inv_skill_shown_reasons, i)
							end
							break
						end
					end
					if can_remove then
						table.removeAll(inv_skill_shown, skillName)
						table.removeAll(inv_skill_shown_reasons, "")
						hasRemoved = true
					end
				end
			end
		end
		
		local function clearUnnecessarySkills(skills)  --清除已经失去的技能，避免再次获得后造成残留
			local skills_copy = table.copyFrom(skills)
			for _,skill_str in ipairs(skills_copy) do
				local skill = skill_str:split("+")[1]
				if not table.contains(visible_skill_names, skill) then
					table.removeAll(skills, skill_str)
				end
			end
		end
		clearUnnecessarySkills(inv_skill_has)
		clearUnnecessarySkills(inv_skill_has_reasons)
		clearUnnecessarySkills(inv_skill_shown)
		clearUnnecessarySkills(inv_skill_shown_reasons)
		
		room:setPlayerProperty(player, "invalid_skill_has", sgs.QVariant(table.concat(inv_skill_has, "+")))
		room:setPlayerProperty(player, "invalid_skill_has_reasons", sgs.QVariant(table.concat(inv_skill_has_reasons, "|")))
		room:setPlayerProperty(player, "invalid_skill_shown", sgs.QVariant(table.concat(inv_skill_shown, "+")))
		room:setPlayerProperty(player, "invalid_skill_shown_reasons", sgs.QVariant(table.concat(inv_skill_shown_reasons, "|")))
		
		room:filterCards(player, player:getCards("he"), hasRemoved)
		local arg = {8}
		room:doBroadcastNotify(sgs.CommandType.S_COMMAND_LOG_EVENT, json.encode(arg))
	end
end
updateInvalidityForNewSkills = sgs.CreateTriggerSkill{  --获得技能时刷新Invalidity
	name = "updateInvalidityForNewSkills", 
	events = {sgs.EventAcquireSkill, sgs.GeneralShown},  --GeneralShown为变副将 
	global = true, 
	priority = 10, 
	on_record = function(self, event, room, player, data)
		for _,skillName in ipairs(InvaliditySkills) do
			local skill = sgs.Sanguosha:getSkill(skillName)
			if skill then
				updateSkillValidity(skill, InvaliditySkillFuncs[skillName], player)
			end
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end
}
local skills = sgs.SkillList()
if not sgs.Sanguosha:getSkill("updateInvalidityForNewSkills") then skills:append(updateInvalidityForNewSkills) end
sgs.Sanguosha:addSkills(skills)

--实际目标数（人头数）
function getEffectiveTargetNum(targets)
	local tab = {}
	for _,p in sgs.qlist(targets) do
		if p:isAlive() and not table.contains(tab, p) then
			table.insert(tab, p)
		end
	end
	return #tab
end

--获得牌堆中所有某一类型的牌名（如所有基本牌）
function fetchCards(check_func, name_func, player)
	--（check_func及name_func为判断函数，前者判断是否符合要求返回bool，后者修正卡牌名称返回string）
	--check_func也可为字符串（如"BasicCard,NDTrick,Blade"）
	if type(check_func) == "string" then
		local check_strs = check_func:split(",")
		check_func = function(card, player)
			for _,typeid in ipairs(check_strs) do
				if card:isKindOf(typeid) or ((typeid == "NDTrick") and card:isNDTrick()) then
					return true
				end
			end
			return false
		end
	elseif type(check_func) ~= "function" then return {} end
	if not name_func or type(name_func) ~= "function" then
		name_func = function(card)
			return card:objectName()
		end
	end
	local result_table = {}
	local cardName = ""
	local card
	for cardid = 0, sgs.Sanguosha:getCardCount() - 1 do
		card = sgs.Sanguosha:getEngineCard(cardid)
		cardName = name_func(card)
		if not table.contains(sgs.Sanguosha:getBanPackages(), card:getPackage()) and not table.contains(result_table, cardName) then
			if check_func(card, player) then
				table.insert(result_table, cardName)
			end
		end
	end
	return result_table
end

--判断某角色是否为指定武将（用于配音）
function matchPlayerName(player, name)
	local alternative_names = {  --用于无法直接靠string.find找出的（如倚天包）
		["zhugeliang"] = "wolong",
	}
	if alternative_names[name] then
		if matchPlayerName(player, alternative_names[name]) then return true end
	end
	return string.find(string.lower(player:getGeneralName()), string.lower(name)) or string.find(string.lower(player:getGeneral2Name()), string.lower(name))
end

--判断是否为大势力（lua\utilities.lua虽然有sgs.isBigKingdom函数，但是MaxCardsType自动为最大，因此不好用）
function isBigKingdom(player, viewer, reason)
	--实际是站在viewer的角度判断player是否为大势力（viewer为君张角时会受到黄巾天兵符影响）
	viewer = viewer or player
	if not player:hasShownOneGeneral() then return false end
	local isBig = false
	local big_kingdoms = viewer:getBigKingdoms(reason, 0)  --MaxCardsType用不了
	if table.contains(big_kingdoms, player:objectName()) then
		isBig = true
	else
		local kingdom = (player:getRole() == "careerist") and "careerist" or player:getKingdom()
		isBig = table.contains(big_kingdoms, kingdom)
	end
	return isBig
end

--手动控制视为技配音（模拟源码中的getEffectIndex）
function getAudioEffectIndex(player, card)  --预设值（相当于源码技能的getEffectIndex函数），包括了一部分预留
	local skillName = card:getSkillName()
	local skin_id = player:property((player:inHeadSkills(skillName) and "head" or "deputy") .. "_skin_id"):toInt() or 0
	local audioEffectIndex = {				--注：0：静音；-1：随机播放；-2：播放卡牌原有配音
		RendeLB = function(player, card, skin_id)
			return (card:getTypeId() == sgs.Card_TypeSkill) and -1 or -2
		end,
		GuoseLB = function(player, card, skin_id)
			return card:isKindOf("Indulgence") and 1 or 2
		end,
		Liyu = -2,
		Longhun = function(player, card, skin_id)
			if skin_id == 1 then
			--return player:getRoom():getCard(card:getSubcards():first()):getSuit() + 1   --实际播放配音混乱，原因不明
				if card:isKindOf("Nullification") then return 1
				elseif card:isKindOf("Jink") then return 2
				elseif card:isKindOf("Peach") then return 3
				else return 4 end
			else return -1
			end
		end,
		zhiheng = function(player, card, skin_id)  --getSkillName依然是制衡，原因不明
			if player:hasFlag("JilyueZhihengAudio") then return 4
			else return nil end
		end,
		Jiushi = math.random(1, 2),
		Mingce = function(player, card, skin_id)
			return card:isKindOf("Slash") and -2 or -1
		end,
		Fuhun = 1,
		Lihuo = function(player, card, skin_id)
			return (skin_id == 1) and 1 or -1
		end,
		Chunlao = function(player, card, skin_id)
			if skin_id == 1 then
				return matchPlayerName(player, "zhouyu") and 3 or 2
			else
				return 1
			end
		end,
		Xiansi = function(player, card, skin_id)
			return math.random(1, 2) + (card:isKindOf("Slash") and 2)
		end,
		--Bifa = 1,  --技能里有3个配音，但是实际只有2个
		Meibu = function(player, card, skin_id)
			return card:isKindOf("Slash") and -2 or -1
		end,
		Shefu = 1,
		Quji = 1,
		Jieyue = function(player, card, skin_id)
			--if card:isKindOf("Nullification") then return 3
			--elseif card:isKindOf("Jink") then return 2
			if card:isKindOf("Jink") or card:isKindOf("Nullification") then return 2  --技能里有3个配音，但是实际只有2个
			else return 1 end
		end,
		SidiOL = 2,
		Chenqing = -2,
		Zhixi = function(player, card, skin_id)
			return card:isKindOf("Slash") and -2 or -1
		end,
		Tanhu = 1,
	}
	local ret = audioEffectIndex[skillName]
	if ret then
		if type(ret) == "number" then
			return ret
		elseif type(ret) == "function" then
			return ret(player, card, skin_id)
		end
	end
	return nil
end
function broadcastSkillInvoke_lua(player, card)
	local room = player:getRoom()
	if card:getClassName() == "ZhihengCard" and player:hasFlag("JilyueZhihengAudio") then  --DIRTY HACK
		room:broadcastSkillInvoke("Jilyue", 4, player)
		return
	end
	if card:isMute() then return end
	local skill_name = card:getSkillName()
	local skill = sgs.Sanguosha:getSkill(skill_name)
	if not skill then
		if not card:getCommonEffectName() then
			player:broadcastSkillInvoke(card:objectName())
		else
			room:broadcastSkillInvoke(card:getCommonEffectName(), "common")
		end
	else
		local index = getAudioEffectIndex(player, card)
		if not index then
			index = skill:getEffectIndex(player, card)
		end
		if index == 0 then return end
		if (index == -1 and not next(skill:getSources())) or index == -2 then
			if card:getCommonEffectName() and card:getCommonEffectName() ~= "" then
				room:broadcastSkillInvoke(card:getCommonEffectName(), "common")
			else
				player:broadcastSkillInvoke(card:objectName())
			end
		else
			room:broadcastSkillInvoke(skill_name, index, player)
		end
	end
end
customAudioEffect = sgs.CreateTriggerSkill{
	name = "customAudioEffect", 
	events = {sgs.PreCardUsed}, 
	global = true, 
	priority = 1, 
	on_record = function(self, event, room, player, data)
		local use = data:toCardUse()
		local card = use.card
		local skill = sgs.Sanguosha:getSkill(card:getSkillName())
		if not skill then return end
		
		local index = getAudioEffectIndex(use.from, card)
		local real_index = skill:getEffectIndex(use.from, card)
		
		if index and (not real_index or index ~= real_index) then  --抄PreCardUsed
			if use.from:hasFlag("Global_ForbidSurrender") then
				use.from:setFlags("-Global_ForbidSurrender")
				room:doNotify(use.from, sgs.CommandType.S_COMMAND_ENABLE_SURRENDER, true)
			end
			
			broadcastSkillInvoke_lua(use.from, card)
			if card:getSkillName() and card:getSkillName(true) == card:getSkillName(false) and use.m_isOwnerUse and use.from:hasSkill(card:getSkillName()) then
				room:notifySkillInvoked(use.from, card:getSkillName())
			end
			
			room:setTag("SkipGameRule", sgs.QVariant(true))
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end
}
local skills = sgs.SkillList()
if not sgs.Sanguosha:getSkill("customAudioEffect") then skills:append(customAudioEffect) end
sgs.Sanguosha:addSkills(skills)

--由于系统bug，即使不能使用锦囊牌时也可以使用勠力同心，因此需要手动取消
CancelFightTogether = sgs.CreateTriggerSkill{
	name = "CancelFightTogether",
	events = {sgs.PreCardUsed},  --取消此牌（虽然在CardUsed取消一般会更有用，避开onUse里面一长串代码，但是越早越好）
	priority = 9,
	frequency = sgs.Skill_Wake,  --这招在旧版不管用，但是这个时机，这个priority就这一个技能，无视Compulsory即可
	global = true,
	can_trigger = function(self, event, room, player, data)
		local use = data:toCardUse()
		if use.card and use.card:isKindOf("FightTogether") and use.from and use.from:isLocked(use.card) and use.card:getHandlingMethod() == sgs.Card_MethodUse then
			return self:objectName()
		end
	end,
	on_cost = function(self, event, room, player, data)
		local msg = sgs.LogMessage()
		msg.type, msg.from = "#CancelFightTogether", player
		room:sendLog(msg)  --国战使用牌的显示在PreCardUsed之前，因此需要加个msg来解释
		return ""
	end,
	on_effect = function(self, event, room, player, data)
		local use = data:toCardUse()
		use.card = sgs.DummyCard()
		use.to = sgs.SPlayerList()
		data:setValue(use)
		return true
	end,
}
local skills = sgs.SkillList()
if not sgs.Sanguosha:getSkill("CancelFightTogether") then skills:append(CancelFightTogether) end
sgs.Sanguosha:addSkills(skills)

-----------------------------------------------新标风-----------------------------------------------

extensionRenew = sgs.Package("Renew", sgs.Package_GeneralPack)

--[[ WEI 011 曹仁
	武将：CaoRen_13
	武将名：曹仁-13新
	体力上限：4
	武将技能：
		据守：结束阶段开始时，你可以摸一张牌，然后叠置。
		解围：当你的武将牌叠置后，你可以摸一张牌，然后你可以使用一张锦囊牌或装备牌，若如此做，你可以弃置场上一张与之类别相同的牌。
	状态：验证通过
]]--
CaoRen_13 = sgs.General(extensionRenew, "CaoRen_13", "wei", 4, true, true)
CaoRen_13:addCompanion("caohong")

--[[
	技能名：据守
	技能：Jushou13
	描述：结束阶段开始时，你可以摸一张牌，然后叠置。
	状态：验证通过
]]--
Jushou13 = sgs.CreatePhaseChangeSkill{
	name = "Jushou13",
	can_preshow = true,
	frequency = sgs.Skill_Frequent,
	can_trigger = function(self, event, room, player, data)
		if not player or player:isDead() or not player:hasSkill(self:objectName()) then return "" end
		if player:getPhase() == sgs.Player_Finish then return self:objectName() end
	end,
	on_cost = function(self, event, room, player, data)
		if player:askForSkillInvoke(self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), player)
			return true 
		end
		return false 
	end,
	on_phasechange = function(self, player)
		local room = player:getRoom()
		player:drawCards(1, self:objectName())
		player:turnOver()
		return false
	end,
}
CaoRen_13:addSkill(Jushou13)

--[[
	技能名：解围
	技能：Jiewei
	描述：当你的武将牌叠置后，你可以摸一张牌，然后你可以使用一张锦囊牌或装备牌，若如此做，你可以弃置场上一张与之类别相同的牌。
	状态：验证通过
]]--
doJiewei = function(self, room, player)  --13与15公用
	player:drawCards(1, self:objectName())
	
	local tricks, disabled_tricks = fetchCards("TrickCard", nil, player), {"TrickCard"}
	local dummy_trick
	for _,trick in ipairs(tricks) do
		dummy_trick = sgs.Sanguosha:cloneCard(trick, sgs.Card_NoSuit, 0)
		dummy_trick:setCanRecast(false)
		if not dummy_trick:isAvailable(player) then
			table.insert(disabled_tricks, dummy_trick:getClassName())
		end
	end
	player:setFlags("JieweiUsing")  --for LT and TE
	local card = room:askForUseCard(player, table.concat(disabled_tricks, "+^") .. ",EquipCard|.|.|hand", "@Jiewei")
	player:setFlags("-JieweiUsing")
	if not card or player:isDead() then return false end
	
	local targets = sgs.SPlayerList()
	if card:getTypeId() == sgs.Card_TypeTrick then
		for _, p in sgs.qlist(room:getAlivePlayers()) do
			local can_discard = false
			for _, judge in sgs.qlist(p:getJudgingArea()) do
				if (judge:getTypeId() == sgs.Card_TypeTrick) and (player:canDiscard(p, judge:getEffectiveId())) then
					can_discard = true
					break
				elseif judge:getTypeId() == sgs.Card_TypeSkill then
					local real_card = Sanguosha:getEngineCard(judge:getEffectiveId())
					if (real_card:getTypeId() == sgs.Card_TypeTrick) and (player:canDiscard(p, real_card:getEffectiveId())) then
						can_discard = true
						break
					end
				end
			end
			if can_discard then targets:append(p) end
		end
	elseif (card:getTypeId() == sgs.Card_TypeEquip) then
		for _, p in sgs.qlist(room:getAlivePlayers()) do
			if (not p:getEquips():isEmpty()) and (player:canDiscard(p, "e")) then
				targets:append(p)
			else
				for _, judge in sgs.qlist(p:getJudgingArea()) do
					if judge:getTypeId() == sgs.Card_TypeSkill then
						local real_card = Sanguosha:getEngineCard(judge:getEffectiveId())
						if (real_card:getTypeId() == sgs.Card_TypeEquip) and (player:canDiscard(p, real_card:getEffectiveId())) then
							targets:append(p)
							break
						end
					end
				end
			end
		end
	end
	if targets:isEmpty() then return false end
	local to_discard = room:askForPlayerChosen(player, targets, self:objectName(), "@Jiewei-discard:::" .. card:getType(), true)  --todo：变包改用GlobalCardsChosen
	if to_discard then
		local disabled_ids = sgs.IntList()
		for _, c in sgs.qlist(to_discard:getCards("ej")) do
			local pcard = c 
			if (pcard:getTypeId() == sgs.Card_TypeSkill) then
				pcard = sgs.Sanguosha:getEngineCard(c:getEffectiveId())
			end
			if (pcard:getTypeId()~= card:getTypeId()) then
				disabled_ids:append(pcard:getEffectiveId())
			end
		end
		local id = room:askForCardChosen(player, to_discard, "ej", self:objectName(), false, sgs.Card_MethodDiscard, disabled_ids)
		local owner = (room:getCardPlace(id) ~= sgs.Player_PlaceDelayedTrick) and room:getCardOwner(id) or nil
		local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_DISMANTLE, player:objectName(), owner and owner:objectName() or nil, self:objectName(), nil)
		room:throwCard(sgs.Sanguosha:getCard(id), reason, owner, player)
	end
end
Jiewei = sgs.CreateTriggerSkill{
	name = "Jiewei",
	can_preshow = true,
	events = {sgs.TurnedOver},
	can_trigger = function(self, event, room, player, data)	
		if not player or player:isDead() or not player:hasSkill(self:objectName()) then return "" end
		return self:objectName()
	end,
	on_cost = function(self, event, room, player, data)
		if player:askForSkillInvoke(self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), player)
			return true 
		end
		return false 
	end,
	on_effect = function(self, event, room, player, data)
		doJiewei(self, room, player)
		return false
	end,
}
JieweiLTandTE = sgs.CreateTriggerSkill{
	name = "#Jiewei-LTandTE",
	frequency = sgs.Skill_Compulsory, 
	events = {sgs.ChoiceMade, sgs.CardEffectConfirmed, sgs.PostCardEffected, sgs.CardFinished},  --对系统的调虎离山和挟天子效果进行修改
	global = true,  --这里的Compulsory+Global是故意的
	priority = 7,
	on_record = function(self, event, room, player, data)	
		if event == sgs.ChoiceMade then
			if data:toString() == "" then  --只能这样判断是否为CardUseStruct
				if data:toCardUse().card and player:hasFlag("JieweiUsing") then
					player:setFlags("-JieweiUsing")
					local card = data:toCardUse().card
					local has_current = room:getCurrent() and room:getCurrent():getPhase() ~= sgs.Player_NotActive
					if (card:isKindOf("LureTiger") and player:getPhase() == sgs.Player_NotActive and not player:hasFlag("LureTigerUser"))
						or (card:isKindOf("ThreatenEmperor") and player:getMark("ThreatenEmperorExtraTurn") == 0 and not has_current) then
						room:setCardFlag(card, "JieweiAffected")
						room:setPlayerFlag(player, "JieweiAffected" .. card:toString())  --相比寄篱做了点改进，只有满足修改效果条件才会添加Affected
					end
				end
			end
		elseif (event == sgs.PostCardEffected) then
			local effect = data:toCardEffect()
			if not effect.card:hasFlag("JieweiAffected") then return false end
			if not effect.from:hasFlag("JieweiAffected" .. effect.card:toString()) then return false end
			
			local has_current = room:getCurrent() and room:getCurrent():getPhase() ~= sgs.Player_NotActive
			if effect.card:isKindOf("LureTiger") then
				player:setFlags("-LureTigerUser")
				if has_current then
					room:getCurrent():setFlags("LureTigerUser")
				else
					room:setPlayerProperty(effect.to, "removed", sgs.QVariant(false))
					room:removePlayerCardLimitation(effect.to, "use", ".$0")
				end
			elseif effect.card:isKindOf("ThreatenEmperor") then
				player:removeMark("ThreatenEmperorExtraTurn")
			end
		elseif event == sgs.CardFinished then  --Clear
			local use = data:toCardUse()
			if use.card:hasFlag("JieweiAffected") then
				room:setCardFlag(use.card, "-JieweiAffected")
				for _,p in sgs.qlist(room:getAlivePlayers()) do
					room:setPlayerFlag(p, "-JieweiAffected" .. use.card:toString()) 
				end
			end
			return
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
CaoRen_13:addSkill(Jiewei)
CaoRen_13:addSkill(JieweiLTandTE)
sgs.insertRelatedSkills(extensionRenew, "Jiewei", "#Jiewei-LTandTE")

----------------------------------------------------------------------------------------------------

--[[ WU 013 周泰
	武将：ZhouTai_13
	武将名：周泰-13新
	体力上限：4
	武将技能：
		不屈：锁定技，当你处于濒死状态时，你将牌堆顶的一张牌置于武将牌上，称为“创”，然后若此“创”与其他“创”点数均不同，你将体力回复至1点，否则你移去此“创”（你的回合内每回合限一次）；若有“创”，你的手牌上限等于“创”的数量。
		奋激：当一名角色因另一名角色的弃置或获得而失去手牌后，你可以失去1点体力，令该失去手牌的角色摸两张牌。
	状态：复制吧友
]]--
ZhouTai_13 = sgs.General(extensionRenew, "ZhouTai_13", "wu", 4, true, true)
ZhouTai_13:addCompanion("sunquan")
ZhouTai_13:addCompanion("jiangqin")

--[[
	技能名：不屈
	技能：BuquRenew_ZhouTai_13
	描述：锁定技，当你处于濒死状态时，你将牌堆顶的一张牌置于武将牌上，称为“创”，然后若此“创”与其他“创”点数均不同，你将体力回复至1点，否则你移去此“创”（你的回合内每回合限一次）；若有“创”，你的手牌上限等于“创”的数量。
	状态：复制吧友
]]--
function sgs.CreateBuquRenewSkill(name)
	local buqu_skill = {
		name = "BuquRenew_" .. name,
		events = {sgs.AskForPeaches, sgs.EventLoseSkill},
		frequency = sgs.Skill_Compulsory,
		on_record = function(self, event, room, player, data)
			if event == sgs.EventLoseSkill and data:toString() == self:objectName() then
				player:clearOnePrivatePile("chuang_" .. name)
			end
		end,
		can_trigger = function(self, event, room, player, data)
			if not player or player:isDead() or not player:hasSkill(self:objectName()) then return "" end
			if event ~= sgs.AskForPeaches then return "" end
			if player:hasFlag("BuquRenew_" .. name .. "InMyTurn") then return "" end  --每回合限一次的限制
			local dying_data = data:toDying()
			if dying_data.who:objectName() ~= player:objectName() then
				return ""
			end
			if player:getHp() > 0 then return "" end
			return self:objectName()
		end,
		on_cost = function(self, event, room, player, data)
			if player:hasShownSkill(self:objectName()) or room:askForSkillInvoke(player, self:objectName(), data) then
				room:broadcastSkillInvoke(self:objectName(), player)
				return true
			end
			return false
		end,
		on_effect = function(self, event, room, player, data)
			room:sendCompulsoryTriggerLog(player, self:objectName(), true)
			if room:getCurrent() and room:getCurrent():objectName() == player:objectName() then  --每回合限一次的限制（todo：验证明鉴）
				player:setFlags("BuquRenew_" .. name .. "InMyTurn")
			end
			local id = room:drawCard()
			local num = sgs.Sanguosha:getCard(id):getNumber()
			local duplicate = false
			for _, card_id in sgs.qlist(player:getPile("chuang_" .. name)) do
				if sgs.Sanguosha:getCard(card_id):getNumber() == num then
					duplicate = true
					break
				end
			end
			player:addToPile("chuang_" .. name, id)
			if duplicate then
				local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_REMOVE_FROM_PILE, "", self:objectName(), "")
				room:throwCard(sgs.Sanguosha:getCard(id), reason, nil)
			else
				local recover = sgs.RecoverStruct()
				recover.who = player
				recover.recover = 1 - player:getHp()
				room:recover(player, recover)
			end
			return false
		end
	}
	return sgs.CreateTriggerSkill(buqu_skill)
end
BuquRenew_ZhouTai_13 = sgs.CreateBuquRenewSkill("ZhouTai_13")
function sgs.CreateBuquRenewMaxCardsSkill(name)
	local buqu_maxcards_skill = {
		name = "#BuquRenew-maxcards_" .. name,
		fixed_func = function(self, target)
			local len = target:getPile("chuang_" .. name):length()
			if len > 0 and target:hasShownSkill("BuquRenew_" .. name) then
				return len
			else
				return -1
			end
		end
	}
	return sgs.CreateMaxCardsSkill(buqu_maxcards_skill)
end
BuquRenewMaxCards_ZhouTai_13 = sgs.CreateBuquRenewMaxCardsSkill("ZhouTai_13")
function sgs.CreateBuquRenewShowMaxCardsSkill(name)
	local buqu_show_maxcards_skill = {
		name = "#BuquRenew-showmaxcards_" .. name,
		can_preshow = true,
		frequency = sgs.Skill_Compulsory,  --因为此技能必须尚未亮将，所以不需要处理无法取消的问题
		events = {sgs.EventPhaseProceeding},
		can_trigger = function(self, event, room, player, data)
			if not player or player:isDead() or not player:hasSkill(self:objectName()) then return "" end
			if (player:getPhase() == sgs.Player_Discard) and not player:hasShownSkill(self:objectName()) then  --进入弃牌阶段询问是否发动不屈存牌（邹氏等）
				if player:getPile("chuang_" .. name):isEmpty() then return "" end
				if math.max(player:getHandcardNum() - player:getMaxCards(sgs.Max), 0) ~= math.max(player:getHandcardNum() - math.max(player:getPile("chuang_" .. name):length() + sgs.Sanguosha:correctMaxCards(player, false, sgs.Max), 0), 0) then   --需要影响到弃牌数才行
					return self:objectName()
				end
			end
			return ""
		end,
		on_cost = function(self, event, room, player, data)
			if player:hasShownSkill(self:objectName()) or room:askForSkillInvoke(player, self:objectName(), sgs.QVariant("keep:::" .. player:getPile("chuang_" .. name):length())) then
				if player:ownSkill("BuquRenew_" .. name) and not player:hasShownSkill("BuquRenew_" .. name) then
					player:showGeneral(player:inHeadSkills("BuquRenew_" .. name))
				end
				return true
			end
		end,
		on_effect = function(self, event, room, player, data)
			room:notifySkillInvoked(player, self:objectName())
		end,
	}
	return sgs.CreateTriggerSkill(buqu_show_maxcards_skill)
end
BuquRenewShowMaxCards_ZhouTai_13 = sgs.CreateBuquRenewShowMaxCardsSkill("ZhouTai_13")
ZhouTai_13:addSkill(BuquRenew_ZhouTai_13)
ZhouTai_13:addSkill(BuquRenewMaxCards_ZhouTai_13)
ZhouTai_13:addSkill(BuquRenewShowMaxCards_ZhouTai_13)
sgs.insertRelatedSkills(extensionRenew, "BuquRenew_ZhouTai_13", "#BuquRenew-maxcards_ZhouTai_13", "#BuquRenew-showmaxcards_ZhouTai_13")

--[[
	技能名：奋激
	技能：Fenji
	描述：当一名角色因另一名角色的弃置或获得而失去手牌后，你可以失去1点体力，令该失去手牌的角色摸两张牌。
	状态：复制吧友
]]--
Fenji = sgs.CreateTriggerSkill{
	name = "Fenji",
	events = {sgs.CardsMoveOneTime},
	can_trigger = function(self, event, room, player, data)
		if not player or player:isDead() or not player:hasSkill(self:objectName()) then return "" end
		local move = data:toMoveOneTime()
		if not move.from then return false end
		if player:getHp() > 0 and move.from:isAlive() and move.from_places:contains(sgs.Player_PlaceHand) 
			and ((move.reason.m_reason == sgs.CardMoveReason_S_REASON_DISMANTLE
			and move.reason.m_playerId ~= move.reason.m_targetId)
			or (move.to and move.to:objectName() ~= move.from:objectName() and move.to_place == sgs.Player_PlaceHand
			and move.reason.m_reason ~= sgs.CardMoveReason_S_REASON_GIVE and move.reason.m_reason ~= sgs.CardMoveReason_S_REASON_SWAP)) then
			return self:objectName()
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		local move = data:toMoveOneTime()
		player:setTag("FenjiMove", data)  --For AI
		local dat = sgs.QVariant()
		for _,p in sgs.qlist(room:getAllPlayers()) do
			if p:objectName() == move.from:objectName() then dat:setValue(p) break end
		end
		if room:askForSkillInvoke(player, self:objectName(), dat) then
			player:removeTag("FenjiMove")
			room:broadcastSkillInvoke(self:objectName(), player)
			room:loseHp(player)
			return true
		end
		player:removeTag("FenjiMove")
		return false
	end,
	on_effect = function(self, event, room, player, data)
		local move = data:toMoveOneTime()
		if move.from:isAlive() then
			for _,from in sgs.qlist(room:getAlivePlayers()) do
				if from:objectName() == move.from:objectName() then
					room:drawCards(from, 2, self:objectName())
				end
			end
		end
	end,
	on_turn_broken = function(self, function_name, event, room, player, data, ask_who)
		player:removeTag("FenjiMove")
	end
}
ZhouTai_13:addSkill(Fenji)

----------------------------------------------------------------------------------------------------

--[[ QUN 019 华雄
	武将：HuaXiong
	武将名：华雄
	体力上限：4
	武将技能：
		耀武：锁定技，当你首次明置此武将牌后，你加2点体力上限，然后回复2点体力；当你受到红色【杀】造成的伤害后，你令来源选择一项：1．回复1点体力；2．摸一张牌；3. 令你减1点体力上限。
	状态：验证通过
]]--
HuaXiong = sgs.General(extensionRenew, "HuaXiong", "qun", 4, true)

--[[
	技能名：耀武
	技能：Yaowu
	描述：锁定技，当你首次明置此武将牌后，你加2点体力上限，然后回复2点体力；当你受到红色【杀】造成的伤害后，你令来源选择一项：1．回复1点体力；2．摸一张牌；3. 令你减1点体力上限。
	状态：验证通过
]]--
Yaowu = sgs.CreateTriggerSkill{
	name = "Yaowu",
	can_preshow = true,
	frequency = sgs.Skill_Compulsory,
	events = {sgs.GeneralShown, sgs.DFDebut, sgs.Damaged},
	can_trigger = function(self, event, room, player, data)
		if not (player and player:isAlive() and player:hasSkill(self:objectName())) then return "" end
		if (event == sgs.GeneralShown) and (player:getMark(self:objectName()) == 0) then
			return (data:toBool() == player:inHeadSkills(self:objectName())) and self:objectName() or ""
		elseif (event == sgs.DFDebut) and (player:getMark(self:objectName()) == 0) then
			return self:objectName()
		elseif event == sgs.Damaged then
			local damage = data:toDamage()
			return (damage.card and damage.card:isKindOf("Slash") and damage.card:isRed() and damage.from and damage.from:isAlive()) and self:objectName() or ""
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		if (event == sgs.DFDebut) or (event == sgs.GeneralShown) then
			room:setPlayerMark(player, self:objectName(), 1)
			return true
		end
		local dat = sgs.QVariant()
		dat:setValue(data:toDamage().from)
		if player:hasShownSkill(self:objectName()) or player:askForSkillInvoke(self:objectName(), dat) then
			room:broadcastSkillInvoke(self:objectName(), player)
			return true
		end
		return false
	end,
	on_effect = function(self, event, room, player, data)
		room:sendCompulsoryTriggerLog(player, self:objectName(), true)
		if event == sgs.Damaged then
			local damage = data:toDamage()
			local choices = {}
			if damage.from:isWounded() then
				table.insert(choices, "recover")
			end
			table.insert(choices, "draw")
			if player:isAlive() then
				table.insert(choices, "maxhp")
			end
			local choice = room:askForChoice(damage.from, self:objectName(), table.concat(choices, "+"), data)
			if choice == "recover" then
				local recover = sgs.RecoverStruct()
				recover.who = player
				room:recover(damage.from, recover)
			elseif choice == "draw" then
				damage.from:drawCards(1, self:objectName())
			elseif choice == "maxhp" then
				room:loseMaxHp(player)
			end
		else
			room:setPlayerProperty(player, "maxhp", sgs.QVariant(player:getMaxHp() + 2))
			local recover = sgs.RecoverStruct()
			recover.recover, recover.who = 2, player
			room:recover(player, recover)
		end
		return false
	end,
}
HuaXiong:addSkill(Yaowu)

----------------------------------------------------------------------------------------------------

--[[ QUN 021 袁术
	武将：YuanShu_Renew
	武将名：袁术-新标
	体力上限：4
	武将技能：
		妄尊：一名大势力角色的准备阶段开始时，你可以摸一张牌，然后本回合其手牌上限-1，且你于下回合开始之前不能发动“妄尊”。
		同疾：锁定技，当攻击范围内含有你的角色使用【杀】指定目标时，若你的手牌数大于你的体力值，你取消除你外的目标。
	状态：验证通过
]]--
YuanShu_Renew = sgs.General(extensionRenew, "YuanShu_Renew", "qun", 4, true)
YuanShu_Renew:addCompanion("yuanshao")
YuanShu_Renew:addCompanion("jiling")

--[[
	技能名：妄尊
	技能：Wangzun
	描述：一名大势力角色的准备阶段开始时，你可以摸一张牌，然后本回合其手牌上限-1，且你于下回合开始之前不能发动“妄尊”。
	状态：验证通过
]]--
function sgs.CreateWangzunSkill(name)
	local wangzun_skill = {
		name = "Wangzun_" .. name,  
		can_preshow = true,
		frequency = sgs.Skill_NotFrequent,
		events = {sgs.EventPhaseStart},
		can_trigger = function(self, event, room, player, data)
			if player:getPhase() == sgs.Player_Start then
				if not player:hasShownOneGeneral() then return "" end
				local skill_list, player_list = {}, {}
				for _, yuanshu in sgs.qlist(room:findPlayersBySkillName(self:objectName())) do
					if yuanshu:getMark("WangzunInvoked_" .. name) == 0 then
						if isBigKingdom(player, yuanshu, self:objectName()) then
							table.insert(skill_list, self:objectName())
							table.insert(player_list, yuanshu:objectName())
						end
					end
				end
				return table.concat(skill_list, "|"), table.concat(player_list, "|")
			end
			return ""
		end,
		on_cost = function(self, event, room, player, data, ask_who)
			if ask_who:askForSkillInvoke(self:objectName(), data) then
				room:broadcastSkillInvoke(self:objectName(), ask_who)
				return true
			end
			return false
		end,
		on_effect = function(self, event, room, player, data, ask_who)  --PhaseChangeSkill没有ask_who
			ask_who:drawCards(1)
			room:addPlayerMark(player, "WangzunDecMaxCards")
			room:setPlayerMark(ask_who, "WangzunInvoked_" .. name, 1)
			room:addPlayerMark(ask_who, "@Wangzun")  --for UI only
			return false
		end,
	}
	return sgs.CreateTriggerSkill(wangzun_skill)
end
Wangzun_YuanShu_Renew = sgs.CreateWangzunSkill("YuanShu_Renew")
function sgs.CreateWangzunClearSkill(name)
	local wangzun_clear_skill = {
		name = "#Wangzun-clear_" .. name,
		events = {sgs.EventPhaseStart},
		priority = 8,
		global = true,
		on_record = function(self, event, room, player, data)
			if (player:getPhase() == sgs.Player_RoundStart) and (player:getMark("WangzunInvoked_" .. name) > 0) then
				room:setPlayerMark(player, "WangzunInvoked_" .. name, 0)
				room:setPlayerMark(player, "@Wangzun", 0)
			elseif player:getPhase() == sgs.Player_NotActive then
				room:setPlayerMark(player, "WangzunDecMaxCards", 0)
			end
		end,
		can_trigger = function(self, event, room, player, data)
			return ""
		end,
	}
	return sgs.CreateTriggerSkill(wangzun_clear_skill)
end
WangzunClear_Yuanshu_Renew = sgs.CreateWangzunClearSkill("YuanShu_Renew")
WangzunMaxCards = sgs.CreateMaxCardsSkill{
	name = "#Wangzun-maxcards",
	extra_func = function(self, target)
		if target:getMark("WangzunDecMaxCards") > 0 then
			return - target:getMark("WangzunDecMaxCards")
		else
			return 0
		end
	end
}
YuanShu_Renew:addSkill(Wangzun_YuanShu_Renew)
YuanShu_Renew:addSkill(WangzunClear_Yuanshu_Renew)
YuanShu_Renew:addSkill(WangzunMaxCards)
sgs.insertRelatedSkills(extensionRenew, "Wangzun_YuanShu_Renew", "#Wangzun-clear_YuanShu_Renew", "#Wangzun-maxcards")

--[[
	技能名：同疾
	技能：Tongji
	描述：锁定技，当攻击范围内含有你的角色使用【杀】指定目标时，若你的手牌数大于你的体力值，你取消除你外的目标。
	状态：验证通过
]]--
Tongji = sgs.CreateTriggerSkill{
	name = "Tongji",
	can_preshow = true,
	frequency = sgs.Skill_Compulsory,
	events = {sgs.TargetChoosing},
	can_trigger = function(self, event, room, player, data)
		local use = data:toCardUse()
		if not use.card or not use.from or use.from:isDead() then return false end
		if not use.card:isKindOf("Slash") then return false end	
		local skill_list, player_list = {}, {}
		for _, yuanshu in sgs.qlist(room:findPlayersBySkillName(self:objectName())) do
			if (yuanshu:getHandcardNum() > yuanshu:getHp()) and use.from:inMyAttackRange(yuanshu) and (use.from:objectName() ~= yuanshu:objectName()) then
				local need_cancel = false
				for _,p in sgs.qlist(use.to) do
					if p:objectName() ~= yuanshu:objectName() then need_cancel = true end
				end
				if need_cancel then
					table.insert(skill_list, self:objectName())
					table.insert(player_list, yuanshu:objectName())
				end
			end
		end
		return table.concat(skill_list, "|"), table.concat(player_list, "|")
	end	,
	on_cost = function(self, event, room, player, data, ask_who)
		if ask_who:hasShownSkill(self:objectName()) or room:askForSkillInvoke(ask_who, self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), ask_who)
			return true
		end
		return false
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		room:sendCompulsoryTriggerLog(ask_who, self:objectName(), true)
		local use = data:toCardUse()
		local done = false
		while not done do
			done = true
			for _,p in sgs.qlist(use.to) do
				if p:objectName() ~= ask_who:objectName() then
					sgs.Room_cancelTarget(use, p)
					done = false
					break
				end
			end
		end
		data:setValue(use)
		if use.to:isEmpty() then
			return true
		end
		return false
	end,
}
YuanShu_Renew:addSkill(Tongji)

----------------------------------------------------------------------------------------------------

--[[ WEI 011 曹仁（15）
	武将：CaoRen_15
	武将名：曹仁-15新
	体力上限：4
	武将技能：
		据守：结束阶段开始时，你可以摸一张牌，然后叠置；当你以此法叠置或于回合开始前叠置后，你可以摸一张牌，然后你可以使用一张锦囊牌或装备牌，若如此做，你可以弃置场上一张与之类别相同的牌。
	状态：验证通过
]]--
CaoRen_15 = sgs.General(extensionRenew, "CaoRen_15", "wei", 4, true, true)
CaoRen_15:addCompanion("caohong")

--[[
	技能名：据守
	技能：Jushou15
	描述：结束阶段开始时，你可以摸一张牌，然后叠置；当你以此法叠置或于回合开始前叠置后，你可以摸一张牌，然后你可以使用一张锦囊牌或装备牌，若如此做，你可以弃置场上一张与之类别相同的牌。
	状态：验证通过
]]--
Jushou15Record = sgs.CreateTriggerSkill{		--[[todo：新版本删除/合并类似技能：
							需要删除的技能包括：Jushou15Record、TishenRecord、ZhuhaiRecord、KejiRecord、YicongRecord、QinyinRecord、JiushiRecord、JingceRecord、FengpoRecord、ZhidaoRecord
							因为太麻烦还没改的：Luoying、Zongxuan
							（QianxunRecord不算，因为priority不同）]]
	name = "#Jushou15-record",
	can_preshow = true,
	events = {sgs.TurnStart, sgs.EventPhaseChanging},
	global = true,
	on_record = function(self, event, room, player, data)
		if event == sgs.TurnStart then
			player:setFlags("-JushouTurnStartTurningOver")
			if not player:faceUp() then
				player:setFlags("JushouTurnStartTurningOver")
			end
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
Jushou15 = sgs.CreateTriggerSkill{
	name = "Jushou15",
	can_preshow = true,
	frequency = sgs.Skill_Frequent,
	events = {sgs.EventPhaseStart, sgs.TurnedOver},
	can_trigger = function(self, event, room, player, data)
		if not player or player:isDead() or not player:hasSkill(self:objectName()) then return "" end
		if event == sgs.EventPhaseStart then
			if player:getPhase() == sgs.Player_Finish then return self:objectName() end
		elseif event == sgs.TurnedOver then
			if player:hasFlag("JushouTurnOver") then return self:objectName() end
			if player:hasFlag("JushouTurnStartTurningOver") then
				return self:objectName()
			end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		if player:askForSkillInvoke(self:objectName(), (event == sgs.EventPhaseStart) and data or sgs.QVariant("draw")) then
			room:broadcastSkillInvoke(self:objectName(), (event == sgs.EventPhaseStart) and 1 or 2, player)
			return true 
		end
		return false 
	end,
	on_effect = function(self, event, room, player, data)
		if event == sgs.EventPhaseStart then
			player:drawCards(1, self:objectName())
			player:setFlags("JushouTurnOver")
			player:turnOver()
			player:setFlags("-JushouTurnOver")
		elseif event == sgs.TurnedOver then
			doJiewei(self, room, player)
		end
		return false
	end,
}
Jushou15Clear = sgs.CreateTriggerSkill{
	name = "#Jushou15-clear",
	events = {sgs.TurnStart},
	priority = -1,
	global = true,
	on_record = function(self, event, room, player, data)
		player:setFlags("-JushouTurnStartTurningOver")
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
CaoRen_15:addSkill(Jushou15)
CaoRen_15:addSkill(Jushou15Record)
CaoRen_15:addSkill(Jushou15Clear)
sgs.insertRelatedSkills(extensionRenew, "Jushou15", "#Jushou15-record", "#Jushou15-clear")

----------------------------------------------------------------------------------------------------

--[[ WU 013 周泰（15）
	武将：ZhouTai_15
	武将名：周泰-15新
	体力上限：4
	武将技能：
		不屈：锁定技，当你处于濒死状态时，你将牌堆顶的一张牌置于武将牌上，称为“创”，然后若此“创”与其他“创”点数均不同，你将体力回复至1点，否则你移去此“创”（你的回合内每回合限一次）；若有“创”，你的手牌上限等于“创”的数量。 
		奋激：当一名角色因另一名角色的弃置或获得而失去手牌后，你可以弃置一张牌，失去1点体力，然后令该失去手牌的角色摸两张牌。
	状态：验证通过
]]--
ZhouTai_15 = sgs.General(extensionRenew, "ZhouTai_15", "wu", 4, true, true)
ZhouTai_15:addCompanion("sunquan")
ZhouTai_15:addCompanion("jiangqin")

--[[
	技能名：不屈
	技能：BuquRenew_ZhouTai_15
	描述：锁定技，当你处于濒死状态时，你将牌堆顶的一张牌置于武将牌上，称为“创”，然后若此“创”与其他“创”点数均不同，你将体力回复至1点，否则你移去此“创”（你的回合内每回合限一次）；若有“创”，你的手牌上限等于“创”的数量。
	状态：复制吧友
]]--
BuquRenew_ZhouTai_15 = sgs.CreateBuquRenewSkill("ZhouTai_15")
BuquRenewMaxCards_ZhouTai_15 = sgs.CreateBuquRenewMaxCardsSkill("ZhouTai_15")
BuquRenewShowMaxCards_ZhouTai_15 = sgs.CreateBuquRenewShowMaxCardsSkill("ZhouTai_15")
ZhouTai_15:addSkill(BuquRenew_ZhouTai_15)
ZhouTai_15:addSkill(BuquRenewMaxCards_ZhouTai_15)
ZhouTai_15:addSkill(BuquRenewShowMaxCards_ZhouTai_15)
sgs.insertRelatedSkills(extensionRenew, "BuquRenew_ZhouTai_15", "#BuquRenew-maxcards_ZhouTai_15", "#BuquRenew-showmaxcards_ZhouTai_15")

--[[
	技能名：奋激
	技能：Fenji15
	描述：当一名角色因另一名角色的弃置或获得而失去手牌后，你可以弃置一张牌，失去1点体力，然后令该失去手牌的角色摸两张牌。
	状态：验证通过
]]--
Fenji15 = sgs.CreateTriggerSkill{
	name = "Fenji15",
	events = {sgs.CardsMoveOneTime},
	can_trigger = function(self, event, room, player, data)
		if not player or player:isDead() or not player:hasSkill(self:objectName()) then return "" end
		if event ~= sgs.CardsMoveOneTime then return "" end
		local move = data:toMoveOneTime()
		if not move.from then return false end
		if move.from:isAlive() and move.from_places:contains(sgs.Player_PlaceHand) 
			and ((move.reason.m_reason == sgs.CardMoveReason_S_REASON_DISMANTLE
			and move.reason.m_playerId ~= move.reason.m_targetId)
			or (move.to and move.to:objectName() ~= move.from:objectName() and move.to_place == sgs.Player_PlaceHand
			and move.reason.m_reason ~= sgs.CardMoveReason_S_REASON_GIVE and move.reason.m_reason ~= sgs.CardMoveReason_S_REASON_SWAP)) then
			return player:canDiscard(player, "he") and self:objectName() or ""
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		local move = data:toMoveOneTime()
		player:setTag("FenjiMove", data)  --For AI（与13奋激AI兼容）
		if player and player:canDiscard(player, "he") and room:askForCard(player, "..", "@Fenji15:" .. move.from:objectName(), data, self:objectName()) then
			player:removeTag("FenjiMove")
			room:broadcastSkillInvoke(self:objectName(), player)
			return true
		end
		player:removeTag("FenjiMove")
		return false
	end,
	on_effect = function(self, event, room, player, data)
		room:loseHp(player)
		local move = data:toMoveOneTime()
		if move.from:isAlive() then
			for _,from in sgs.qlist(room:getAlivePlayers()) do
				if from:objectName() == move.from:objectName() then
					room:drawCards(from, 2, self:objectName())
				end
			end
		end
	end,
	on_turn_broken = function(self, function_name, event, room, player, data, ask_who)
		player:removeTag("FenjiMove")
	end
}
ZhouTai_15:addSkill(Fenji15)

----------------------------------------------界限突破----------------------------------------------

extensionLB = sgs.Package("LimitBreaking", sgs.Package_GeneralPack)

--[[ WEI 001 曹操
	武将：CaoCao_LB
	武将名：曹操-界
	体力上限：4
	武将技能：
		奸雄：当你受到伤害后，你可以选择一项：1. 摸一张牌；2. 获得造成此伤害的牌。
	状态：复制手册
]]--
CaoCao_LB = sgs.General(extensionLB, "CaoCao_LB", "wei", 4, true, true)
CaoCao_LB:addCompanion("dianwei")
CaoCao_LB:addCompanion("xuchu")

--[[
	技能名：奸雄
	技能：JianxiongLB
	描述：当你受到伤害后，你可以选择一项：1. 摸一张牌；2. 获得造成此伤害的牌。
	状态：复制手册
]]--
JianxiongLB = sgs.CreateTriggerSkill{
	name = "JianxiongLB",
	can_preshow = true,
	frequency = sgs.Skill_Frequent,
	events = sgs.Damaged,
	
	can_trigger = function(self, event, room, player, data)
		if not (player and player:isAlive() and player:hasSkill(self:objectName())) then return "" end
		return self:objectName()
	end,
	
	on_cost = function(self, event, room, player, data)
		if room:askForSkillInvoke(player, self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), player)
			return true
		end
		return false
	end,
	
	on_effect = function(self, event, room, player, data)
		local damage = data:toDamage()
		local choices = {"draw"}

		local card = damage.card
		if card then
			local ids = sgs.IntList()
			if card:isVirtualCard() then
				ids = card:getSubcards()
			else
				ids:append(card:getEffectiveId())
			end
			if ids:length() > 0 then
				local all_place_table = true
				for _,id in sgs.qlist(ids) do
					if room:getCardPlace(id) ~= sgs.Player_PlaceTable then
						all_place_table = false
						break
					end
				end
				if all_place_table then table.insert(choices, "obtain") end
			end
		end

		local choice = room:askForChoice(player, self:objectName(), table.concat(choices, "+"), data)
		if choice == "obtain" and card then
			player:obtainCard(card)
		else
			player:drawCards(1, self:objectName())
		end
		return false 
	end,
}
CaoCao_LB:addSkill(JianxiongLB)

----------------------------------------------------------------------------------------------------

--[[ WEI 002 司马懿
	武将：SiMaYi_LB
	武将名：司马懿-界
	体力上限：3
	武将技能：
		反馈：当你受到1点伤害后，你可以获得伤害来源的一张牌。
		鬼才：当一名角色的判定牌生效前，你可以打出一张牌代替之。
	状态：
]]--
SiMaYi_LB = sgs.General(extensionLB, "SiMaYi_LB", "wei", 3, true, true)

--[[
	技能名：反馈
	技能：FankuiLB
	描述：当你受到1点伤害后，你可以获得伤害来源的一张牌。
	状态：复制手册
]]--
FankuiLB = sgs.CreateTriggerSkill{
	name = "FankuiLB",
	can_preshow = true,
	frequency = sgs.Skill_Frequent,
	events = sgs.Damaged,
	
	can_trigger = function(self, event, room, player, data)
		local trigger_list = {}
		if player and player:isAlive() and player:hasSkill(self:objectName()) then	
			local damage = data:toDamage()
			if damage.from and damage.from:isAlive() then
				local flags = (damage.from:objectName() == player:objectName()) and "e" or "he"
				if not damage.from:getCards(flags):isEmpty() then
					for i = 1, damage.damage do
						table.insert(trigger_list, self:objectName())
					end
				end
			end
		end
		return table.concat(trigger_list, ",")
	end,

	on_cost = function(self, event, room, player, data)
		if player:askForSkillInvoke(self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), player)
			return true 
		end
		return false 
	end,
	
	on_effect = function(self, event, room, player, data)
		local damage = data:toDamage()
		local flags = (damage.from:objectName() == player:objectName()) and "e" or "he"
		if damage.from:getCards(flags):isEmpty() then return false end
		local card_id = room:askForCardChosen(player, data:toDamage().from, flags, self:objectName())
		local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_EXTRACTION, player:objectName())
		room:obtainCard(player, sgs.Sanguosha:getCard(card_id), reason, false)
		return false 
	end,
}
SiMaYi_LB:addSkill(FankuiLB)

--[[
	技能名：鬼才
	技能：GuicaiLB
	描述：当一名角色的判定牌生效前，你可以打出一张牌代替之。
	状态：复制手册
]]--
GuicaiLB = sgs.CreateTriggerSkill{
	name = "GuicaiLB",
	can_preshow = true,
	events = sgs.AskForRetrial,
	
	can_trigger = function(self, event, room, player, data)
		if not (player and player:isAlive() and player:hasSkill(self:objectName())) or (player:isNude() and player:getHandPile():isEmpty()) then return "" end
		return self:objectName()
	end,
	
	on_cost = function(self, event, room, player, data)
		local judge = data:toJudge()
		local prompt_list = {"@"..self:objectName().."-card" , judge.who:objectName(), self:objectName(), judge.reason, string.format("%d", judge.card:getEffectiveId())}
		local prompt = table.concat(prompt_list, ":")
		local card = room:askForCard(player, "..", prompt, data, sgs.Card_MethodResponse, judge.who, true)
		if card then
			room:broadcastSkillInvoke(self:objectName(), player)
			room:retrial(card, player, judge, self:objectName())
			return true
		end
		return false 
	end,
	
	on_effect = function(self, event, room, player, data)
		data:toJudge():updateResult()
		return false
	end,
}
SiMaYi_LB:addSkill(GuicaiLB)

----------------------------------------------------------------------------------------------------

--[[ WEI 003 夏侯惇
	武将：XiaHouDun_LB
	武将名：夏侯惇-界
	体力上限：4
	武将技能：
		刚烈：当你受到1点伤害后，你可以进行判定，若结果为：红色，你对伤害来源造成1点伤害；黑色，你弃置伤害来源的一张牌。
		清俭：当你于摸牌阶段外获得牌后，你可以将其中至少一张牌交给其他角色。
	状态：验证通过
]]--
XiaHouDun_LB = sgs.General(extensionLB, "XiaHouDun_LB", "wei", 4, true, true)
XiaHouDun_LB:addCompanion("xiahouyuan")

--[[
	技能名：刚烈
	技能：GanglieLB
	描述：当你受到1点伤害后，你可以进行判定，若结果为：红色，你对伤害来源造成1点伤害；黑色，你弃置伤害来源的一张牌。
	状态：复制原项目并调整
]]--
function sgs.CreateGanglieLBSkill(name)
	local ganglielb_skill = {
		name = "GanglieLB_" .. name,
		can_preshow = true,
		events = {sgs.Damaged, sgs.FinishJudge},
		on_record = function(self, event, room, player, data)
			if event == sgs.FinishJudge then
				local judge = data:toJudge()
				if judge.reason ~= self:objectName() then return false end
				judge.pattern = tostring(judge.card:getSuit())
			end
		end,
		can_trigger = function(self, event, room, player, data)
			if not player or player:isDead() or not player:hasSkill(self:objectName()) then	return false end
			if event == sgs.Damaged then
				local damage = data:toDamage()
				local trigger_list = {}
				for i = 1, damage.damage, 1 do
					table.insert(trigger_list, self:objectName())
				end
				return table.concat(trigger_list,",")
			end
		end,
		on_cost = function(self, event, room, player, data)
			if room:askForSkillInvoke(player, self:objectName(), data) then
				local damage = data:toDamage()
				if damage and damage.from then
					room:doAnimate(1, player:objectName(), damage.from:objectName())
				end
				room:broadcastSkillInvoke(self:objectName(), player)
				return true
			end
		end,
		on_effect = function(self, event, room, player, data)
			local damage = data:toDamage()
			local judge = sgs.JudgeStruct()
			judge.pattern = "."
			judge.who = player
			judge.reason = self:objectName()
			room:judge(judge)
			if not damage.from or damage.from:isDead() then return false end
			local suit = tonumber(judge.pattern)
			if (suit == sgs.Card_Heart) or (suit == sgs.Card_Diamond) then
				room:damage(sgs.DamageStruct(self:objectName(), player, damage.from))
			elseif (suit == sgs.Card_Spade) or (suit == sgs.Card_Club) then
				if player:canDiscard(damage.from, "he") then
					local id = room:askForCardChosen(player, damage.from, "he", self:objectName(), false, sgs.Card_MethodDiscard)
					local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_DISMANTLE, player:objectName(), damage.from:objectName(), self:objectName(), nil)
					room:throwCard(sgs.Sanguosha:getCard(id), reason, damage.from, player)
				end
			end
		end
	}
	return sgs.CreateTriggerSkill(ganglielb_skill)
end
GanglieLB_XiaHouDun_LB = sgs.CreateGanglieLBSkill("XiaHouDun_LB")
XiaHouDun_LB:addSkill(GanglieLB_XiaHouDun_LB)

--[[
	技能名：清俭
	技能：Qingjian
	描述：当你于摸牌阶段外获得牌后，你可以将其中至少一张牌交给其他角色。
	状态：验证通过
	注：由于伤逝清俭无限循环的问题，暂时规定因伤逝而摸的牌不能触发清俭
]]--
QingjianCard = sgs.CreateSkillCard{
	name = "QingjianCard",
	skill_name = "Qingjian",
	target_fixed = false,
	will_throw = false,
	mute = true,
	handling_method = sgs.Card_MethodNone,
	filter = function(self, targets, to_select, player)
		return #targets == 0 and to_select:objectName() ~= player:objectName()
	end,
	feasible = function(self, targets, player)
		return #targets == 1
	end,
	about_to_use = function(self, room, cardUse)
		local source, target = cardUse.from, cardUse.to:at(0)
		local data = sgs.QVariant()
		data:setValue(target)
		source:setTag(self:getSkillName().."_target", data)
	end,
}
QingjianVS = sgs.CreateViewAsSkill{   
	name = "Qingjian",
	view_filter = function(self, selected, to_select)
		return table.contains(sgs.Self:property(self:objectName().."_hands"):toString():split("+"), tostring(to_select:getId()))
	end, 
	view_as = function(self, originalCards) 
		if #originalCards > 0 then
			local skillcard = QingjianCard:clone()
			for _, card in ipairs(originalCards) do
				skillcard:addSubcard(card)
			end
			skillcard:setSkillName(self:objectName())
			return skillcard
		end
	end, 
	enabled_at_play = function(self, player)
		return false
	end,
	enabled_at_response = function(self, player, pattern)
		return string.startsWith(pattern, "@@"..self:objectName())
	end,
}
Qingjian = sgs.CreateTriggerSkill{
	name = "Qingjian",
	can_preshow = true,
	frequency = sgs.Skill_NotFrequent,
	events = {sgs.CardsMoveOneTime},
	view_as_skill = QingjianVS,
	can_trigger = function(self, event, room, player, data)
		if not (player and player:isAlive() and player:hasSkill(self:objectName())) then return "" end
		if room:getTag("FirstRound"):toBool() or player:getPhase() == sgs.Player_Draw then return "" end
		local move = data:toMoveOneTime()
		if not move.to or move.to:objectName() ~= player:objectName() or move.to_place ~= sgs.Player_PlaceHand then return "" end
		if move.reason.m_skillName == "Shangshi" then return "" end  --临时解决伤逝清俭无限循环（因此对伤逝的摸牌代码也进行了调整）
		for _,id in sgs.qlist(move.card_ids) do
			if room:getCardOwner(id):objectName() == player:objectName() and room:getCardPlace(id) == sgs.Player_PlaceHand then
				return self:objectName()
			end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		player:setTag("QingjianCurrentMoveSkill", sgs.QVariant(data:toMoveOneTime().reason.m_skillName))  --但是实际上并无卵用，drawCards没有m_skillName
		if player:askForSkillInvoke(self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), player)
			return true 
		end
		return false 
	end,
	on_effect = function(self, event, room, player, data)
		local move = data:toMoveOneTime()
		local ids, all_visible = {}, true
		local visible_places = {sgs.Player_PlaceEquip, sgs.Player_PlaceDelayedTrick, sgs.Player_DiscardPile, sgs.Player_PlaceTable}  --room.cpp #5163
		for i, id in sgs.qlist(move.card_ids) do
			if room:getCardOwner(id):objectName() == player:objectName() and room:getCardPlace(id) == sgs.Player_PlaceHand then
				table.insert(ids, id)
				if not sgs.Sanguosha:getCard(id):hasFlag("visible") and not table.contains(visible_places, move.from_places:at(i)) then
					all_visible = false
				end
			end
		end
		local get = {}
		local sum = #ids
		
		local pattern, prompt = "@@" .. self:objectName() .. "!", "@Qingjian-distribute1:::"
		while next(ids) do
			room:setPlayerProperty(player, self:objectName().."_hands", sgs.QVariant(table.concat(ids, "+")))
			local u_card = room:askForUseCard(player, pattern, prompt .. #ids)
			if not u_card then
				break
			end
			local target = player:getTag(self:objectName().."_target"):toPlayer()

			for _, id in sgs.qlist(u_card:getSubcards()) do
				table.removeOne(ids, id)
				table.insert(get, target:objectName().."|"..id)
			end
			pattern = "@@" .. self:objectName()
			prompt = "@Qingjian-distribute2:::"
		end
		
		if string.endsWith(pattern, "!") and #ids > 0 and not player:isKongcheng() then  --Give the remaining cards randomly
			local id = ids[math.random(1, #ids)]
			local receiver = room:getOtherPlayers(player):at(math.random(0, player:aliveCount() - 2))
			table.insert(get, receiver:objectName() .. "|" .. id) 
			table.removeOne(ids, id)
		end

		local moves = sgs.CardsMoveList()
		local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_GIVE, player:objectName(), self:objectName(), "")
		for _, p in sgs.qlist(room:getAllPlayers()) do
			local _ids = sgs.IntList()
			for _, toget in ipairs(get) do
				if toget:split("|")[1] == p:objectName() then _ids:append(tonumber(toget:split("|")[2])) end
			end
			if not _ids:isEmpty() then
				local move = sgs.CardsMoveStruct(_ids, player, p, sgs.Player_PlaceHand, sgs.Player_PlaceHand, reason)
				moves:append(move)
			end
		end
		if not moves:isEmpty() then
			local visible = all_visible and moves:length() == 1 and moves:first().card_ids:length() == sum
			room:moveCardsAtomic(moves, visible)
		end
		
		return false
	end
}
XiaHouDun_LB:addSkill(Qingjian)

----------------------------------------------------------------------------------------------------

--[[ WEI 004 张辽
	武将：ZhangLiao_LB
	武将名：张辽-界
	体力上限：4
	武将技能：
		突袭：摸牌阶段，你可以少摸至少一张牌并选择等量的有手牌且手牌不少于你的其他角色，获得这些角色的各一张手牌。
	状态：验证通过
]]--
ZhangLiao_LB = sgs.General(extensionLB, "ZhangLiao_LB", "wei", 4, true, true)
ZhangLiao_LB:addCompanion("zangba")

--[[
	技能名：突袭
	技能：TuxiLB
	描述：摸牌阶段，你可以少摸至少一张牌并选择等量的有手牌且手牌不少于你的其他角色，获得这些角色的各一张手牌。
	状态：验证通过
]]--
TuxiLB = sgs.CreateDrawCardsSkill{
	name = "TuxiLB",
	can_preshow = true,
	can_trigger = function(self, event, room, player, data)
		if not player or player:isDead() or not player:hasSkill(self:objectName()) then return "" end
		if data:toInt() <= 0 then return "" end
		for _,p in sgs.qlist(room:getOtherPlayers(player)) do
			if not p:isKongcheng() and (p:getHandcardNum() >= player:getHandcardNum()) then
				return self:objectName()
			end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		local targets = sgs.SPlayerList()
		for _,p in sgs.qlist(room:getOtherPlayers(player)) do
			if not p:isKongcheng() and (p:getHandcardNum() >= player:getHandcardNum()) then
				targets:append(p)
			end
		end
		local num = math.min(targets:length(), data:toInt())
		if num > 0 then
			local choosees = room:askForPlayersChosen(player, targets, self:objectName(), 0, num, "@TuxiLB-card:::" .. num, true)
			if not choosees:isEmpty() then
				room:sortByActionOrder(choosees)
				local choices_qvar = sgs.VariantList()
				for _,p in sgs.qlist(choosees) do
					dat = sgs.QVariant()
					dat:setValue(p)
					choices_qvar:append(dat)
				end
				player:setTag("TuxiLB_invoke", sgs.QVariant(choices_qvar))
				room:broadcastSkillInvoke(self:objectName(), player)
				return true
			end
		end
		return false
	end,
	draw_num_func = function(self, player, n)
        player:setFlags("TuxiLBInvoked")
		local tuxi_num = player:getTag("TuxiLB_invoke"):toList():length()
        return n - tuxi_num
	end,
	on_turn_broken = function(self, function_name, event, room, player, data, ask_who)
		player:removeTag("TuxiLB_invoke")
	end
}
TuxiLBAct = sgs.CreateTriggerSkill{
	name = "#TuxiLB-act",
	events = {sgs.AfterDrawNCards},
	frequency = sgs.Skill_Compulsory,
	can_trigger = function(self, event, room, player, data)
		if player:isAlive() and player:hasFlag("TuxiLBInvoked") then
			return self:objectName()
		end
	end,
	on_cost = function(self, event, room, player, data)
		return true
	end,
	on_effect = function(self, event, room, player, data)
		local targets_qvar = player:getTag("TuxiLB_invoke"):toList()
		player:removeTag("TuxiLB_invoke")
		local target
		for _,target_qvar in sgs.qlist(targets_qvar) do
			target = target_qvar:toPlayer()
			if target and not target:isKongcheng() then
				local id = room:askForCardChosen(player, target, "h", "TuxiLB", false)
				room:obtainCard(player, sgs.Sanguosha:getCard(id), sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_EXTRACTION, player:objectName(), target:objectName(), "TuxiLB", ""), false)
			end
		end
	end,
	on_turn_broken = function(self, function_name, event, room, player, data, ask_who)
		player:removeTag("TuxiLB_invoke")
	end
}
TuxiLBClear = sgs.CreateTriggerSkill{
	name = "#TuxiLB-clear",
	events = {sgs.AfterDrawNCards},
	priority = -1,
	global = true,
	on_record = function(self, event, room, player, data)
		player:setFlags("-TuxiLBInvoked")
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
ZhangLiao_LB:addSkill(TuxiLB)
ZhangLiao_LB:addSkill(TuxiLBAct)
ZhangLiao_LB:addSkill(TuxiLBClear)
sgs.insertRelatedSkills(extensionLB, "TuxiLB", "#TuxiLB-act", "#TuxiLB-clear")

----------------------------------------------------------------------------------------------------

--[[ WEI 005 许褚
	武将：XuChu_LB
	武将名：许褚-界
	体力上限：4
	武将技能：
		裸衣：你可以跳过摸牌阶段，若如此做，你亮出牌堆顶的三张牌，然后获得其中的基本牌、武器牌与【决斗】，将其余的牌置入弃牌堆，若如此做，直到你的下回合开始时，你为伤害来源的【杀】或【决斗】造成伤害时，你令此伤害+1。
	状态：复制原项目并调整
]]--
XuChu_LB = sgs.General(extensionLB, "XuChu_LB", "wei", 4, true, true)
XuChu_LB:addCompanion("caocao")
XuChu_LB:addCompanion("CaoCao_LB")

--[[
	技能名：裸衣
	技能：LuoyiLB
	描述：你可以跳过摸牌阶段，若如此做，你亮出牌堆顶的三张牌，然后获得其中的基本牌、武器牌与【决斗】，将其余的牌置入弃牌堆，若如此做，直到你的下回合开始时，你为伤害来源的【杀】或【决斗】造成伤害时，你令此伤害+1。
	状态：复制原项目并调整
]]--
LuoyiLB = sgs.CreateTriggerSkill{
	name = "LuoyiLB",
	can_preshow = true,
	events = {sgs.EventPhaseChanging},
	frequency = sgs.Skill_NotFrequent,
	can_trigger = function(self, event, room, player, data)
		if player and player:isAlive() and player:hasSkill(self:objectName()) then
			if data:toPhaseChange().to == sgs.Player_Draw and not player:isSkipped(sgs.Player_Draw) then
				return self:objectName()
			end
		end
	end,
	on_cost = function(self, event, room, player, data)
		if player:askForSkillInvoke(self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), player)
			player:skip(sgs.Player_Draw, true)
			return true
		end
		return false
	end,
	on_effect = function(self, event, room, player, data)
		local ids = room:getNCards(3, false)
		local move = sgs.CardsMoveStruct(ids, player, sgs.Player_PlaceTable, sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_TURNOVER, player:objectName(), self:objectName(), ""))
		room:moveCardsAtomic(move, true)
		room:getThread():delay()
		room:getThread():delay()
		
		local card_to_throw = sgs.IntList()
		local card_to_gotback = sgs.IntList()
		for _, id in sgs.qlist(ids) do
			local card = sgs.Sanguosha:getCard(id)
			if card:getTypeId() == sgs.Card_TypeBasic or card:isKindOf("Duel") or card:isKindOf("Weapon") then
				card_to_gotback:append(id)
			else
				card_to_throw:append(id)
			end			
		end
		if not card_to_gotback:isEmpty() then
			local dummy = sgs.DummyCard(card_to_gotback)
			room:obtainCard(player, dummy)
			dummy:deleteLater()
		end
		if not card_to_throw:isEmpty() then
			local dummy = sgs.DummyCard(card_to_throw)
			room:throwCard(dummy, sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_NATURAL_ENTER, player:objectName(), self:objectName(), ""), nil)
			dummy:deleteLater()
		end
		room:addPlayerMark(player, "@LuoyiLB")
		return false
	end,
}
LuoyiLBDamage = sgs.CreateTriggerSkill{
	name = "#LuoyiLB-damage",
	events = {sgs.DamageCaused},
	frequency = sgs.Skill_Compulsory,
	can_trigger = function(self, event, room, player, data)
		if not player or player:isDead() or (player:getMark("@LuoyiLB") <= 0) then return false end
		local damage = data:toDamage()
		if damage.card and (damage.card:isKindOf("Slash") or damage.card:isKindOf("Duel")) and not damage.chain and not damage.transfer then
			return self:objectName()
		end
	end,
	on_cost = function(self, event, room, player, data)
		return true
	end,
	on_effect = function(self,event,room,player,data)
		local damage = data:toDamage()
		
		local l = sgs.LogMessage()
		l.type = "#LuoyiBuff"
		l.from = damage.from
		l.arg = damage.damage
		l.arg2 = damage.damage + 1
		room:sendLog(l)

		damage.damage = damage.damage + 1
		data:setValue(damage)
		return false
	end,
}
LuoyiLBClear = sgs.CreateTriggerSkill{
	name = "#LuoyiLB-clear",
	events = {sgs.EventPhaseStart},
	priority = 8,
	global = true,
	on_record = function(self, event, room, player, data)
		if player:getPhase() == sgs.Player_RoundStart and player:getMark("@LuoyiLB") > 0 then
			room:setPlayerMark(player, "@LuoyiLB", 0)
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end
}
XuChu_LB:addSkill(LuoyiLB)
XuChu_LB:addSkill(LuoyiLBDamage)
XuChu_LB:addSkill(LuoyiLBClear)
sgs.insertRelatedSkills(extensionLB, "LuoyiLB", "#LuoyiLB-damage", "#LuoyiLB-clear")

----------------------------------------------------------------------------------------------------

--[[ WEI 006 郭嘉
	武将：GuoJia_LB
	武将名：郭嘉-界
	体力上限：3
	武将技能：
		天妒：每当你的判定牌生效后，你可以获得之。
		遗计：当你受到1点伤害后，你可以摸两张牌，然后你可以在至多两名其他角色的武将牌旁分别扣置一至两张手牌，若如此做，这些角色各于下个摸牌阶段开始时获得所有“遗计牌”。
	状态：
]]--
GuoJia_LB = sgs.General(extensionLB, "GuoJia_LB", "wei", 3, true, true)

--[[
	技能名：天妒
	技能：tiandu_GuoJia_LB
	描述：每当你的判定牌生效后，你可以获得之。
	状态：复制手册
]]--
function sgs.CreateTianduSkill(name)
	local tiandu_skill = {
		name = "tiandu_" .. name,
		frequency = sgs.Skill_Frequent,
		events = {sgs.FinishJudge},
		can_trigger = function(self, event, room, player, data)
			if not player or player:isDead() or not player:hasSkill(self:objectName()) then return false end
			local judge = data:toJudge()
			if room:getCardPlace(judge.card:getEffectiveId()) == sgs.Player_PlaceJudge then
				return self:objectName()
			end
		end,
		on_cost = function(self, event, room, player, data)
			if player:askForSkillInvoke(self:objectName(), data) then
				room:broadcastSkillInvoke(self:objectName())
				return true
			end
			return false
		end,
		
		on_effect = function(self, event, room, player, data)
			room:notifySkillInvoked(player, self:objectName())
			local judge = data:toJudge()
			player:obtainCard(judge.card)
		end,
	}
	return sgs.CreateTriggerSkill(tiandu_skill)
end
tiandu_GuoJia_LB = sgs.CreateTianduSkill("GuoJia_LB")
GuoJia_LB:addSkill(tiandu_GuoJia_LB)

--[[
	技能名：遗计
	技能：YijiLB
	描述：当你受到1点伤害后，你可以摸两张牌，然后你可以在至多两名其他角色的武将牌旁分别扣置一至两张手牌，若如此做，这些角色各于下个摸牌阶段开始时获得所有“遗计牌”。
	状态：验证通过
]]--
--[[YijiLBCard = sgs.CreateSkillCard{
	name = "YijiLBCard",
	skill_name = "YijiLB",
	target_fixed = false,
	will_throw = false,
	mute = true,
	handling_method = sgs.Card_MethodNone,
	filter = function(self, targets, to_select, player)
		if (#targets >= 1) or (to_select == player) then return false end
		local distribution = player:property(self:getSkillName() .. "_distribution"):toString():split(",")  --sgs1|4,sgs1|39,sgs2|66...
		local targets_num, cards_num = 0, {}
		local target_name
		for _,tab in pairs(distribution) do
			target_name = tab:split("|")[1]
			if not cards_num[target_name] or (cards_num[target_name] == 0) then
				targets_num = targets_num + 1
				cards_num[target_name] = 1
			else
				cards_num[target_name] = cards_num[target_name] + 1
			end
		end
		if not cards_num[to_select:objectName()] or (cards_num[to_select:objectName()] == 0) then
			return targets_num <= 1
		else
			return cards_num[to_select:objectName()] + self:subcardsLength() <= 2
		end
	end,
	feasible = function(self, targets, player)
		return #targets == 1
	end,
	about_to_use = function(self, room, cardUse)
		local source, target = cardUse.from, cardUse.to:at(0)
		local data = sgs.QVariant()
		data:setValue(target)
		source:setTag(self:getSkillName() .. "_target", data)
	end,
}
YijiLBVS = sgs.CreateViewAsSkill{   
	name = "YijiLB",
	response_pattern = "@@YijiLB", 
	view_filter = function(self, selected, to_select)
		return #selected < 2 and table.contains(sgs.Self:property(self:objectName().."_hands"):toString():split("+"), tostring(to_select:getId()))
	end, 
	view_as = function(self, originalCards) 
		if #originalCards > 0 then
			local skillcard = YijiLBCard:clone()
			for _, card in ipairs(originalCards) do
				skillcard:addSubcard(card)
			end
			skillcard:setSkillName(self:objectName())
			return skillcard
		end
	end, 
}
YijiLB = sgs.CreateMasochismSkill{
	name = "YijiLB",
	can_preshow = true,
	frequency = sgs.Skill_Frequent,
	view_as_skill = YijiLBVS,
	can_trigger = function(self, event, room, player, data)	
		if not player or player:isDead() or not player:hasSkill(self:objectName()) then return false end
		local trigger_list = {}
		local damage = data:toDamage()
		for i = 1, damage.damage, 1 do
			table.insert(trigger_list, self:objectName())
		end
		return table.concat(trigger_list,",")
	end,
	on_cost = function(self, event, room, player, data)
		if room:askForSkillInvoke(player, self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), player)
			return true
		end
		return false
	end,
	on_damaged = function(self, player, damage)
		local room = player:getRoom()
		player:drawCards(2, self:objectName())
		
		local ids, get = sgs.QList2Table(player:handCards()), {}
		local targets_num, cards_num, total_num = 0, {}, 0
		room:setPlayerProperty(player, self:objectName() .. "_distribution", sgs.QVariant())
		
		while #ids > 0 do
			room:setPlayerProperty(player, self:objectName() .. "_hands", sgs.QVariant(table.concat(ids, "+")))
			local u_card = room:askForUseCard(player, "@@" .. self:objectName(), "@" .. self:objectName())
			if not u_card then
				break
			end
			local target = player:getTag(self:objectName().."_target"):toPlayer()

			for _, id in sgs.qlist(u_card:getSubcards()) do
				table.removeOne(ids, id)
				table.insert(get, target:objectName().."|"..id)
			end
			room:setPlayerProperty(player, self:objectName() .. "_distribution", sgs.QVariant(table.concat(get, ",")))
			
			if not cards_num[target:objectName()] or (cards_num[target:objectName()] == 0) then
				targets_num = targets_num + 1
				cards_num[target:objectName()] = u_card:subcardsLength()
			else
				cards_num[target:objectName()] = cards_num[target:objectName()] + u_card:subcardsLength()
			end
			total_num = total_num + u_card:subcardsLength()
			if total_num >= 4 then break end
		end

		local dummy = sgs.DummyCard()
		for _, p in sgs.qlist(room:getAllPlayers()) do
			dummy = sgs.DummyCard()
			for _, toget in ipairs(get) do
				if toget:split("|")[1] == p:objectName() then dummy:addSubcard(tonumber(toget:split("|")[2])) end
			end
			if not dummy:getSubcards():isEmpty() then
				p:addToPile(self:objectName(), dummy, false)
			end
		end
		dummy:deleteLater()
	end,
}]]
YijiLB = sgs.CreateMasochismSkill{
	name = "YijiLB",
	can_preshow = true,
	frequency = sgs.Skill_Frequent,
	can_trigger = function(self, event, room, player, data)	
		if not player or player:isDead() or not player:hasSkill(self:objectName()) then return false end
		local trigger_list = {}
		local damage = data:toDamage()
		for i = 1, damage.damage, 1 do
			table.insert(trigger_list, self:objectName())
		end
		return table.concat(trigger_list,",")
	end,
	on_cost = function(self, event, room, player, data)
		if room:askForSkillInvoke(player, self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), player)
			return true
		end
		return false
	end,
	on_damaged = function(self, player, damage)
		local room = player:getRoom()
		player:drawCards(2, self:objectName())
		if player:isKongcheng() then return end
		
		local targets = room:askForPlayersChosen(player, room:getOtherPlayers(player), self:objectName(), 0, math.min(2, player:getHandcardNum()), "@YijiLB")
		if targets:isEmpty() then return end
		room:sortByActionOrder(targets)
		for i, target in sgs.qlist(targets) do
			if not target:isAlive() then continue end
			local num = math.min(player:getHandcardNum() - (targets:length() - i) + 1, 2)
			if num <= 0 then continue end
			local dummy = room:askForExchange(player, self:objectName(), num, 1, "YijiLBGive::" .. target:objectName() .. ":" .. num, "", ".|.|.|hand")
			target:addToPile(self:objectName(), dummy, false)
			dummy:deleteLater()
		end
		
		--[[local ids, get = sgs.QList2Table(player:handCards()), {}
		local targets_num, cards_num, total_num = 0, {}, 0
		room:setPlayerProperty(player, self:objectName() .. "_distribution", sgs.QVariant())
		
		while #ids > 0 do
			room:setPlayerProperty(player, self:objectName() .. "_hands", sgs.QVariant(table.concat(ids, "+")))
			local u_card = room:askForUseCard(player, "@@" .. self:objectName(), "@" .. self:objectName())
			if not u_card then
				break
			end
			local target = player:getTag(self:objectName().."_target"):toPlayer()

			for _, id in sgs.qlist(u_card:getSubcards()) do
				table.removeOne(ids, id)
				table.insert(get, target:objectName().."|"..id)
			end
			room:setPlayerProperty(player, self:objectName() .. "_distribution", sgs.QVariant(table.concat(get, ",")))
			
			if not cards_num[target:objectName()] or (cards_num[target:objectName()] == 0) then
				targets_num = targets_num + 1
				cards_num[target:objectName()] = u_card:subcardsLength()
			else
				cards_num[target:objectName()] = cards_num[target:objectName()] + u_card:subcardsLength()
			end
			total_num = total_num + u_card:subcardsLength()
			if total_num >= 4 then break end
		end

		local dummy = sgs.DummyCard()
		for _, p in sgs.qlist(room:getAllPlayers()) do
			dummy = sgs.DummyCard()
			for _, toget in ipairs(get) do
				if toget:split("|")[1] == p:objectName() then dummy:addSubcard(tonumber(toget:split("|")[2])) end
			end
			if not dummy:getSubcards():isEmpty() then
				p:addToPile(self:objectName(), dummy, false)
			end
		end
		dummy:deleteLater()]]
	end,
}
YijiLBObtain = sgs.CreatePhaseChangeSkill{
	name = "#YijiLB-obtain",  
	frequency = sgs.Skill_Compulsory,  --然而由于2.1.0的bug（类似鼓舌），触发的不是技能拥有者的话可以点取消，Compulsory也没用
	can_trigger = function(self, event, room, player, data)
		if player:isAlive() and (player:getPhase() == sgs.Player_Draw) and not player:getPile("YijiLB"):isEmpty() then return self:objectName() end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		return true
	end,
	on_phasechange = function(self, player)
		local room = player:getRoom()
		local dummy = sgs.DummyCard(player:getPile("YijiLB"))
		local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_EXCHANGE_FROM_PILE, player:objectName(), "YijiLB", "")
		room:obtainCard(player, dummy, reason, false)
		dummy:deleteLater()
	end,
}
GuoJia_LB:addSkill(YijiLB)
GuoJia_LB:addSkill(YijiLBObtain)
sgs.insertRelatedSkills(extensionLB, "YijiLB", "#YijiLB-obtain")

----------------------------------------------------------------------------------------------------

--[[ SHU 001 刘备
	武将：LiuBei_LB
	武将名：刘备-界
	体力上限：4
	武将技能：
		仁德：出牌阶段，你可以将至少一张手牌交给一名本阶段未获得过“仁德”牌的其他角色，若你以此法交给其他角色的手牌数不小于2，你可以视为使用任意一张基本牌。
	状态：验证通过
]]--
LiuBei_LB = sgs.General(extensionLB, "LiuBei_LB", "shu", 4, true, true)
LiuBei_LB:addCompanion("guanyu")
LiuBei_LB:addCompanion("zhangfei")
LiuBei_LB:addCompanion("ganfuren")

--[[
	技能名：仁德
	技能：RendeLB
	描述：出牌阶段，你可以将至少一张手牌交给一名本阶段未获得过“仁德”牌的其他角色，若你以此法交给其他角色的手牌数不小于2，你可以视为使用任意一张基本牌。
	状态：验证通过
]]--
RendeLBCard = sgs.CreateSkillCard{
	name = "RendeLBCard", 
	skill_name = "RendeLB",
	will_throw = false, 
	handling_method = sgs.Card_MethodNone, 
	filter = function(self, selected, to_select)
		return #selected == 0 and to_select:objectName() ~= sgs.Self:objectName() and to_select:getMark("RendeLBRecipient") == 0
	end, 
	extra_cost = function(self,room,card_use)
		local target = card_use.to:first()
		local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_GIVE, card_use.from:objectName(), target:objectName(), "RendeLB", "")
		room:obtainCard(target, self, reason, false)
	end,
	on_use = function(self, room, source, targets)
		if source:isDead() then return end
		local old_value = source:getMark("RendeLB")
		room:addPlayerMark(source, "RendeLB", self:getSubcards():length())
		room:addPlayerMark(targets[1], "RendeLBRecipient")
		if (old_value < 2) and source:getMark("RendeLB") >= 2 then
			local basic = fetchCards("BasicCard", nil, player)
			table.insert(basic, "cancel")
			local done = false
			while not done do
				done = true
				for _, patt in ipairs(basic) do
					if patt == "cancel" then continue end
					local poi = sgs.Sanguosha:cloneCard(patt, sgs.Card_NoSuit, 0)
					if poi and not poi:isAvailable(source) then
						table.removeOne(basic, patt)
						if patt == "slash" then
							table.removeOne(basic, "thunder_slash")
							table.removeOne(basic, "fire_slash")
						end
						done = false
						break
					end
				end
			end
			local choice = room:askForChoice(source, "RendeLB", table.concat(basic, "+"))
			if choice ~= "cancel" then
				local card = sgs.Sanguosha:cloneCard(choice, sgs.Card_NoSuit, 0)
				if card:targetFixed() then
					card:setSkillName("_RendeLB")
					room:useCard(sgs.CardUseStruct(card, source, sgs.SPlayerList()))
				else
					room:setPlayerProperty(source, "RendeLBBasicCard", sgs.QVariant(choice))
					room:askForUseCard(source, "@@RendeLB", "@RendeLB:::" .. choice, -1, sgs.Card_MethodUse)
					room:setPlayerProperty(source, "RendeLBBasicCard", sgs.QVariant())
				end
			end
		end
	end, 
}
RendeLBVS = sgs.CreateViewAsSkill{
	name = "RendeLB", 
	n = 999, 
	response_pattern = "@@RendeLB", 
	view_filter = function(self, selected, to_select)
		if sgs.Sanguosha:getCurrentCardUsePattern() == "@@RendeLB" then return false end
		return not to_select:isEquipped()
	end, 
	view_as = function(self, cards)
		if sgs.Sanguosha:getCurrentCardUsePattern() == "@@RendeLB" then
			if #cards == 0 then
				local name = sgs.Self:property("RendeLBBasicCard"):toString()
				local card = sgs.Sanguosha:cloneCard(name, sgs.Card_NoSuit, 0)
				card:setSkillName("_RendeLB")
				return card
			end
		else
			if #cards > 0 then
				local rende = RendeLBCard:clone()
				for _, c in ipairs(cards) do
					rende:addSubcard(c)
				end
				rende:setShowSkill(self:objectName())
				return rende
			end
		end
		return nil
	end, 
	enabled_at_play = function(self, player)
		return not player:isKongcheng()
	end
}
RendeLB = sgs.CreateTriggerSkill{
	name = "RendeLB",
	events = {sgs.EventPhaseStart},
	priority = 8,  --本来想用EventPhaseChanging，但是当先触发不了
	view_as_skill = RendeLBVS,
	on_record = function(self, event, room, player, data)
		if player:getPhase() ~= sgs.Player_Play then return false end
		if player:getMark(self:objectName()) > 0 then
			room:setPlayerMark(player, self:objectName(), 0)
		end
		for _,p in sgs.qlist(room:getAllPlayers()) do
			if p:getMark("RendeLBRecipient") > 0 then
				room:setPlayerMark(p, "RendeLBRecipient", 0)
			end
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
LiuBei_LB:addSkill(RendeLB)

----------------------------------------------------------------------------------------------------

--[[ SHU 002 关羽
	武将：GuanYu_LB
	武将名：关羽-界
	体力上限：4
	武将技能：
		武圣：你可以将一张红色牌当【杀】使用或打出。
		义绝：出牌阶段限一次，你可以与一名角色拼点：若你赢，该角色不能使用或打出手牌且你选择的其一张武将牌的非锁定技无效，直到回合结束；若你没赢，你可以令该角色回复1点体力。
	状态：验证通过
]]--
GuanYu_LB = sgs.General(extensionLB, "GuanYu_LB", "shu", 4, true, true)
GuanYu_LB:addCompanion("liubei")
GuanYu_LB:addCompanion("LiuBei_LB")

--[[
	技能名：武圣
	技能：wusheng_GuanYu_LB
	描述：你可以将一张红色牌当【杀】使用或打出。
	状态：复制手册
]]--
function sgs.CreateWushengSkill(name)
	local wusheng_skill = {
		name = "wusheng_" .. name,
		response_or_use = true,
		view_filter = function(self, card)
			local lord = sgs.Self:getLord()
			if not lord or not lord:hasLordSkill("shouyue") or not lord:hasShownGeneral1() then
				if not card:isRed() then return false end
			end
			if sgs.Sanguosha:getCurrentCardUseReason() == sgs.CardUseStruct_CARD_USE_REASON_PLAY then
				local slash = sgs.Sanguosha:cloneCard("slash", sgs.Card_SuitToBeDecided, -1)
				slash:addSubcard(card:getEffectiveId())
				slash:deleteLater()
				return slash:isAvailable(sgs.Self)
			end
			return true
		end,
		view_as = function(self, originalCard)
			local slash = sgs.Sanguosha:cloneCard("slash", originalCard:getSuit(), originalCard:getNumber())
			slash:addSubcard(originalCard:getId())
			slash:setSkillName(self:objectName())
			slash:setShowSkill(self:objectName())
			return slash
		end,
		enabled_at_play = function(self, player)
			return sgs.Slash_IsAvailable(player)
		end,
		enabled_at_response = function(self, player, pattern)
			return pattern == "slash"
		end,
	}
	return sgs.CreateOneCardViewAsSkill(wusheng_skill)
end
wusheng_GuanYu_LB = sgs.CreateWushengSkill("GuanYu_LB")
GuanYu_LB:addSkill(wusheng_GuanYu_LB)

--[[
	技能名：义绝
	技能：Yijue
	描述：出牌阶段限一次，你可以与一名角色拼点：若你赢，该角色不能使用或打出手牌且你选择的其一张武将牌的非锁定技无效，直到回合结束；若你没赢，你可以令该角色回复1点体力。
	状态：验证通过
]]--
fake_attached_lord_skills = {"Xiansi_slash"}  --（所有伪AttachedLordSkill都要写到这里）
function NonCompulsoryInvalidity(self, player, skill, isHas)  --isSkillValid函数
	if skill:getFrequency() == sgs.Skill_Compulsory or skill:isAttachedLordSkill() or table.contains(fake_attached_lord_skills, skill:objectName()) then return true end
	local reason = self:objectName()
	local invalid_list = player:property("NonCompulsoryInvalidity"):toString():split(",")
	local isHeadInvalid, isDeputyInvalid = false, false
	for i, str in ipairs(invalid_list) do
		local tab = str:split("+")
		if table.contains(tab, reason) then
			if tab[1] == "head" then
				isHeadInvalid = true
			elseif tab[1] == "deputy" then
				isDeputyInvalid = true
			end
		end
	end
	if isHeadInvalid then
		for _,headSkill in sgs.qlist(player:getHeadSkillList()) do
			if headSkill:objectName() == skill:objectName() then
				return false
			end
		end
	end
	if isDeputyInvalid then
		for _,depSkill in sgs.qlist(player:getDeputySkillList()) do
			if depSkill:objectName() == skill:objectName() then
				return false
			end
		end
	end
	return true
end
function doNonCompulsoryInvalidity(source, target, reason)  --一张武将牌的非锁定技无效
	if source:isDead() or target:isDead() then return false end
	local room = source:getRoom()
	local _data = sgs.QVariant()
	_data:setValue(target)
	local choices = {}
	local choice = "head_general"
	if source:getAI() then
		if not string.find(target:getGeneralName(), "sujiang") then
			table.insert(choices, "head_general")
		end
		if target:getGeneral2() and not string.find(target:getGeneral2Name(), "sujiang") then
			table.insert(choices, "deputy_general")
		end
		choice = room:askForChoice(source, reason, table.concat(choices, "+"), _data)
	else
		local generals = {}
		if not string.find(target:getGeneralName(), "sujiang") then
			local g = target:getGeneralName()
			if string.find(g, "anjiang") then
				g = "anjiang_head"
			end
			table.insert(generals, g)
		end
		if target:getGeneral2() and not string.find(target:getGeneral2Name(), "sujiang") then
			local g = target:getGeneral2Name()
			if string.find(g, "anjiang") then
				g = "anjiang_deputy"
			end
			table.insert(generals, g)
		end
		local general = generals[1]
		if #generals == 2 then
			general = room:askForGeneral(source, table.concat(generals, "+"), generals[1], true, reason, _data)
		end
		if (general == target:getGeneralName()) or (general == "anjiang_head") then
			choice = "head_general"
		else
			choice = "deputy_general"
		end
	end
	local msg = sgs.LogMessage()
	msg.type = (choice == "head_general") and "#NonCompulsoryInvalidityHead" or "#NonCompulsoryInvalidityDeputy"
	msg.arg = reason
	msg.arg2 = (choice == "head_general") and target:getGeneralName() or target:getGeneral2Name()
	msg.to:append(target)
	if msg.arg2 ~= "anjiang" then
		room:sendLog(msg)
	else
		for _,p in sgs.qlist(room:getOtherPlayers(target, true)) do
			room:doNotify(p, sgs.CommandType.S_COMMAND_LOG_SKILL, msg:toVariant())
		end
		msg.arg2 = (choice == "head_general") and target:getActualGeneral1Name() or target:getActualGeneral2Name()
		room:doNotify(target, sgs.CommandType.S_COMMAND_LOG_SKILL, msg:toVariant())
	end
	
	local skillName = reason
	local invalid_list = target:property("NonCompulsoryInvalidity"):toString():split(",")
	--格式：head+Yijue+Tieqi,deputy+Yijue（为以后非锁在回合结束后还有效果的技能做准备）
	local head_appeared, deputy_appeared = false, false
	for i, str in ipairs(invalid_list) do
		if str:startsWith("head") and (choice == "head_general") then
			head_appeared = true
			local tab = str:split("+")
			if not table.contains(tab, skillName) then
				table.insert(tab, skillName)
			end
			invalid_list[i] = table.concat(tab, "+")
		elseif str:startsWith("deputy") and (choice == "deputy_general") then
			deputy_appeared = true
			local tab = str:split("+")
			if not table.contains(tab, skillName) then
				table.insert(tab, skillName)
			end
			invalid_list[i] = table.concat(tab, "+")
		end
	end
	if not head_appeared and (choice == "head_general") then
		table.insert(invalid_list, "head+" .. skillName)
	elseif not deputy_appeared and (choice == "deputy_general") then
		table.insert(invalid_list, "deputy+" .. skillName)
	end
	room:setPlayerProperty(target, "NonCompulsoryInvalidity", sgs.QVariant(table.concat(invalid_list, ",")))
	
	updateSkillValidity(sgs.Sanguosha:getSkill(skillName), NonCompulsoryInvalidity)
end
function clearNonCompulsoryInvalidity(source, target, reason)
	local room = target:getRoom()
	local skillName = reason
	local invalid_list = target:property("NonCompulsoryInvalidity"):toString():split(",")
	for i, str in ipairs(invalid_list) do
		local tab = str:split("+")
		if table.contains(tab, skillName) then
			table.removeAll(tab, skillName)
			if #tab == 1 then
				invalid_list[i] = ""
			else
				invalid_list[i] = table.concat(tab, "+")
			end
		end
	end
	table.removeAll(invalid_list, "")
	room:setPlayerProperty(target, "NonCompulsoryInvalidity", sgs.QVariant(table.concat(invalid_list, ",")))
	updateSkillValidity(sgs.Sanguosha:getSkill(skillName), NonCompulsoryInvalidity)
end
function clearAllNonCompulsoryInvalidityForSpecificGeneral(source, target, isHead)
	local room = target:getRoom()
	local skillName = reason
	local invalid_list = target:property("NonCompulsoryInvalidity"):toString():split(",")
	table.removeAll(invalid_list, "")
	local invalidity_skills = {}
	for i, str in ipairs(invalid_list) do
		local tab = str:split("+")
		if (isHead and tab[1] == "head") or (not isHead and tab[1] == "deputy") then
			invalidity_skills = table.copyFrom(tab)
			table.remove(invalidity_skills, 1)
			invalid_list[i] = ""
		end
	end
	table.removeAll(invalid_list, "")
	room:setPlayerProperty(target, "NonCompulsoryInvalidity", sgs.QVariant(table.concat(invalid_list, ",")))
	for _,invSkillName in ipairs(invalidity_skills) do
		updateSkillValidity(sgs.Sanguosha:getSkill(invSkillName), NonCompulsoryInvalidity)
	end
end
YijueCard = sgs.CreateSkillCard{
	name = "YijueCard", 
 	will_throw = false,
	skill_name = "Yijue",
	filter = function(self, targets, to_select, player)
		return #targets == 0 and not to_select:isKongcheng() and to_select:objectName() ~= player:objectName()
	end,
	extra_cost = function(self, room, use)
		local pd = sgs.PindianStruct()
		pd = use.from:pindianSelect(use.to:first(), "Yijue")
		local d = sgs.QVariant()
		d:setValue(pd)
		use.from:setTag("Yijue_pd", d)
	end,		
	on_effect = function(self, effect)
		local source = effect.from
		local target = effect.to
		local room = source:getRoom()
		local pd = effect.from:getTag("Yijue_pd"):toPindian()
		effect.from:removeTag("Yijue_pd")
		if pd then
			local success = effect.from:pindian(pd)
			pd = nil
			if success then
				target:addMark("Yijue")
				room:setPlayerCardLimitation(target, "use,response", ".|.|.|hand", true)
				if source:isAlive() then doNonCompulsoryInvalidity(source, target, "Yijue") end
				room:addPlayerMark(target, "@skill_invalidity")
			else
				if effect.to:isWounded() then
					target:setFlags("YijueTarget")
					if source:isDead() then return end
					local choice = room:askForChoice(source, "YijueRecover", "recover+cancel")
					target:setFlags("-YijueTarget")
					if choice == "recover" then
						local recover = sgs.RecoverStruct()
						recover.who = source
						room:recover(target, recover)
					end
				end
			end
		end
	end
}
YijueVS = sgs.CreateZeroCardViewAsSkill{
	name = "Yijue",
	view_filter = function(self, selected, to_select)
		return false
	end,
	view_as = function(self, cards)
		local card = YijueCard:clone()
		card:setShowSkill(self:objectName())
		return card
	end, 
	enabled_at_play = function(self, player)
		return not player:hasUsed("#YijueCard") and not player:isKongcheng()
	end,
}
Yijue = sgs.CreateTriggerSkill{
	name = "Yijue",
	can_preshow = false,
	events = {sgs.EventPhaseStart},
	priority = 8,
	view_as_skill = YijueVS,
	on_record = function(self, event, room, player, data)
		if player:getPhase() ~= sgs.Player_NotActive then return false end
		for _,p in sgs.qlist(room:getAllPlayers()) do
			if p:getMark("Yijue") > 0 then
				for i = 1, p:getMark("Yijue") do
					room:removePlayerMark(p, "@skill_invalidity")
					room:removePlayerCardLimitation(p, "use,response", ".|.|.|hand$1")
				end
				room:setPlayerMark(p, "Yijue", 0)
				
				clearNonCompulsoryInvalidity(player, p, self:objectName())
			end
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end
}
handleNonCompulsoryInvalidity = sgs.CreateTriggerSkill{
	name = "handleNonCompulsoryInvalidity",
	events = {sgs.GeneralRemoved},  --移除、变副将、飞龙复活时清除原本的记录
	priority = 9,
	global = true,
	on_record = function(self, event, room, player, data)
		if string.find(player:getGeneralName(), "sujiang") then
			clearAllNonCompulsoryInvalidityForSpecificGeneral(nil, player, true)
		end
		if string.find(player:getGeneral2Name(), "sujiang") then
			clearAllNonCompulsoryInvalidityForSpecificGeneral(nil, player, false)
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end
}
GuanYu_LB:addSkill(Yijue)
local skills = sgs.SkillList()
if not sgs.Sanguosha:getSkill("handleNonCompulsoryInvalidity") then skills:append(handleNonCompulsoryInvalidity) end
sgs.Sanguosha:addSkills(skills)

----------------------------------------------------------------------------------------------------

--[[ SHU 003 张飞
	武将：ZhangFei_LB
	武将名：张飞-界
	体力上限：4
	武将技能：
		咆哮：你使用【杀】无次数限制。
		替身：限定技，准备阶段开始时，你可以将体力值回复至等同于你上回合结束时的体力值，摸X张牌（X为你以此法回复的体力数）。
	状态：验证通过
]]--
ZhangFei_LB = sgs.General(extensionLB, "ZhangFei_LB", "shu", 4, true, true)
ZhangFei_LB:addCompanion("liubei")
ZhangFei_LB:addCompanion("LiuBei_LB")

--[[
	技能名：咆哮
	技能：paoxiao_ZhangFei_LB
	描述：你使用【杀】无次数限制。
	状态：复制手册
	注：亮将代码在showTMSkillForSlash中
]]--
function sgs.CreatePaoxiaoSkill(name)
	local paoxiao_skill = {
		name = "paoxiao_" .. name,
		pattern = "Slash",
		residue_func = function(self, from, card)
			if not sgs.Sanguosha:matchExpPattern("Slash", from, card) then return 0 end
			if from:hasSkill(self:objectName()) then
				return 1000
			else
				return 0
			end
		end,
	}
	return sgs.CreateTargetModSkill(paoxiao_skill)
end
paoxiao_ZhangFei_LB = sgs.CreatePaoxiaoSkill("ZhangFei_LB")
function sgs.CreatePaoxiaoArmorNullificaionSkill(name)
	local paoxiao_armor_skill = {
		name = "#paoxiao-null_" .. name,
		events = {sgs.TargetChosen},
		frequency = sgs.Skill_Compulsory,
		global = true,
		can_preshow = false,

		can_trigger = function(self,event,room,player,data)
			if not player or player:isDead() then return "" end
			local use = data:toCardUse()
			if player:hasSkill("paoxiao_" .. name) then
				local lord = room:getLord(player:getKingdom())
				if lord and lord:hasLordSkill("shouyue") and lord:hasShownGeneral1() then
					if use.card and use.card:isKindOf("Slash") then
						local targets = {}
						for _, p in sgs.qlist(use.to) do
							table.insert(targets, p:objectName())
						end
						if #targets > 0 then
							return self:objectName() .. "->" .. table.concat(targets, "+")
						end
					end
				end
			end
		end,
		on_cost = function(self,event,room,target,data, ask_who)
			if ask_who then
				if ask_who:hasShownSkill("paoxiao_" .. name) then
					return true
				else
					ask_who:setTag("paoxiao_use", data)				--useless data?
					local invoke = ask_who:askForSkillInvoke("paoxiao", sgs.QVariant("armor_nullify:" .. target:objectName()))
					ask_who:removeTag("paoxiao_use")
					if invoke then
						ask_who:showGeneral(ask_who:inHeadSkills("paoxiao_" .. name))
						return true
					end
				end
			end
		end,

		on_effect = function(self,event,room,target,data, ask_who)
			local lord = room:getLord(ask_who:getKingdom())
			room:notifySkillInvoked(lord, "shouyue")
			room:broadcastSkillInvoke("shouyue")
			local use = data:toCardUse()
			target:addQinggangTag(use.card)
		end,
	}
	return sgs.CreateTriggerSkill(paoxiao_armor_skill)
end
paoxiaoArmorNullificaion_ZhangFei_LB = sgs.CreatePaoxiaoArmorNullificaionSkill("ZhangFei_LB")
ZhangFei_LB:addSkill(paoxiao_ZhangFei_LB)
ZhangFei_LB:addSkill(paoxiaoArmorNullificaion_ZhangFei_LB)
sgs.insertRelatedSkills(extensionLB, "paoxiao_ZhangFei_LB", "#paoxiao-null_ZhangFei_LB")

--[[
	技能名：替身
	技能：Tishen
	描述：限定技，准备阶段开始时，你可以将体力值回复至等同于你上回合结束时的体力值，摸X张牌（X为你以此法回复的体力数）。
	状态：验证通过
]]--
TishenRecord = sgs.CreateTriggerSkill{
	name = "#Tishen-record",
	can_preshow = true,
	events = {sgs.EventPhaseChanging, sgs.GeneralShown},
	global = true,
	on_record = function(self, event, room, player, data)
		if (event == sgs.EventPhaseChanging) and (data:toPhaseChange().to == sgs.Player_NotActive) then
			room:setPlayerProperty(player, "Tishen_hp", sgs.QVariant(player:getHp()))
			if player:getMark("@substitute") == 0 then return end
			if player:hasShownSkill("Tishen") then
				room:setPlayerMark(player, "@substitute_hp", player:getHp())
			elseif player:hasSkill("Tishen") then
				player:setMark("@substitute_hp", player:getHp())
				local arg = {
					player:objectName(), 
					"@substitute_hp", 
					player:getHp(),
				}
				room:doNotify(player, sgs.CommandType.S_COMMAND_SET_MARK, json.encode(arg))
			end
		elseif (event == sgs.GeneralShown) and player:hasSkill("Tishen") and (data:toBool() == player:inHeadSkills("Tishen")) then
			if player:getMark("@substitute") == 0 then return end
			room:setPlayerMark(player, "@substitute_hp", player:getMark("@substitute_hp"))
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
Tishen = sgs.CreateTriggerSkill{
	name = "Tishen",
	can_preshow = true,
	events = {sgs.EventPhaseStart},
	frequency = sgs.Skill_Limited,
	limit_mark = "@substitute",
	can_trigger = function(self, event, room, player, data)
		if not player or player:isDead() or not player:hasSkill(self:objectName()) then return "" end
		if (player:getPhase() == sgs.Player_Start) and (player:getMark("@substitute") > 0) then
			local hp_str = player:property("Tishen_hp"):toString()
			if not hp_str or hp_str == "" then return "" end
			local hp = tonumber(hp_str)
			local x = math.min(hp - player:getHp(), player:getMaxHp() - player:getHp())
			if x > 0 then
				return self:objectName()
			end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		if player:askForSkillInvoke(self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), player)
			room:doSuperLightbox("ZhangFei_LB", self:objectName())
			room:removePlayerMark(player, "@substitute")
			room:setPlayerMark(player, "@substitute_hp", 0)
			return true
		end
	end,
	on_effect = function(self, event, room, player, data)
		local hp_str = player:property("Tishen_hp"):toString()
		if not hp_str or hp_str == "" then return end
		local hp = tonumber(hp_str)
		local x = math.min(hp - player:getHp(), player:getMaxHp() - player:getHp())
		if x > 0 then
			local recover = sgs.RecoverStruct()
			recover.recover = x
			recover.who = player
			room:recover(player, recover)
			player:drawCards(x, self:objectName())
		end
	end,
}
ZhangFei_LB:addSkill(Tishen)
ZhangFei_LB:addSkill(TishenRecord)
sgs.insertRelatedSkills(extensionLB, "Tishen", "#Tishen-record")

----------------------------------------------------------------------------------------------------

--[[ SHU 005 赵云
	武将：ZhaoYun_LB
	武将名：赵云-界
	体力上限：4
	武将技能：
		龙胆：你可以将一张【杀】当【闪】使用或打出；你可以将一张【闪】当【杀】使用或打出。
		涯角：当你于回合外使用或打出手牌时，你可以展示牌堆顶的一张牌，若这两张牌的类别：相同，你可以将展示的牌交给一名角色；不同，你可以将之置入弃牌堆。
	状态：验证通过
]]--
ZhaoYun_LB = sgs.General(extensionLB, "ZhaoYun_LB", "shu", 4, true, true)
ZhaoYun_LB:addCompanion("liushan")

--[[
	技能名：龙胆
	技能：longdan_ZhaoYun_LB
	描述：你可以将一张【杀】当【闪】使用或打出；你可以将一张【闪】当【杀】使用或打出。
	状态：复制手册
]]--
function sgs.CreateLongdanVSSkill(name)
	local longdan_vs_skill = {
		name = "longdan_" .. name,
		response_or_use = true,
		view_filter = function(self, to_select)
			local card = to_select
			local usereason = sgs.Sanguosha:getCurrentCardUseReason()
			if usereason == sgs.CardUseStruct_CARD_USE_REASON_PLAY then
				return card:isKindOf("Jink")
			elseif (usereason == sgs.CardUseStruct_CARD_USE_REASON_RESPONSE) or (usereason == sgs.CardUseStruct_CARD_USE_REASON_RESPONSE_USE) then
				local pattern = sgs.Sanguosha:getCurrentCardUsePattern()
				if pattern == "slash" then
					return card:isKindOf("Jink")
				else
					return card:isKindOf("Slash")
				end
			else
				return false
			end
		end,
		
		view_as = function(self, originalCard)
			if originalCard:isKindOf("Slash") then
				local jink = sgs.Sanguosha:cloneCard("jink", originalCard:getSuit(), originalCard:getNumber())
				jink:addSubcard(originalCard)
				jink:setSkillName(self:objectName())
				jink:setShowSkill(self:objectName())
				return jink
			elseif originalCard:isKindOf("Jink") then
				local slash = sgs.Sanguosha:cloneCard("slash", originalCard:getSuit(), originalCard:getNumber())
				slash:addSubcard(originalCard)
				slash:setSkillName(self:objectName())
				slash:setShowSkill(self:objectName())
				return slash
			else
				return nil
			end
		end ,
		enabled_at_play = function(self, target)
			return sgs.Slash_IsAvailable(target)
		end,
		enabled_at_response = function(self, target, pattern)
			return (pattern == "slash") or (pattern == "jink")
		end,
	}
	return sgs.CreateOneCardViewAsSkill(longdan_vs_skill)
end
longdanVS_ZhaoYun_LB = sgs.CreateLongdanVSSkill("ZhaoYun_LB")
function sgs.CreateLongdanSkill(name, vs_skill)
	local longdan_skill = {
		name = "longdan_" .. name,
		events = {sgs.CardUsed, sgs.CardResponded},
		view_as_skill = vs_skill,

		can_trigger = function(self,event,room,player,data)
			if not player or player:isDead() or not player:hasShownSkill(self) then return false end
			local lord = room:getLord(player:getKingdom())
			if lord and lord:hasLordSkill("shouyue") and lord:hasShownGeneral1() then
				local card
				if event == sgs.CardUsed then
					card = data:toCardUse().card
				else
					card = data:toCardResponse().m_card
				end
				if card and card:getSkillName() == "longdan_" .. name then
					return self:objectName()
				end
			end
		end,
		on_cost = function(self,event,room,player,data)
			return true
		end,
		on_effect = function(self,event,room,player,data)
			local lord = room:getLord(player:getKingdom())
			room:notifySkillInvoked(lord, "shouyue")
			player:drawCards(1)
		end,
	}
	return sgs.CreateTriggerSkill(longdan_skill)
end
longdan_ZhaoYun_LB = sgs.CreateLongdanSkill("ZhaoYun_LB", longdanVS_ZhaoYun_LB)
ZhaoYun_LB:addSkill(longdan_ZhaoYun_LB)

--[[
	技能名：涯角
	技能：Yajiao
	描述：当你于回合外使用或打出手牌时，你可以展示牌堆顶的一张牌，若这两张牌的类别：相同，你可以将展示的牌交给一名角色；不同，你可以将之置入弃牌堆。
	状态：复制原项目并调整
]]--
Yajiao = sgs.CreateTriggerSkill{  --可考虑：改涯角荐言的给牌操作方式，改为notifyMoveCards将牌移动至手牌区，然后用技能卡
	name = "Yajiao",
	can_preshow = true,
	events = {sgs.CardUsed, sgs.CardResponded},
	frequency = sgs.Skill_Frequent,
	can_trigger = function(self, event, room, player, data)
		if player and player:isAlive() and player:hasSkill(self:objectName()) then
			if player:getPhase() ~= sgs.Player_NotActive then return false end
			local card
			local isHandcard = false
			if event == sgs.CardUsed then
				local use = data:toCardUse()
				card = use.card
				isHandcard = use.m_isHandcard
			elseif event == sgs.CardResponded then
				card = data:toCardResponse().m_card
				isHandcard = data:toCardResponse().m_isHandcard
			end
			if not card or (card:getHandlingMethod() ~= sgs.Card_MethodUse and card:getHandlingMethod() ~= sgs.Card_MethodResponse) then return false end
			return isHandcard and self:objectName() or ""
		end
		return ""
	end	,
	on_cost = function(self, event, room, player, data)
		if room:askForSkillInvoke(player, self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), player)
			return true
		end
		return false
	end,
	on_effect = function(self, event, room, player, data)
		local ids = room:getNCards(1, false)
		local move = sgs.CardsMoveStruct(ids, player, sgs.Player_PlaceTable, sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_TURNOVER, player:objectName(), self:objectName(), ""))
		room:moveCardsAtomic(move, true)
		local cardstar
		if event == sgs.CardUsed then
			local use = data:toCardUse()
			cardstar = use.card
		elseif event == sgs.CardResponded then
			cardstar = data:toCardResponse().m_card
		end
		
		local id = ids:first()
		local card = sgs.Sanguosha:getCard(id)
		room:fillAG(ids, player)
		local dealt = false
		if card:getTypeId() == cardstar:getTypeId() then
			player:setMark(self:objectName(), id)  --for AI
			local target = room:askForPlayerChosen(player, room:getAlivePlayers(), self:objectName(), "@Yajiao-give:::" .. card:objectName() .. ":" .. card:getSuitString() .. "_char\\" .. card:getNumberString(), true)
			if target then
				room:clearAG(player)
				dealt = true
				room:obtainCard(target, card, sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_DRAW, target:objectName(), self:objectName(), ""))
			end
		else
			--[[local dat = sgs.QVariant()
			dat:setValue(card)
			if room:askForChoice(player, self:objectName(), "throw+cancel", dat) == "throw" then]]
			player:setMark(self:objectName(), id)  --for AI
			if room:askForSkillInvoke(player, "YajiaoDiscard", sgs.QVariant("throw:::" .. card:objectName() .. ":" .. card:getSuitString() .. "_char\\" .. card:getNumberString())) then
				room:clearAG(player)
				dealt = true
				room:throwCard(card, sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_NATURAL_ENTER, player:objectName(), self:objectName(), ""), nil)
			end
		end
		if not dealt then
			room:clearAG(player)
			room:returnToDrawPile(ids, false)
		end
		return false
	end,
}
ZhaoYun_LB:addSkill(Yajiao)

----------------------------------------------------------------------------------------------------

--[[ SHU 006 马超
	武将：MaChao_LB
	武将名：马超-界
	体力上限：4
	武将技能：
		马术：锁定技，你与其他角色的距离-1。
		铁骑：当你使用【杀】指定一个目标后，你可以令你选择的其一张武将牌的非锁定技于此回合内无效，然后进行判定，令其选择一项：1. 弃置与结果花色相同的一张牌；2. 不能使用【闪】响应此【杀】。
	状态：验证通过
]]--
MaChao_LB = sgs.General(extensionLB, "MaChao_LB", "shu", 4, true, true)
MaChao_LB:addCompanion("madai")

--[[
	技能名：马术
	技能：mashu_MaChao_LB
	描述：锁定技，你与其他角色的距离-1。
	状态：复制手册
]]--
function sgs.CreateMashuSkill(name)
	local mashu_skill = {
		name = "mashu_" .. name,
		correct_func = function(self, from, to)
			if from:hasSkill(self:objectName()) and from:hasShownSkill(self) then
				return -1
			end
			return 0
		end
	}
	return sgs.CreateDistanceSkill(mashu_skill)
end
mashu_MaChao_LB = sgs.CreateMashuSkill("MaChao_LB")
MaChao_LB:addSkill(mashu_MaChao_LB)

--[[
	技能名：铁骑
	技能：TieqiLB
	描述：当你使用【杀】指定一个目标后，你可以令你选择的其一张武将牌的非锁定技于此回合内无效，然后进行判定，令其选择一项：1. 弃置与结果花色相同的一张牌；2. 不能使用【闪】响应此【杀】。
	状态：验证通过
]]--
function SuperTieqiLBInvalidity(self, player, skill, isHas)  --isSkillValid函数
	return (player:getMark("SuperTieqiLB") == 0) or (skill:getFrequency() == sgs.Skill_Compulsory) or skill:isAttachedLordSkill() or table.contains(fake_attached_lord_skills, skill:objectName())
end
SuperTieqiLB = sgs.CreateTriggerSkill{  --for InvaliditySkill only
	name = "SuperTieqiLB",
}
TieqiLB = sgs.CreateTriggerSkill{
	name = "TieqiLB",
	can_preshow = true,
	events = {sgs.TargetChosen, sgs.FinishJudge},
	frequency = sgs.Skill_Frequent,
	on_record = function(self, event, room, player, data)
		if event == sgs.FinishJudge then
			local judge = data:toJudge()
			if judge.reason == self:objectName() then
				judge.pattern = judge.card:getSuitString()
			end
		end
	end,
	can_trigger = function(self, event, room, player, data)
		if (event == sgs.TargetChosen) and (player and player:isAlive() and player:hasSkill(self:objectName())) then
			local use = data:toCardUse()
			if not use.card or not use.from then return false end
			if player:objectName() ~= use.from:objectName() or not use.card:isKindOf("Slash") then return false end	
			local targets = {}
			for _, p in sgs.qlist(use.to) do
				table.insert(targets, p:objectName())
			end
			return self:objectName() .. "->" .. table.concat(targets,"+")	
		end
		return ""
	end	,
	on_cost = function(self, event, room, player, data, ask_who)
		local d = sgs.QVariant()
		d:setValue(player)
		if room:askForSkillInvoke(ask_who, self:objectName(), d) then
			room:broadcastSkillInvoke(self:objectName(), ask_who)
			return true
		end
		return false
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		local use = data:toCardUse()
		local jink_list = ask_who:getTag("Jink_"..use.card:toString()):toList()
		local index = use.to:indexOf(player)
		
		if player and player:isAlive() then  --如果目标存活
			local lord = room:getLord(ask_who:getKingdom())
			if lord and lord:hasLordSkill("shouyue") and lord:hasShownGeneral1() then
				if player:getMark("SuperTieqiLB") == 0 then
					room:notifySkillInvoked(lord, "shouyue")
					player:addMark("SuperTieqiLB")
					room:addPlayerMark(player, "@skill_invalidity")
					updateSkillValidity(sgs.Sanguosha:getSkill("SuperTieqiLB"), SuperTieqiLBInvalidity)
					local msg = sgs.LogMessage()
					msg.type = "#SuperTieqiLBInvalidity"
					msg.arg, msg.arg2 = self:objectName(), "shouyue"
					msg.to:append(player)
					room:sendLog(msg)
				end
			else
				player:addMark("TieqiLB")
				doNonCompulsoryInvalidity(ask_who, player, "TieqiLB")
				room:addPlayerMark(player, "@skill_invalidity")
			end
			
			local judge = sgs.JudgeStruct()
			judge.pattern = ".|.|."
			judge.reason = self:objectName()
			judge.who = ask_who
			judge.play_animation = false
			room:judge(judge)
			
			--local _data = sgs.QVariant()
			--_data:setValue(judge.card)
			--player:setTag("tieqicard", data)										--铁骑卡tag
			if ((player:isAlive() and not player:canDiscard(player, "he")) or not room:askForCard(player, ".|" .. judge.pattern, "@TieqiLB-discard:::" .. judge.pattern, --[[_data]]data, sgs.Card_MethodDiscard)) then			
				local log = sgs.LogMessage()
				log.type = "#NoJink"
				log.from = player
				room:sendLog(log)
				jink_list:replace(index,sgs.QVariant(0))
			end
		end
		--player:removeTag("tieqicard")
		ask_who:setTag("Jink_"..use.card:toString(), sgs.QVariant(jink_list))
	end,
}
TieqiLBClear = sgs.CreateTriggerSkill {
	name = "#TieqiLB-clear",
	events = {sgs.EventPhaseStart},
	priority = 8,
	global = true,
	on_record = function(self, event, room, player, data)
		if player:getPhase() ~= sgs.Player_NotActive then return false end
		for _,p in sgs.qlist(room:getAllPlayers()) do
			if p:getMark("SuperTieqiLB") > 0 then
				room:removePlayerMark(p, "@skill_invalidity")
				room:setPlayerMark(p, "SuperTieqiLB", 0)
				updateSkillValidity(sgs.Sanguosha:getSkill("SuperTieqiLB"), SuperTieqiLBInvalidity)
			end
			if p:getMark("TieqiLB") > 0 then
				for i = 1, p:getMark("TieqiLB") do
					room:removePlayerMark(p, "@skill_invalidity")
				end
				room:setPlayerMark(p, "TieqiLB", 0)
				
				clearNonCompulsoryInvalidity(player, p, "TieqiLB")
			end
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end
}
MaChao_LB:addSkill(TieqiLB)
MaChao_LB:addSkill(TieqiLBClear)
sgs.insertRelatedSkills(extensionLB, "TieqiLB", "#TieqiLB-clear")
local skillList = sgs.SkillList()
if not sgs.Sanguosha:getSkill("SuperTieqiLB") then skillList:append(SuperTieqiLB) end
sgs.Sanguosha:addSkills(skillList)

----------------------------------------------------------------------------------------------------

--[[ SHU 017 徐庶
	武将：XuShu_LB
	武将名：徐庶-界
	体力上限：(3)/4
	武将技能：
		诛害：其他角色的结束阶段开始时，若该角色于此回合内造成过伤害，你可以对其使用一张【杀】（无距离限制）。
		荐言：主将技，此武将牌上单独的阴阳鱼个数-1；出牌阶段限一次，你可以选择一种牌的类别或颜色，然后依次亮出牌堆顶的牌直到与你的选择相符，然后你令一名男性角色获得此牌，再将亮出的其余牌置入弃牌堆。
		潜心：副将技，当你使用【杀】对目标角色造成伤害后，若你已受伤，你可以摸一张牌，若如此做，你于此回合内不能使用或打出手牌。
	状态：验证通过
]]--
XuShu_LB = sgs.General(extensionLB, "XuShu_LB", "shu", 4, true)
XuShu_LB:addCompanion("wolong")
XuShu_LB:addCompanion("pangtong")

--[[
	技能名：诛害
	技能：Zhuhai
	描述：其他角色的结束阶段开始时，若该角色于此回合内造成过伤害，你可以对其使用一张【杀】（无距离限制）。
	状态：验证通过
]]--
ZhuhaiRecord = sgs.CreateTriggerSkill{
	name = "#Zhuhai-record",
	events = {sgs.DamageDone},
	global = true,
	on_record = function(self, event, room, player, data)
		local damage = data:toDamage()
		if damage.from and damage.from:getPhase() ~= sgs.Player_NotActive and not damage.from:hasFlag("ZhuhaiDamageInTurn") then
			damage.from:setFlags("ZhuhaiDamageInTurn")
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
Zhuhai = sgs.CreateTriggerSkill{
	name = "Zhuhai",  
	can_preshow = true,
	events = {sgs.EventPhaseStart, sgs.ChoiceMade},
	frequency = sgs.Skill_NotFrequent,
	on_record = function(self, event, room, player, data)  --此段代码是在发动技能后才执行的on_record，因此不用global
		if not (player and player:isAlive()) then return "" end
		if (event == sgs.ChoiceMade) and player:hasFlag("ZhuhaiSlash") then
			if data:toString() == "" then  --只能这样判断是否为CardUseStruct
				if data:toCardUse() and data:toCardUse().card and not data:toCardUse().card:isKindOf("HalberdCard") then  --todo：蛊惑
					player:setFlags("-ZhuhaiSlash")
					room:broadcastSkillInvoke(self:objectName(), player)
					room:notifySkillInvoked(player, self:objectName())
					local msg = sgs.LogMessage()
					msg.type, msg.from, msg.arg = "#InvokeSkill", player, self:objectName()
					room:sendLog(msg)
					if player:ownSkill(self:objectName()) and not player:hasShownSkill(self:objectName()) then
						player:showGeneral(player:inHeadSkills(self:objectName()))
					end
				end
			end
		end
	end,
	can_trigger = function(self, event, room, player, data)
		if event ~= sgs.EventPhaseStart then return "" end
		if player:isAlive() and (player:getPhase() == sgs.Player_Finish) and player:hasFlag("ZhuhaiDamageInTurn") then
			local skill_list, player_list = {}, {}
			for _, xushu in sgs.qlist(room:findPlayersBySkillName(self:objectName())) do
				if xushu and (xushu:objectName() ~= player:objectName()) and xushu:canSlash(player, false) then					
					table.insert(skill_list, self:objectName())
					table.insert(player_list, xushu:objectName())
				end
			end
			return table.concat(skill_list, "|"), table.concat(player_list, "|")
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		ask_who:setFlags("ZhuhaiSlash")
		if room:askForUseSlashTo(ask_who, player, "@Zhuhai-slash:" .. ask_who:objectName() .. ":" .. player:objectName(), false) then
			return true
		end
		ask_who:setFlags("-ZhuhaiSlash")
		return false
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		return false
	end,
}
XuShu_LB:addSkill(Zhuhai)
XuShu_LB:addSkill(ZhuhaiRecord)
sgs.insertRelatedSkills(extensionLB, "Zhuhai", "#Zhuhai-record")

--[[
	技能名：荐言
	技能：Jianyan
	描述：主将技，此武将牌上单独的阴阳鱼个数-1；出牌阶段限一次，你可以选择一种牌的类别或颜色，然后依次亮出牌堆顶的牌直到与你的选择相符，然后你令一名男性角色获得此牌，再将亮出的其余牌置入弃牌堆。
	状态：验证通过
]]--
JianyanCard = sgs.CreateSkillCard{
	name = "JianyanCard",
	skill_name = "Jianyan",
	target_fixed = true,
	on_use = function(self, room, source, targets)
		local choice_list = {"basic", "trick", "equip", "no_suit_red", "no_suit_black"}  --国战没有red和black的翻译
		local pattern_list = {"BasicCard", "TrickCard", "EquipCard", ".|red", ".|black"}
		local choice = room:askForChoice(source, "Jianyan", table.concat(choice_list, "+"))
		local pattern = pattern_list[table.indexOf(choice_list, choice)]
		local msg = sgs.LogMessage()
		msg.type, msg.from, msg.arg = "#JianyanChoice", source, choice
		room:sendLog(msg)
		
		local cardIds = sgs.IntList()
		while true do
			if room:getDrawPile():isEmpty() then
				local discard = room:getDiscardPile()
				if discard:isEmpty() then break end
				local have = false
				for _,id in sgs.qlist(discard) do
					if sgs.Sanguosha:matchExpPattern(pattern, nil, sgs.Sanguosha:getCard(id)) then
						have = true break
					end
				end
				room:swapPile()
				if not have then break end
			end
			local id = room:drawCard()
			cardIds:append(id)
			local move = sgs.CardsMoveStruct(id, nil, sgs.Player_PlaceTable, sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_TURNOVER, source:objectName(), "Jianyan", ""))
			room:moveCardsAtomic(move, true)
			room:getThread():delay()
			
			local card = sgs.Sanguosha:getCard(id)
			if sgs.Sanguosha:matchExpPattern(pattern, nil, card) then
				local males = sgs.SPlayerList()
				for _,p in sgs.qlist(room:getAlivePlayers()) do
					if p:isMale() then males:append(p) end
				end
				if not males:isEmpty() then
					local ids = sgs.IntList()
					ids:append(id)
					cardIds:removeOne(id)
					room:fillAG(ids, source)
					source:setMark("Jianyan", id)  --for AI
					local target = room:askForPlayerChosen(source, males, "Jianyan", "@Jianyan-give:::" .. card:objectName() .. ":" .. card:getSuitString() .. "_char\\" .. card:getNumberString())
					if target then
						room:clearAG(player)
						room:obtainCard(target, card)
					end
				end
				break
			end
		end
		if not cardIds:isEmpty() then
			local dummy = sgs.DummyCard(cardIds)
			local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_NATURAL_ENTER, source:objectName(), "Jianyan", "")
			room:throwCard(dummy, reason, nil)
			dummy:deleteLater()
		end
	end,
}
Jianyan = sgs.CreateZeroCardViewAsSkill{   
	name = "Jianyan",
	relate_to_place = "head",
	view_as = function(self)
		local skillcard = JianyanCard:clone()
		skillcard:setSkillName(self:objectName())
		skillcard:setShowSkill(self:objectName())
		return skillcard
	end,
	enabled_at_play = function(self, player)
		return not player:hasUsed("#JianyanCard")
	end, 
}
XuShu_LB:addSkill(Jianyan)
XuShu_LB:setHeadMaxHpAdjustedValue(-1)

--[[
	技能名：潜心
	技能：Qianxin
	描述：副将技，当你使用【杀】对目标角色造成伤害后，若你已受伤，你可以摸一张牌，若如此做，你于此回合内不能使用或打出手牌。
	状态：验证通过
]]--
Qianxin = sgs.CreateTriggerSkill{
	name = "Qianxin",
	relate_to_place = "deputy",
	can_preshow = true,
	frequency = sgs.Skill_Frequent,
	events = {sgs.Damage},
	can_trigger = function(self, event, room, player, data)
		if not (player and player:isAlive() and player:hasSkill(self:objectName())) then return "" end
		local damage = data:toDamage()
		if damage.card and damage.card:isKindOf("Slash") and (not damage.chain) and (not damage.transfer) and player:isWounded() then
			return self:objectName()
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		if player:askForSkillInvoke(self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), player)
			return true 
		end
		return false 
	end,
	on_effect = function(self, event, room, player, data)
		player:drawCards(1, self:objectName())
		room:addPlayerMark(player, "QianxinInvoke")
		room:setPlayerCardLimitation(player, "use,response", ".|.|.|hand", false)  --设为false是防止回合结束系统自动清了，导致在QianxinClear清空其他技能的$0
	end,
}
QianxinClear = sgs.CreateTriggerSkill{
	name = "#Qianxin-clear",
	events = {sgs.EventPhaseStart},
	priority = 8,
	on_record = function(self, event, room, player, data)
		if player:getPhase() ~= sgs.Player_NotActive then return false end
		for _,p in sgs.qlist(room:getAllPlayers()) do
			if p:getMark("QianxinInvoke") > 0 then
				for i = 1, p:getMark("QianxinInvoke") do
					room:removePlayerCardLimitation(p, "use,response", ".|.|.|hand$0")
				end
				room:setPlayerMark(p, "QianxinInvoke", 0)
			end
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end
}
XuShu_LB:addSkill(Qianxin)
XuShu_LB:addSkill(QianxinClear)
sgs.insertRelatedSkills(extensionLB, "Qianxin", "#Qianxin-clear")

----------------------------------------------------------------------------------------------------

--[[ WU 002 甘宁
	武将：GanNing_LB
	武将名：甘宁-界
	体力上限：4
	武将技能：
		奇袭：你可以将一张黑色牌当【过河拆桥】使用。 
		奋威：限定技，当一张锦囊牌指定至少两名目标后，你可以令此牌对至少一名目标角色无效。
	状态：验证通过
]]--
GanNing_LB = sgs.General(extensionLB, "GanNing_LB", "wu", 4, true, true)

--[[
	技能名：奇袭
	技能：qixi_GanNing_LB
	描述：你可以将一张黑色牌当【过河拆桥】使用。 
	状态：复制手册
]]--
function sgs.CreateQixiSkill(name)
	local qixi_skill = {
		name = "qixi_" .. name,
		response_or_use = true,
		view_filter = function(self, to_select)
			return to_select:isBlack()
		end,
		view_as = function(self,card)
			local dismantlement = sgs.Sanguosha:cloneCard("dismantlement", card:getSuit(), card:getNumber())
			dismantlement:addSubcard(card:getId())
			dismantlement:setSkillName(self:objectName())
			dismantlement:setShowSkill(self:objectName())
			return dismantlement
		end,
	}
	return sgs.CreateOneCardViewAsSkill(qixi_skill)
end
qixi_GanNing_LB = sgs.CreateQixiSkill("GanNing_LB")
GanNing_LB:addSkill(qixi_GanNing_LB)

--[[
	技能名：奋威
	技能：Fenwei
	描述：限定技，当一张锦囊牌指定至少两名目标后，你可以令此牌对至少一名目标角色无效。
	状态：验证通过
]]--
Fenwei = sgs.CreateTriggerSkill{
	name = "Fenwei", 
	can_preshow = true,
	frequency = sgs.Skill_Limited,
	limit_mark = "@fenwei",
	events = {sgs.TargetChosen},
	can_trigger = function(self, event, room, player, data)
		local use = data:toCardUse()
		if (getEffectiveTargetNum(use.to) <= 1) or not use.card:isKindOf("TrickCard") then return "" end
		local skill_list, player_list = {}, {}
		for _, ganning in sgs.qlist(room:findPlayersBySkillName(self:objectName())) do
			if ganning:getMark("@fenwei") > 0 then
				table.insert(skill_list, self:objectName())
				table.insert(player_list, ganning:objectName())
			end
		end
		return table.concat(skill_list, "|"), table.concat(player_list, "|")
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		local use = data:toCardUse()
		local to_choose = sgs.SPlayerList()
		for _, p in sgs.qlist(use.to) do
			if not to_choose:contains(p) then to_choose:append(p) end
		end
		ask_who:setTag("Fenwei", data)  --Now it's for AI only.
		local choices = room:askForPlayersChosen(ask_who, to_choose, self:objectName(), 0, to_choose:length(), "@Fenwei-card", true)
		ask_who:removeTag("Fenwei")
		if choices:length() > 0 then
			room:sortByActionOrder(choices)
			local choices_qvar = sgs.VariantList()
			for _,p in sgs.qlist(choices) do
				dat = sgs.QVariant()
				dat:setValue(p)
				choices_qvar:append(dat)
			end
			ask_who:setTag("Fenwei_invoke", sgs.QVariant(choices_qvar))
			room:broadcastSkillInvoke(self:objectName(), ask_who)
			room:doSuperLightbox("GanNing_LB", self:objectName())
			room:removePlayerMark(ask_who, "@fenwei")
			return true
		end
		return false
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		local targets_qvar = ask_who:getTag("Fenwei_invoke"):toList()
		ask_who:removeTag("Fenwei_invoke")
		local use = data:toCardUse()
		local nullified_list = use.nullified_list
		local target
		for _,target_qvar in sgs.qlist(targets_qvar) do
			target = target_qvar:toPlayer()
			if target then
				table.insert(nullified_list, target:objectName())
			end
		end
		use.nullified_list = nullified_list
		data:setValue(use)
	end,
	on_turn_broken = function(self, function_name, event, room, player, data, ask_who)
		player:removeTag("Fenwei_invoke")
	end
}
GanNing_LB:addSkill(Fenwei)

----------------------------------------------------------------------------------------------------

--[[ WU 003 吕蒙
	武将：LyuMeng_LB
	武将名：吕蒙-界
	体力上限：3
	武将技能：
		克己：若你未于出牌阶段内使用或打出【杀】，你可以跳过弃牌阶段。 
		攻心：出牌阶段限一次，你可以观看一名其他角色的手牌并可展示其中的一张红桃牌，然后选择一项：1. 弃置之；2. 将之置于牌堆顶。
	状态：复制手册
]]--
LyuMeng_LB = sgs.General(extensionLB, "LyuMeng_LB", "wu", 3, true, true)

--[[
	技能名：克己
	技能：keji_LyuMeng_LB
	描述：若你未于出牌阶段内使用或打出【杀】，你可以跳过弃牌阶段。
	状态：复制手册
]]--
function sgs.CreateKejiRecordSkill(name)
	local keji_record_skill = {
		name = "#keji-record_" .. name,
		events = {sgs.PreCardUsed, sgs.CardResponded},
		global = true,
		on_record = function(self, event, room, player, data)
			if not player or player:isDead() then return end
			local card
			if event == sgs.PreCardUsed then
				card = data:toCardUse().card
			elseif event == sgs.CardResponded then
				card = data:toCardResponse().m_card
			end
			if card and card:isKindOf("Slash") and player:getPhase() == sgs.Player_Play then
				player:setFlags("Keji" .. name .. "SlashInPlayPhase")
			end
		end,
		can_trigger = function(self, event, room, player, data)
			return ""
		end,
	}
	return sgs.CreateTriggerSkill(keji_record_skill)
end
kejiRecord_LyuMeng_LB = sgs.CreateKejiRecordSkill("LyuMeng_LB")
function sgs.CreateKejiSkill(name)
	local keji_skill = {
		name = "keji_" .. name,
		events = {sgs.EventPhaseChanging},
		frequency = sgs.Skill_Frequent,
		can_trigger = function(self, event, room, player, data)
			if not player or player:isDead() or not player:hasSkill(self:objectName()) then return false end
			local change = data:toPhaseChange()
			if not player:hasFlag("Keji" .. name .. "SlashInPlayPhase") and change.to == sgs.Player_Discard then
				return self:objectName()
			end
			return ""
		end,
		on_cost = function(self, event, room, player, data)
			if player:askForSkillInvoke(self:objectName()) then
				if player:getHandcardNum() > player:getMaxCards() then
					room:broadcastSkillInvoke(self:objectName(), player)
				end
				return true
			end
		end,
		on_effect = function(self, event, room, player, data)
			player:skip(sgs.Player_Discard)
		end,
	}
	return sgs.CreateTriggerSkill(keji_skill)
end
keji_LyuMeng_LB = sgs.CreateKejiSkill("LyuMeng_LB")
LyuMeng_LB:addSkill(keji_LyuMeng_LB)
LyuMeng_LB:addSkill(kejiRecord_LyuMeng_LB)
sgs.insertRelatedSkills(extensionLB, "keji_LyuMeng_LB", "#keji-record_LyuMeng_LB")

--[[
	技能名：攻心
	技能：Gongxin
	描述：出牌阶段限一次，你可以观看一名其他角色的手牌并可展示其中的一张红桃牌，然后选择一项：1. 弃置之；2. 将之置于牌堆顶。
	状态：复制手册
]]--
function sgs.CreateGongxinCard(name)
	local gongxin_card = {
		name = "Gongxin" .. name .. "Card",
		skill_name = "Gongxin_" .. name,
		target_fixed = false,
		will_throw = false,
		handling_method = sgs.Card_MethodNone,
		filter = function(self, targets, to_select, player)
			return #targets == 0 and to_select:objectName() ~= player:objectName() and not to_select:isKongcheng()
		end,
		on_use = function(self, room, source, targets)
			local target = targets[1]
			if not target:isKongcheng() then
				local ids = sgs.IntList()
				for _, card in sgs.qlist(target:getHandcards()) do
					if card:getSuit() == sgs.Card_Heart then
						ids:append(card:getEffectiveId())
					end
				end
				local card_id = room:doGongxin(source, target, ids, self:getSkillName())
				if card_id == -1 then return end
				room:showCard(target, card_id)
				
				--local dat = sgs.QVariant()
				--dat:setValue(target)
				--source:setTag("Gongxin", dat)  --这个Tag的添加写在了room::doGongxin里
				local operation = {"put"}
				if source:canDiscard(target, card_id) then table.insert(operation, "discard") end
				local result
				if #operation > 1 then
					result = room:askForChoice(source, self:getSkillName(), table.concat(operation, "+"))
				else
					result = operation[1]
				end
				source:removeTag(self:getSkillName())
				if result == "discard" then
					local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_DISMANTLE, source:objectName(), target:objectName(), self:getSkillName(), nil)
					room:throwCard(sgs.Sanguosha:getCard(card_id), reason, target, source)
				else
					source:setFlags("Global_GongxinOperator")
					local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_PUT, source:objectName(), target:objectName(), self:getSkillName(), nil)
					room:moveCardTo(sgs.Sanguosha:getCard(card_id), target, nil, sgs.Player_DrawPile, reason, true)
					source:setFlags("-Global_GongxinOperator")
				end
			end
		end,
	}
	return sgs.CreateSkillCard(gongxin_card)
end
GongxinCard_LyuMeng_LB = sgs.CreateGongxinCard("LyuMeng_LB")
function sgs.CreateGongxinSkill(name, skillcard)
	local gongxin_skill = {
		name = "Gongxin_" .. name,
		view_as = function(self)
			local card = skillcard:clone()
			card:setSkillName(self:objectName())
			card:setShowSkill(self:objectName())
			return card
		end,
		enabled_at_play = function(self, player)
			return not player:hasUsed("#" .. skillcard:objectName())
		end, 
	}
	return sgs.CreateZeroCardViewAsSkill(gongxin_skill)
end
Gongxin_LyuMeng_LB = sgs.CreateGongxinSkill("LyuMeng_LB", GongxinCard_LyuMeng_LB)
LyuMeng_LB:addSkill(Gongxin_LyuMeng_LB)

----------------------------------------------------------------------------------------------------

--[[ WU 004 黄盖
	武将：HuangGai_LB
	武将名：黄盖-界
	体力上限：4
	武将技能：
		苦肉：出牌阶段限一次，你可以弃置一张牌，失去1点体力。
		诈降：锁定技，当你失去1点体力后，你摸三张牌，然后若此时在你的出牌阶段内，你本回合使用红色【杀】无距离限制且目标角色不能使用【闪】响应你使用的红色【杀】，且你可以多使用一张【杀】。
	状态：复制原项目并调整
]]--
HuangGai_LB = sgs.General(extensionLB, "HuangGai_LB", "wu", 4, true, true)
HuangGai_LB:addCompanion("zhouyu")

--[[
	技能名：苦肉
	技能：KurouLB
	描述：出牌阶段限一次，你可以弃置一张牌，失去1点体力。
	状态：复制原项目
]]--
KurouLBCard = sgs.CreateSkillCard{
	name = "KurouLBCard",
	skill_name = "KurouLB",
	target_fixed = true,
	on_use = function(self, room, source)
		room:loseHp(source)
	end,
}
KurouLB = sgs.CreateOneCardViewAsSkill{
	name = "KurouLB",
	filter_pattern = ".!",
	view_as = function(self, originalCard)
		local card = KurouLBCard:clone()
		card:addSubcard(originalCard)
		card:setShowSkill(self:objectName())
		return card
	end,
	enabled_at_play = function(self, player)
		return not player:hasUsed("#KurouLBCard") and player:getHp() > 0 and player:canDiscard(player, "he")
	end
}
HuangGai_LB:addSkill(KurouLB)

--[[
	技能名：诈降
	技能：Zhaxiang
	描述：锁定技，当你失去1点体力后，你摸三张牌，然后若此时在你的出牌阶段内，你本回合使用红色【杀】无距离限制且目标角色不能使用【闪】响应你使用的红色【杀】，且你可以多使用一张【杀】。
	状态：复制原项目并调整
]]--
Zhaxiang = sgs.CreateTriggerSkill{
	name = "Zhaxiang",
	can_preshow = true,
	events = {sgs.HpLost},
	frequency = sgs.Skill_Compulsory,
	can_trigger = function(self, event, room, player, data)
		if not player or player:isDead() or not player:hasSkill(self) then return false end
		local skill_list = {}
		for i = 1, data:toInt() do
			table.insert(skill_list, self:objectName())
		end
		return table.concat(skill_list, ",")
	end	,
	on_cost = function(self, event, room, player, data)
		if player:hasShownSkill(self:objectName()) or player:askForSkillInvoke(self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), player)
			return true
		end
	end ,
	on_effect = function(self, event, room, player, data)
		room:sendCompulsoryTriggerLog(player, self:objectName(), true)
		player:drawCards(3, self:objectName())
		if player:getPhase() == sgs.Player_Play then
			room:addPlayerMark(player, self:objectName())
		end
	end,
}
ZhaxiangSlash = sgs.CreateTriggerSkill{
	name = "#Zhaxiang-slash",
	events = {sgs.SlashEffected},
	frequency = sgs.Skill_Compulsory,
	priority = 1,  --规则中诈降无时机，放在SlashEffected因为slash_effect.jink_num=0的判断是在此时机的GameRule
	can_trigger = function(self, event, room, player, data)
		local effect = data:toSlashEffect()
		if effect and effect.from and (effect.from:getMark("Zhaxiang") > 0) and effect.slash and effect.slash:isRed() then
			return self:objectName(), effect.from
		end
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		return true
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		local effect = data:toSlashEffect()
		effect.jink_num = 0
		data:setValue(effect)
		local log = sgs.LogMessage()
		log.type = "#NoJink"
		log.from = effect.to
		room:sendLog(log)
		return false
	end,
}
ZhaxiangClear = sgs.CreateTriggerSkill{
	name = "#Zhaxiang-clear",
	events = {sgs.EventPhaseStart},
	priority = 8,
	global = true,
	on_record = function(self, event, room, player, data)
		if player:getPhase() == sgs.Player_NotActive or player:getPhase() == sgs.Player_RoundStart then  --不太清楚源码RoundStart是什么鬼
			room:setPlayerMark(player, "Zhaxiang", 0)
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end	,
}
ZhaxiangTargetMod = sgs.CreateTargetModSkill{
	name = "#Zhaxiang-target",
	pattern = "Slash",
	distance_limit_func = function(self, from, card)
		if from:getMark("Zhaxiang") > 0 and card:isRed() then
			return 1000
		else
			return 0
		end
	end,
	residue_func = function(self, from, card)
		return from:getMark("Zhaxiang")
	end,
}
HuangGai_LB:addSkill(Zhaxiang)
HuangGai_LB:addSkill(ZhaxiangSlash)
HuangGai_LB:addSkill(ZhaxiangClear)
HuangGai_LB:addSkill(ZhaxiangTargetMod)
sgs.insertRelatedSkills(extensionLB, "Zhaxiang", "#Zhaxiang-slash", "#Zhaxiang-clear", "#Zhaxiang-target")

----------------------------------------------------------------------------------------------------

--[[ WU 005 周瑜
	武将：ZhouYu_LB
	武将名：周瑜-界
	体力上限：3
	武将技能：
		英姿：锁定技，摸牌阶段，你多摸一张牌；你的手牌上限为X（X为你的体力上限）。
		反间：出牌阶段限一次，你可以展示一张手牌并将之交给一名角色，令其选择一项：1. 展示所有手牌并弃置所有为此花色的牌；2. 失去1点体力。
	状态：验证通过
]]--
ZhouYu_LB = sgs.General(extensionLB, "ZhouYu_LB", "wu", 3, true, true)
ZhouYu_LB:addCompanion("huanggai")
ZhouYu_LB:addCompanion("xiaoqiao")
ZhouYu_LB:addCompanion("sunce")
ZhouYu_LB:addCompanion("HuangGai_LB")

--[[
	技能名：英姿
	技能：YingziLB
	描述：锁定技，摸牌阶段，你多摸一张牌；你的手牌上限为X（X为你的体力上限）。
	状态：复制原项目+手册
]]--
YingziLB = sgs.CreateDrawCardsSkill{
	name = "YingziLB",
	frequency = sgs.Skill_Compulsory,
	can_preshow = true,
	on_cost = function(self, event, room, player, data)
		if not player or player:isDead() or not player:hasSkill(self:objectName()) then return false end
		if player:hasShownSkill(self:objectName()) or player:askForSkillInvoke(self:objectName()) then
			room:broadcastSkillInvoke(self:objectName(), player)
			return true
		end
	end,
	draw_num_func = function(self, player, n)
		player:getRoom():sendCompulsoryTriggerLog(player, self:objectName(), true)
		return n + 1
	end,
}
YingziLBMaxCards = sgs.CreateMaxCardsSkill{
	name = "#YingziLB-maxcards",
	fixed_func = function(self, target)
		if target:hasShownSkill("YingziLB") then
			return target:getMaxHp()
		else
			return -1
		end
	end,
}
YingziLBShowMaxCards = sgs.CreateTriggerSkill{
	name = "#YingziLB-showmaxcards",
	can_preshow = true,
	frequency = sgs.Skill_Compulsory,  --因为此技能必须尚未亮将，所以不需要处理无法取消的问题
	events = {sgs.EventPhaseProceeding},
	can_trigger = function(self, event, room, player, data)
		if not player or player:isDead() or not player:hasSkill(self:objectName()) then return "" end
		if (player:getPhase() == sgs.Player_Discard) and not player:hasShownSkill(self:objectName()) then  --进入弃牌阶段询问是否发动英姿存牌
			if math.max(player:getHandcardNum() - player:getMaxCards(sgs.Max), 0) ~= math.max(player:getHandcardNum() - math.max(player:getMaxHp() + sgs.Sanguosha:correctMaxCards(player, false, sgs.Max), 0), 0) then   --需要影响到弃牌数才行
				return self:objectName()
			end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		if player:hasShownSkill(self:objectName()) or room:askForSkillInvoke(player, self:objectName(), sgs.QVariant("keep:::" .. player:getMaxHp())) then
			if player:ownSkill("YingziLB") and not player:hasShownSkill("YingziLB") then
				player:showGeneral(player:inHeadSkills("YingziLB"))
			end
			return true
		end
	end,
	on_effect = function(self, event, room, player, data)
		room:notifySkillInvoked(player, self:objectName())
	end,
}
ZhouYu_LB:addSkill(YingziLB)
ZhouYu_LB:addSkill(YingziLBMaxCards)
ZhouYu_LB:addSkill(YingziLBShowMaxCards)
sgs.insertRelatedSkills(extensionLB, "YingziLB", "#YingziLB-maxcards", "#YingziLB-showmaxcards")

--[[
	技能名：反间
	技能：FanjianLB
	描述：出牌阶段限一次，你可以展示一张手牌并将之交给一名角色，令其选择一项：1. 展示所有手牌并弃置所有为此花色的牌；2. 失去1点体力。
	状态：验证通过
]]--
FanjianLBCard = sgs.CreateSkillCard{
	name = "FanjianLBCard",
	skill_name = "FanjianLB",
	target_fixed = false,
	will_throw = false,
	extra_cost = function(self, room, card_use)
		local target = card_use.to:first()
		local suit = self:getSuit()
		room:setPlayerMark(target, "FanjianLBSuit", suit)
		room:showCard(card_use.from, self:getSubcards():first())
		local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_GIVE, card_use.from:objectName(), target:objectName(), "FanjianLB", "")
		room:obtainCard(target, self, reason)
	end,
	on_effect = function(self, effect)
		local source = effect.from
		local target = effect.to
		local room = source:getRoom()
		if not target:isAlive() then return end
		if target:isNude() then
			room:loseHp(target)
		else
			local suit = target:getMark("FanjianLBSuit")
			room:setPlayerMark(target, "FanjianLBSuit", 0)
			if room:askForSkillInvoke(target, "FanjianLB_discard", sgs.QVariant("prompt:::" .. sgs.Card_Suit2String(suit))) then
				room:showAllCards(target)
				local dummy = sgs.DummyCard()
				for _,card in sgs.qlist(target:getCards("he")) do
					if (card:getSuit() == suit) and target:canDiscard(target, card:getEffectiveId()) then
						dummy:addSubcard(card)
					end
				end
				if dummy:subcardsLength() > 0 then
					room:throwCard(dummy, target)
				end
				dummy:deleteLater()
			else
				room:loseHp(target)
			end
		end
	end
}
FanjianLB = sgs.CreateOneCardViewAsSkill{
	name = "FanjianLB",
	filter_pattern = ".|.|.|hand",
	view_as = function(self, originalCard)
		local card = FanjianLBCard:clone()
		card:addSubcard(originalCard)
		card:setShowSkill(self:objectName())
		return card
	end,
	enabled_at_play = function(self, player)
		return not player:hasUsed("#FanjianLBCard") and not player:isKongcheng()
	end
}
ZhouYu_LB:addSkill(FanjianLB)

----------------------------------------------------------------------------------------------------

--[[ WU 006 大乔
	武将：DaQiao_LB
	武将名：大乔-界
	体力上限：3
	武将技能：
		国色：出牌阶段限一次，你可以选择一项：1.将一张方块牌当【乐不思蜀】使用；2.弃置一张方块牌，弃置场上的一张【乐不思蜀】。若如此做，你摸一张牌。
		流离：每当你成为【杀】的目标时，你可以弃置一张牌并选择你攻击范围内的一名角色，将此【杀】转移给该角色。 
	状态：
]]--
DaQiao_LB = sgs.General(extensionLB, "DaQiao_LB", "wu", 3, false, true)
DaQiao_LB:addCompanion("xiaoqiao")
DaQiao_LB:addCompanion("sunce")

--[[
	技能名：国色
	技能：GuoseLB
	描述：出牌阶段限一次，你可以选择一项：1.将一张方块牌当【乐不思蜀】使用；2.弃置一张方块牌，弃置场上的一张【乐不思蜀】。若如此做，你摸一张牌。
	状态：
]]--
GuoseLBCard = sgs.CreateSkillCard {
	name = "GuoseLBCard",
	skill_name = "GuoseLB",
	handling_method = sgs.Card_MethodNone,
	filter = function(self, targets, to_select, player)
		if #targets == 0 then
			local targets2 = sgs.PlayerList()
			local card = sgs.Sanguosha:getCard(self:getSubcards():first())
			local indulgence = sgs.Sanguosha:cloneCard("indulgence", card:getSuit(), card:getNumber())
			indulgence:addSubcard(card)
			indulgence:setSkillName("GuoseLB")
			indulgence:deleteLater()
			
			local canUse = not player:isLocked(indulgence)
			if canUse and (to_select ~= player) and not to_select:containsTrick("indulgence") and not player:isProhibited(to_select, indulgence) then
				return true
			end
			local canDiscard = false
			for _,cd in sgs.qlist(player:getHandcards()) do
				if (cd:getEffectiveId() == card:getEffectiveId()) and not player:isJilei(card) then
					canDiscard = true
					break
				end
			end
			for _,cd in sgs.qlist(player:getEquips()) do
				if (cd:getEffectiveId() == card:getEffectiveId()) and not player:isJilei(card) then
					canDiscard = true
					break
				end
			end
			if not canDiscard or not to_select:containsTrick("indulgence") then return false end
			for _,cd in sgs.qlist(to_select:getJudgingArea()) do
				if cd:isKindOf("Indulgence") and player:canDiscard(to_select, cd:getEffectiveId()) then
					return true
				end
			end
		end
		return false
	end,
	on_validate = function(self, use)
		if not use.to:first():containsTrick("indulgence") then
			local card = sgs.Sanguosha:getCard(self:getSubcards():first())
			local indulgence = sgs.Sanguosha:cloneCard("indulgence", card:getSuit(), card:getNumber())
			indulgence:addSubcard(card)
			indulgence:setSkillName("GuoseLB")
			indulgence:setShowSkill("GuoseLB")
			return indulgence
		end
		return use.card
	end,
	about_to_use = function(self, room, cardUse)
		local use = cardUse
		
		local data = sgs.QVariant()
		data:setValue(use)
		local thread = room:getThread()
		thread:trigger(sgs.PreCardUsed, room, use.from, data)
		use = data:toCardUse()
		
		local msg = sgs.LogMessage()
		msg.from, msg.to, msg.type, msg.card_str = use.from, use.to, "#UseCard", use.card:toString()
		room:sendLog(msg)
		
		local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_THROW, use.from:objectName(), "", "GuoseLB", "")
		room:moveCardTo(self, use.from, nil, sgs.Player_DiscardPile, reason, true)
		
		thread:trigger(sgs.CardUsed, room, use.from, data)
		use = data:toCardUse()
		thread:trigger(sgs.CardFinished, room, use.from, data)
	end,
	on_effect = function(self, effect)
		local indulgence
		for _, card in sgs.qlist(effect.to:getJudgingArea()) do
			if card:isKindOf("Indulgence") and effect.from:canDiscard(effect.to, card:getEffectiveId()) then
				local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_DISMANTLE, effect.from:objectName(), nil, "GuoseLB", nil)
				effect.from:getRoom():throwCard(card, reason, nil, effect.from)
				effect.from:drawCards(1, "GuoseLB")
				return
			end
		end
	end,
}
GuoseLBVS = sgs.CreateOneCardViewAsSkill{
	name = "GuoseLB",
	filter_pattern = ".|diamond",
	response_or_use = true,
	view_as = function(self, originalCard)
		local card = GuoseLBCard:clone()
		card:addSubcard(originalCard)
		card:setSkillName(self:objectName())
		card:setShowSkill(self:objectName())
		return card
	end,
	enabled_at_play = function(self, player)
		return not player:hasUsed("#GuoseLBCard") and not (player:isNude() and player:getHandPile():isEmpty())
	end
}
GuoseLB = sgs.CreateTriggerSkill{
	name = "GuoseLB",
	can_preshow = false,
	events = {sgs.CardFinished},
	priority = 1,
	view_as_skill = GuoseLBVS,
	can_trigger = function(self, event, room, player, data)
		if not (player and player:isAlive()) then return "" end
		local use = data:toCardUse()
		if use.card:isKindOf("Indulgence") and (use.card:getSkillName() == self:objectName()) then
			return self:objectName()
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		return true
	end,
	on_effect = function(self, event, room, player, data)
		player:drawCards(1, self:objectName())
	end
}
DaQiao_LB:addSkill(GuoseLB)

--[[
	技能名：流离
	技能：liuli_DaQiao_LB
	描述：每当你成为【杀】的目标时，你可以弃置一张牌并选择你攻击范围内的一名角色，将此【杀】转移给该角色。 
	状态：复制手册
]]--
function sgs.CreateLiuliCard(name)
	local liuli_card = {
		name = "Liuli" .. name .. "Card" ,
		skill_name = "liuli_" .. name,
		filter = function(self, targets, to_select, player)
			if #targets > 0 then return false end
			if to_select:hasFlag("Liuli" .. name .. "SlashSource") or (to_select == player) then return false end
			local from
			for _, p in sgs.qlist(sgs.Self:getSiblings()) do
					if p:hasFlag("Liuli" .. name .. "SlashSource") then
						from = p
						break
					end
				end
			local slash = sgs.Card_Parse(sgs.Self:property("liuli_" .. name):toString())
			if from and (not from:canSlash(to_select, slash, false)) then return false end
			local card_id = self:getSubcards():first()
			local range_fix = 0
			if sgs.Self:getWeapon() and (sgs.Self:getWeapon():getId() == card_id) then
			local weapon = sgs.Self:getWeapon():getRealCard():toWeapon()
				range_fix = range_fix + weapon:getRange() - sgs.Self:getAttackRange(false)  --手册里的-1应该是bug
			elseif sgs.Self:getOffensiveHorse() and (sgs.Self:getOffensiveHorse():getId() == card_id) then
				range_fix = range_fix + 1
			end
			return sgs.Self:distanceTo(to_select, range_fix) <= sgs.Self:getAttackRange()
		end,
		on_effect = function(self, effect)
			effect.to:setFlags("Liuli" .. name .. "Target")
		end,
	}
	return sgs.CreateSkillCard(liuli_card)
end
LiuliCard_DaQiao_LB = sgs.CreateLiuliCard("DaQiao_LB")
function sgs.CreateLiuliVSSkill(name, skillcard)
	local liuli_vs_skill = {
		name = "liuli_" .. name,
		response_pattern = "@@liuli_" .. name,
		filter_pattern = ".!",
		view_as = function(self, card)
			local liuli_card = skillcard:clone()
			liuli_card:addSubcard(card)
			liuli_card:setSkillName(self:objectName())
			return liuli_card
		end,
	}
	return sgs.CreateOneCardViewAsSkill(liuli_vs_skill)
end
liuliVS_DaQiao_LB = sgs.CreateLiuliVSSkill("DaQiao_LB", LiuliCard_DaQiao_LB)
function sgs.CreateLiuliSkill(name, vs_skill)
	local liuli_skill = {
		name = "liuli_" .. name,
		events = {sgs.TargetConfirming} ,
		view_as_skill = vs_skill,
		can_preshow = true ,
		can_trigger = function(self, event, room, player, data)
			if not player or player:isDead() or not player:hasSkill(self:objectName()) then return false end
			local room = player:getRoom()
			local use = data:toCardUse()
			if use.card and use.card:isKindOf("Slash")
				and use.to:contains(player) and player:canDiscard(player,"he") then
				local players = room:getOtherPlayers(player)
				players:removeOne(use.from)
				local can_invoke = false
				for _, p in sgs.qlist(players) do
					if use.from:canSlash(p, use.card, false) and player:inMyAttackRange(p) then
						can_invoke = true
						break
					end
				end
				if can_invoke then return self:objectName() end
			end
		end,

		on_cost = function(self, event, room, player, data)
			local room = player:getRoom()
			local use = data:toCardUse()
			local prompt = "@liuli:" .. use.from:objectName()
			room:setPlayerFlag(use.from, "Liuli" .. name .. "SlashSource")
			d = sgs.QVariant()
			d:setValue(use.card)
			player:setTag("liuli_" .. name .. "-card", d)			--for the server (AI)		
			room:setPlayerProperty(player, "liuli_" .. name, sgs.QVariant(use.card:toString()))		--for the client (UI)		
			local c = room:askForUseCard(player, "@@liuli_" .. name, prompt, -1, sgs.Card_MethodDiscard)		
			player:removeTag("liuli_" .. name .. "-card")		
			room:setPlayerProperty(player, "liuli_" .. name, sgs.QVariant())
			room:setPlayerFlag(use.from, "-Liuli" .. name .. "SlashSource")		
			if c then return true end
			return false
		end,
			
		on_effect = function(self, event, room, player, data)
			local use = data:toCardUse()
			local players = room:getOtherPlayers(player)
			for _, p in sgs.qlist(players) do
				if p:hasFlag("Liuli" .. name .. "Target") then
					p:setFlags("-Liuli" .. name .. "Target")
					use.to:removeOne(player)
					use.to:append(p)
					room:sortByActionOrder(use.to)
					data:setValue(use)
					room:getThread():trigger(sgs.TargetConfirming, room, p, data)
					return false
				end
			end
			return false
		end,
	}
	return sgs.CreateTriggerSkill(liuli_skill)
end
liuli_DaQiao_LB = sgs.CreateLiuliSkill("DaQiao_LB", liuliVS_DaQiao_LB)
DaQiao_LB:addSkill(liuli_DaQiao_LB)

----------------------------------------------------------------------------------------------------

--[[ WU 007 陆逊
	武将：LuXun_LB
	武将名：陆逊-界
	体力上限：3
	武将技能：
		谦逊：当延时锦囊牌或其他角色使用的普通锦囊牌生效时，若你是此牌唯一的目标，你可以将所有手牌扣置于武将牌上，若如此做，当前回合结束后，你获得所有“谦逊牌”。
		连营：当你失去手牌后，若你没有手牌，你可以令一至X名角色各摸一张牌（X为你此次失去的手牌数）。
	状态：验证通过
]]--
LuXun_LB = sgs.General(extensionLB, "LuXun_LB", "wu", 3, true, true)

--[[
	技能名：谦逊
	技能：QianxunLB
	描述：当延时锦囊牌或其他角色使用的普通锦囊牌生效时，若你是此牌唯一的目标，你可以将所有手牌扣置于武将牌上，若如此做，当前回合结束后，你获得所有“谦逊牌”。
	状态：验证通过
]]--
QianxunLB = sgs.CreateTriggerSkill{
	name = "QianxunLB",
	frequency = sgs.Skill_NotFrequent,
	events = {sgs.CardEffectConfirmed},
	can_trigger = function(self, event, room, player, data)
		if not player or player:isDead() or not player:hasSkill(self:objectName()) then return false end		
		local effect = data:toCardEffect()
		if effect.card:getTypeId() == sgs.Card_TypeTrick and (effect.card:isKindOf("DelayedTrick") or effect.card:hasFlag("QianxunLBSingleTarget")) and not effect.to:isKongcheng() then
			return self:objectName()
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		if player:askForSkillInvoke(self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), player)
			player:setTag("QianxunLBEffectData", data)
			return true
		end
	end,
	on_effect = function(self, event, room, player, data)
		local effect = data:toCardEffect()
		local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_TRANSFER, player:objectName(), self:objectName(), "")
		local handcards = player:handCards()
		local open = sgs.SPlayerList()
		open:append(player)
		player:addToPile("QianxunLB", handcards, false, open, reason)
		player:removeTag("QianxunLBEffectData")
	end,
}
QianxunLBRecord = sgs.CreateTriggerSkill{
	name = "#QianxunLB-record",
	events = {sgs.TargetConfirmed},
	global = true,
	priority = -1,
	on_record = function(self, event, room, player, data)	
		local use = data:toCardUse()
		if use.card:isNDTrick() and (getEffectiveTargetNum(use.to) == 1) and (use.to:contains(player)) and use.from and (use.from:objectName() ~= player:objectName()) then
			room:setCardFlag(use.card, "QianxunLBSingleTarget")
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
QianxunLBReturn = sgs.CreateTriggerSkill{
	name = "#QianxunLB-return",
	frequency = sgs.Skill_Compulsory,
	events = {sgs.EventPhaseStart, sgs.EventLoseSkill},
	on_record = function(self, event, room, player, data)
		if event == sgs.EventLoseSkill and data:toString() == "QianxunLB" then
			player:clearOnePrivatePile("QianxunLB")
		end
	end,
	can_trigger = function(self, event, room, player, data)
		if (event == sgs.EventPhaseStart) and (player:getPhase() == sgs.Player_NotActive) then
			local skill_list, player_list = {}, {}
			for _, p in sgs.qlist(room:getAlivePlayers()) do
				if p:getPile("QianxunLB"):length() > 0 then
					table.insert(skill_list, self:objectName())
					table.insert(player_list, p:objectName())
				end
			end
			return table.concat(skill_list, "|"), table.concat(player_list, "|")
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		return true
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		if event == sgs.EventPhaseStart then
			local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_EXCHANGE_FROM_PILE, ask_who:objectName(), "QianxunLB", "")
			local dummy = sgs.DummyCard(ask_who:getPile("QianxunLB"))
			room:obtainCard(ask_who, dummy, reason, false)
			dummy:deleteLater()
		end
	end
}
QianxunLBClear = sgs.CreateTriggerSkill{
	name = "#QianxunLB-clear",
	events = {sgs.CardEffectConfirmed},
	priority = -1,
	global = true,
	on_record = function(self, event, room, player, data)
		local effect = data:toCardEffect()
		if effect.card and effect.card:hasFlag("QianxunLBSingleTarget") then
			room:setCardFlag(effect.card, "-QianxunLBSingleTarget")
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
LuXun_LB:addSkill(QianxunLB)
LuXun_LB:addSkill(QianxunLBRecord)
LuXun_LB:addSkill(QianxunLBReturn)
LuXun_LB:addSkill(QianxunLBClear)
sgs.insertRelatedSkills(extensionLB, "QianxunLB", "#QianxunLB-record", "#QianxunLB-return", "#QianxunLB-clear")

--[[
	技能名：连营
	技能：Lianying
	描述：当你失去手牌后，若你没有手牌，你可以令一至X名角色各摸一张牌（X为你此次失去的手牌数）。
	状态：验证通过
]]--
Lianying = sgs.CreateTriggerSkill{
	name = "Lianying", 
	can_preshow = true,
	events = {sgs.CardsMoveOneTime},
	can_trigger = function(self, event, room, player, data)
		if not player or player:isDead() or not player:hasSkill(self:objectName()) then return "" end
		local move = data:toMoveOneTime()
		if move.from and (move.from:objectName() == player:objectName()) and move.from_places:contains(sgs.Player_PlaceHand) and player:isKongcheng() then
			return self:objectName()
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		local move = data:toMoveOneTime()
		local count = 0
		for i, id in sgs.qlist(move.card_ids) do
			if move.from_places:at(i) == sgs.Player_PlaceHand then
				count = count + 1
			end
		end
		if count <= 0 then return false end
		
		player:setTag("LianyingMoveData", data)
		local choices = room:askForPlayersChosen(player, room:getAlivePlayers(), self:objectName(), 0, count, "@Lianying-card:::" .. count, true)
		player:removeTag("LianyingMoveData")
		if choices:length() > 0 then
			room:sortByActionOrder(choices)
			local choices_qvar = sgs.VariantList()
			for _,p in sgs.qlist(choices) do
				dat = sgs.QVariant()
				dat:setValue(p)
				choices_qvar:append(dat)
			end
			player:setTag("Lianying_invoke", sgs.QVariant(choices_qvar))
			room:broadcastSkillInvoke(self:objectName(), player)
			return true
		end
		return false
	end,
	on_effect = function(self, event, room, player, data)
		local targets_qvar = player:getTag("Lianying_invoke"):toList()
		player:removeTag("Lianying_invoke")
		local target
		for _,target_qvar in sgs.qlist(targets_qvar) do
			target = target_qvar:toPlayer()
			if target then
				room:drawCards(target, 1, self:objectName())
			end
		end
	end,
	on_turn_broken = function(self, function_name, event, room, player, data, ask_who)
		player:removeTag("Lianying_invoke")
	end
}
LuXun_LB:addSkill(Lianying)

----------------------------------------------------------------------------------------------------

--[[ QUN 001 华佗
	武将：HuaTuo_LB
	武将名：华佗-界
	体力上限：3
	武将技能：
		除疠：出牌阶段限一次，若你有牌，你可以选择至少一名势力各不相同的有牌的其他角色，弃置你和这些角色的各一张牌，然后以此法被弃置黑桃牌的角色各摸一张牌。
		急救：你于回合外可以将一张红色牌当【桃】使用。
	状态：验证通过
]]--
HuaTuo_LB = sgs.General(extensionLB, "HuaTuo_LB", "qun", 3, true, true)

--[[
	技能名：除疠
	技能：Chuli
	描述：出牌阶段限一次，若你有牌，你可以选择至少一名势力各不相同的有牌的其他角色，弃置你和这些角色的各一张牌，然后以此法被弃置黑桃牌的角色各摸一张牌。
	状态：复制原手册并改
]]--
ChuliCard = sgs.CreateSkillCard{
	name = "ChuliCard",
	skill_name = "Chuli",
	filter = function(self,selected,to_select,player)
		if to_select:objectName() == player:objectName() then return false end
		if not to_select:hasShownOneGeneral() or to_select:isNude() then return false end
		if #selected > 0 then
			for _, p in ipairs(selected) do
				if to_select:isFriendWith(p) then return false end
			end
		end
		return true
	end,
	feasible = function(self,targets)
		if #targets == 0 then return false end
		for _, p in ipairs(targets) do
			for _, other in ipairs(targets) do
				if (p:objectName() ~= other:objectName()) and p:isFriendWith(other) then return false end
			end
		end
		return true
	end,
	on_use = function(self, room, source, targets)
		local targetlist = targetsTable2QSPList(targets)
		targetlist:append(source)
		room:sortByActionOrder(targetlist)
		local players = sgs.SPlayerList()
		for _, p in sgs.qlist(targetlist) do
			if not p:isAlive() or not source:isAlive() or not source:canDiscard(p, "he") then continue end
			if p:objectName() == source:objectName() then
				local card = room:askForCard(source, "..!", "@ChuliSelfDiscard", sgs.QVariant())  --remark：askForCard里！是compulsory
				if card:getSuit() == sgs.Card_Spade then players:append(source) end
			else
				local card_id = room:askForCardChosen(source, p, "he", "Chuli", false, sgs.Card_MethodDiscard)
				if sgs.Sanguosha:getCard(card_id):getSuit() == sgs.Card_Spade then
					players:append(p)
				end
				local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_DISMANTLE, source:objectName(), p:objectName(), "Chuli", nil)
				room:throwCard(sgs.Sanguosha:getCard(card_id), reason, p, source)
			end
		end
		for _, p in sgs.qlist(players) do
			if p:isAlive() then p:drawCards(1) end
		end
	end,
}
Chuli = sgs.CreateZeroCardViewAsSkill{   
	name = "Chuli",
	view_as = function(self)  --改成0牌视为技是因为可能有半体力摸牌、珠联璧合啥的
		local card = ChuliCard:clone()
		card:setShowSkill(self:objectName())
		return card
	end,
	enabled_at_play = function(self, player)
		return not player:isNude() and not player:hasUsed("#ChuliCard")
	end
}
HuaTuo_LB:addSkill(Chuli)

--[[
	技能名：急救
	技能：jijiu_HuaTuo_LB
	描述：你于回合外可以将一张红色牌当【桃】使用。
	状态：复制手册
]]--
function sgs.CreateJijiuSkill(name)
	local jijiu_skill = {
		name = "jijiu_" .. name,
		filter_pattern = ".|red",
		response_or_use = true,
		enabled_at_play = function(self)
			return false
		end,
		enabled_at_response = function(self,player,pattern)
			return pattern:match("peach") and not player:hasFlag("Global_PreventPeach") and player:getPhase() == sgs.Player_NotActive
		end,
		view_as = function(self,ocard)
			local peach = sgs.Sanguosha:cloneCard("peach",ocard:getSuit(), ocard:getNumber())
			peach:addSubcard(ocard:getId())
			peach:setSkillName(self:objectName())
			peach:setShowSkill(self:objectName())
			return peach
		end
	}
	return sgs.CreateOneCardViewAsSkill(jijiu_skill)
end
jijiu_HuaTuo_LB = sgs.CreateJijiuSkill("HuaTuo_LB")
HuaTuo_LB:addSkill(jijiu_HuaTuo_LB)

----------------------------------------------------------------------------------------------------

--[[ QUN 002 吕布
	武将：LyuBu_LB
	武将名：吕布-界
	体力上限：5
	武将技能：
		无双：锁定技，每当你使用【杀】指定一个目标后，你将其抵消此【杀】的方式改为依次使用两张【闪】；锁定技，每当你使用【决斗】指定一个目标后，或成为一名角色使用【决斗】的目标后，你将其执行此【决斗】中打出【杀】的效果改为依次打出两张【杀】。
		利驭：当你使用的【杀】对一名其他角色造成伤害后，该角色可以令你获得其一张牌，若如此做，你视为对其选择的另一名角色使用一张【决斗】。
	状态：验证通过
]]--
LyuBu_LB = sgs.General(extensionLB, "LyuBu_LB", "qun", 5, true, true)
LyuBu_LB:addCompanion("diaochan")

--[[
	技能名：无双
	技能：wushuang_LyuBu_LB
	描述：锁定技，每当你使用【杀】指定一个目标后，你将其抵消此【杀】的方式改为依次使用两张【闪】；锁定技，每当你使用【决斗】指定一个目标后，或成为一名角色使用【决斗】的目标后，你将其执行此【决斗】中打出【杀】的效果改为依次打出两张【杀】。
	状态：复制手册
]]--
function sgs.CreateWushuangSkill(name)
	local wushuang_skill = {
		name = "wushuang_" .. name,
		events = {sgs.TargetChosen,sgs.TargetConfirmed,sgs.CardFinished},
		frequency = sgs.Skill_Compulsory,

		can_trigger = function(self,event,room,player,data)
			if not player then return false end
			local use = data:toCardUse()
			if event == sgs.TargetChosen then
				if use.card and (use.card:isKindOf("Slash") or use.card:isKindOf("Duel")) then
					if player:isAlive() and player:hasSkill(self:objectName()) then
						local targets = {}
						for _, p in sgs.qlist(use.to) do
							table.insert(targets, p:objectName())
						end
						if #targets > 0 then return self:objectName() .. "->" .. table.concat(targets,"+") end
					end
				end
			elseif event == sgs.TargetConfirmed then
				if not use.to:contains(player) then return false end
				if use.card and use.card:isKindOf("Duel") and player:isAlive() and player:hasSkill(self:objectName()) then
					return self:objectName() .. "->" .. use.from:objectName()
				end
			elseif event == sgs.CardFinished then
				if use.card:isKindOf("Duel") then
					for _, lvbu in sgs.qlist(room:getAllPlayers()) do
						if lvbu:getMark("WushuangTarget") > 0 then
							room:setPlayerMark(lvbu, "WushuangTarget", 0)
						end
					end
				end
			end
			return ""
		end,
		on_cost = function(self,event,room,target,data,ask_who)
			ask_who:setTag("WushuangData",data)			--for AI
			local d = sgs.QVariant()
			d:setValue(target)
			ask_who:setTag("WushuangTarget",d)			--for AI
			local invoke = ask_who:hasShownSkill(self:objectName()) or ask_who:askForSkillInvoke(self:objectName(), d)
			ask_who:removeTag("WushuangData")
			if invoke then
				room:broadcastSkillInvoke(self:objectName(), ask_who)
				return true
			end
		end,
		
		on_effect = function(self,event,room,target,data,ask_who)
			room:sendCompulsoryTriggerLog(ask_who, self:objectName(),true)
			local use = data:toCardUse()
			if use.card:isKindOf("Slash") then
				if event ~= sgs.TargetChosen then return false end
				local x = use.to:indexOf(target)
				local jink_list = ask_who:getTag("Jink_" .. use.card:toString()):toList()
				if (jink_list:at(x):toInt() == 1) then
					jink_list:replace(x,sgs.QVariant(2))
				end
				ask_who:setTag("Jink_" .. use.card:toString(),sgs.QVariant(jink_list))
			elseif use.card:isKindOf("Duel") then
				room:setPlayerMark(ask_who, "WushuangTarget", 1)
			end
		end,
	}
	return sgs.CreateTriggerSkill(wushuang_skill)
end
wushuang_LyuBu_LB = sgs.CreateWushuangSkill("LyuBu_LB")
LyuBu_LB:addSkill(wushuang_LyuBu_LB)

--[[
	技能名：利驭
	技能：Liyu
	描述：当你使用的【杀】对一名其他角色造成伤害后，该角色可以令你获得其一张牌，若如此做，你视为对其选择的另一名角色使用一张【决斗】。
	状态：验证通过
]]--
Liyu = sgs.CreateTriggerSkill{
	name = "Liyu",
	can_preshow = false,
	frequency = sgs.Skill_NotFrequent,
	events = {sgs.Damage},
	can_trigger = function(self, event, room, player, data)
		if not (player and player:isAlive() and player:hasShownSkill(self:objectName())) then return "" end
		local damage = data:toDamage()
		if damage.card and damage.card:isKindOf("Slash") and damage.to:isAlive() and (player:objectName() ~= damage.to:objectName()) and (not damage.to:hasFlag("Global_DebutFlag")) --[[and player:canGetCard(damage.to, "he")]] and not damage.to:isNude() then
			return --[[player:objectName() .. "!" .. ]]self:objectName(), damage.to:objectName()  --源码bug
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		if ask_who:askForSkillInvoke(self:objectName(), sgs.QVariant("Liyu_invoke:" .. player:objectName())) then
			room:broadcastSkillInvoke(self:objectName(), player)
			room:notifySkillInvoked(player, self:objectName())
			local msg = sgs.LogMessage()
			msg.type, msg.from, msg.arg = "#InvokeOthersSkill", ask_who, self:objectName()
			msg.to:append(player)
			room:sendLog(msg)
			
			local id = room:askForCardChosen(player, ask_who, "he", self:objectName())
			room:obtainCard(player, sgs.Sanguosha:getCard(id), sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_EXTRACTION, player:objectName(), self:objectName(), ""), false)
			return true 
		end
		return false 
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		local duel = sgs.Sanguosha:cloneCard("duel", sgs.Card_NoSuit, 0)
		duel:setSkillName("_Liyu")
		if player:isDead() or player:isLocked(duel) or ask_who:isDead() then return end
		local targets = sgs.SPlayerList()
		for _,p in sgs.qlist(room:getOtherPlayers(player)) do
			if (p:objectName() ~= ask_who:objectName()) and duel:targetFilter(sgs.PlayerList(), p, player) then
				targets:append(p)
			end
		end
		if targets:isEmpty() then
			duel:deleteLater()
			return
		end
		local target = room:askForPlayerChosen(ask_who, targets, self:objectName(), "@Liyu" .. player:objectName())
		if target then
			room:useCard(sgs.CardUseStruct(duel, player, target))
		else
			duel:deleteLater()
		end
	end,
}
LyuBu_LB:addSkill(Liyu)

----------------------------------------------------------------------------------------------------

--[[ QUN 026 公孙瓒
	武将：GongSunZan
	武将名：公孙瓒
	体力上限：4
	武将技能：
		趫猛：当你使用的黑色【杀】对一名角色造成伤害后，你可以弃置其装备区的一张牌，当此牌置入弃牌堆后，若此牌为坐骑牌，你获得之。
		义从：锁定技，若你的体力值大于2，你与其他角色的距离-1；若你的体力值不大于2，其他角色与你的距离+1。
	状态：验证通过
]]--
GongSunZan = sgs.General(extensionLB, "GongSunZan", "qun", 4, true)

--[[
	技能名：趫猛
	技能：Qiaomeng
	描述：当你使用的黑色【杀】对一名角色造成伤害后，你可以弃置其装备区的一张牌，当此牌置入弃牌堆后，若此牌为坐骑牌，你获得之。
	状态：验证通过
]]--
Qiaomeng = sgs.CreateTriggerSkill{
	name = "Qiaomeng",
	can_preshow = true,
	frequency = sgs.Skill_Frequent,
	events = {sgs.Damage},
	can_trigger = function(self, event, room, player, data)
		if not (player and player:isAlive() and player:hasSkill(self:objectName())) then return "" end
		local damage = data:toDamage()
		if damage.card and damage.card:isKindOf("Slash") and damage.card:isBlack() and damage.to:isAlive() and (not damage.to:hasFlag("Global_DebutFlag")) and player:canDiscard(damage.to, "e") then
			return self:objectName() .. "->" .. damage.to:objectName()
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		if ask_who:askForSkillInvoke(self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), ask_who)
			return true 
		end
		return false 
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		local damage = data:toDamage()
		if not ask_who:canDiscard(damage.to, "e") then return end
		local id = room:askForCardChosen(ask_who, damage.to, "e", self:objectName(), false, sgs.Card_MethodDiscard)
		local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_DISMANTLE, ask_who:objectName(), damage.to:objectName(), self:objectName(), "")
		room:throwCard(sgs.Sanguosha:getCard(id), reason, damage.to, ask_who)
		return false 
	end,
}
QiaomengObtain = sgs.CreateTriggerSkill{
	name = "#Qiaomeng-obtain",
	can_preshow = true,
	frequency = sgs.Skill_Compulsory,
	events = {sgs.CardsMoveOneTime},
	can_trigger = function(self, event, room, player, data)
		if not player or player:isDead() then return "" end
		local move = data:toMoveOneTime()
		if (move.reason.m_skillName == "Qiaomeng") and (move.reason.m_playerId == player:objectName()) and (move.card_ids:length() > 0) then
			local card = sgs.Sanguosha:getCard(move.card_ids:first())
			if card:isKindOf("Horse") and (room:getCardPlace(move.card_ids:first()) == sgs.Player_DiscardPile) then
				return self:objectName()
			end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		return true
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		local move = data:toMoveOneTime()
		local card = sgs.Sanguosha:getCard(move.card_ids:first())
		room:obtainCard(player, card)
		return false 
	end,
}
GongSunZan:addSkill(Qiaomeng)
GongSunZan:addSkill(QiaomengObtain)
sgs.insertRelatedSkills(extensionLB, "Qiaomeng", "#Qiaomeng-obtain")

--[[
	技能名：义从
	技能：YicongGongSunZan
	描述：锁定技，若你的体力值大于2，你与其他角色的距离-1；若你的体力值不大于2，其他角色与你的距离+1。
	状态：验证通过（部分复制原项目）
]]--
function sgs.CreateYicongSkill(name, to_place)
	local yicong_skill = {
		name = "Yicong" .. name,
		can_preshow = true,
		relate_to_place = to_place,
		events = {sgs.HpChanged},
		frequency = sgs.Skill_Compulsory,
		can_trigger = function(self, event, room, player, data)
			if not player or player:isDead() or not player:hasSkill(self:objectName()) then return "" end
			if player:hasShownSkill(self:objectName()) then return "" end
			local hp = player:getHp()
			local mark = player:getMark("Yicong" .. name .. "Change")
			local event = player:getTag("Yicong" .. name .. "Event"):toString()
			if (event == "recover") and (hp > 2) and (hp - mark <= 2) then
				return self:objectName()
			elseif (event == "lost") and (hp <= 2) and (hp + mark > 2) then
				return self:objectName()
			end
			return ""
		end,
		on_cost = function(self, event, room, player, data)
			local event = player:getTag("Yicong" .. name .. "Event"):toString()
			if room:askForSkillInvoke(player, self:objectName(), sgs.QVariant((event == "recover") and "attack" or "defend")) then
				return true
			end
		end,
		on_effect = function(self, event, room, player, data)
			return false
		end
	}
	return sgs.CreateTriggerSkill(yicong_skill)
end
YicongGongSunZan = sgs.CreateYicongSkill("GongSunZan", nil)
function sgs.CreateYicongRecordSkill(name)  
	local yicong_record_skill = {
		name = "#Yicong" .. name .. "-record",
		events = {sgs.PreHpRecover, sgs.PreHpLost, sgs.PreDamageDone},
		global = true,  --因此不能relate_to_place（对所有玩家都发动）
		on_record = function(self, event, room, player, data)
			player:setTag("Yicong" .. name .. "Event", sgs.QVariant((event == sgs.PreHpRecover) and "recover" or "lost"))
			local int = 0
			if event == sgs.PreHpRecover then
				int = data:toRecover().recover
			else
				int = (event == sgs.PreHpLost) and data:toInt() or data:toDamage().damage
			end
			room:setPlayerMark(player, "Yicong" .. name .. "Change", int)
		end,
		can_trigger = function(self, event, room, player, data)
			return ""
		end,
	}
	return sgs.CreateTriggerSkill(yicong_record_skill)
end
YicongGongSunZanRecord = sgs.CreateYicongRecordSkill("GongSunZan")
function sgs.CreateYicongDistSkill(name, to_place)
	local yicong_skill = {
		name = "#Yicong" .. name .. "-dist",  --不算做一个技能，因为描述不同
		relate_to_place = to_place,  --JSP赵云
		correct_func = function(self, from, to)
			local result = 0
			if from:hasSkill(self:objectName()) and from:hasShownSkill(self) and (from:getHp() > 2) then  --其实可以将两个义从合并处理，但是对副将技的处理略麻烦所以没改
				result = result - 1
			end
			if to:hasSkill(self:objectName()) and to:hasShownSkill(self) and (to:getHp() <= 2) then
				result = result + 1
			end
			return result
		end
	}
	return sgs.CreateDistanceSkill(yicong_skill)
end
YicongGongSunZanDist = sgs.CreateYicongDistSkill("GongSunZan", nil)
function sgs.CreateYicongAudioSkill(name, to_place)
	local yicong_audio_skill = {
		name = "#Yicong" .. name .. "-audio",
		relate_to_place = to_place,
		events = {sgs.HpChanged},  --音效及清Mark
		priority = 1,
		global = true,
		on_record = function(self, event, room, player, data)
			if not player or player:isDead() then return end
			local hp = player:getHp()
			local mark = player:getMark("Yicong" .. name .. "Change")
			room:setPlayerMark(player, "Yicong" .. name .. "Change", 0)
			local event = player:getTag("Yicong" .. name .. "Event"):toString()
			player:removeTag("Yicong" .. name .. "Event")
			if not player:hasShownSkill("Yicong" .. name) then return end
			if (event == "recover") and (hp > 2) and (hp - mark <= 2) then
				room:broadcastSkillInvoke("Yicong" .. name, 1, player)
				room:notifySkillInvoked(player, "Yicong" .. name)
			elseif (event == "lost") and (hp <= 2) and (hp + mark > 2) then
				room:broadcastSkillInvoke("Yicong" .. name, 2, player)
				room:notifySkillInvoked(player, "Yicong" .. name)
			end
		end
	}
	return sgs.CreateTriggerSkill(yicong_audio_skill)
end
YicongGongSunZanAudio = sgs.CreateYicongAudioSkill("GongSunZan", nil)
GongSunZan:addSkill(YicongGongSunZan)
GongSunZan:addSkill(YicongGongSunZanRecord)
GongSunZan:addSkill(YicongGongSunZanDist)
GongSunZan:addSkill(YicongGongSunZanAudio)
sgs.insertRelatedSkills(extensionLB, "YicongGongSunZan", "#YicongGongSunZan-record", "#YicongGongSunZan-dist", "#YicongGongSunZan-audio")

---------------------------------------------神话再临·界--------------------------------------------

extensionLegendLB = sgs.Package("LegendLB", sgs.Package_GeneralPack)

--[[ SHU 008 黄忠
	武将：HuangZhong_LB
	武将名：黄忠-界
	体力上限：4
	武将技能：
		烈弓：你使用【杀】可以选择距离不大于此【杀】点数的角色为目标；当你使用【杀】指定一个目标后，你可以根据下列条件执行相应的效果：1. 若其手牌数不大于你，你可以令其不能使用【闪】响应此【杀】；2. 若其体力值不小于你，你可以令此【杀】对其造成的伤害+1。
	状态：验证通过
]]--
HuangZhong_LB = sgs.General(extensionLegendLB, "HuangZhong_LB", "shu", 4, true, true)
HuangZhong_LB:addCompanion("weiyan")

--[[
	技能名：烈弓
	技能：LiegongLB
	描述：你使用【杀】可以选择距离不大于此【杀】点数的角色为目标；当你使用【杀】指定一个目标后，你可以根据下列条件执行相应的效果：1. 若其手牌数不大于你，你可以令其不能使用【闪】响应此【杀】；2. 若其体力值不小于你，你可以令此【杀】对其造成的伤害+1。
	状态：验证通过
]]--
LiegongLB = sgs.CreateTriggerSkill{
	name = "LiegongLB",
	events = {sgs.TargetChosen},
	frequency = sgs.Skill_Frequent,
	can_trigger = function(self, event, room, player, data)
		if not player or player:isDead() or not player:hasSkill(self) then return false end
		local use = data:toCardUse()
		if use.card and use.card:isKindOf("Slash") then
			local targets = {}
			for _, p in sgs.qlist(use.to) do
				if p:getHandcardNum() <= player:getHandcardNum() or p:getHp() >= player:getHp() then
					table.insert(targets, p:objectName())
				end
			end
			if #targets > 0 then
				return self:objectName() .. "->" .. table.concat(targets, "+")
			end
		end
		return ""
	end	,
	on_cost = function(self, event, room, player, data, ask_who)
		local d = sgs.QVariant()
		d:setValue(player)
		if room:askForSkillInvoke(ask_who, self:objectName(), d) then
			room:broadcastSkillInvoke(self:objectName(), 1, ask_who)
			return true
		end
		return false
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		local use = data:toCardUse()
		local choices, cancelable, choices_done = {}, false, {}
		repeat
			choices = {}
			if player:getHandcardNum() <= ask_who:getHandcardNum() and not choices_done["noJink"] then
				table.insert(choices, "noJink")
			end
			if player:getHp() >= ask_who:getHp() and not choices_done["damage"] then
				table.insert(choices, "damage")
			end
			if cancelable then table.insert(choices, "cancel") end
			if (#choices == 0) or (#choices == 1 and choices[1] == "cancel") then return false end
			
			local choice = room:askForChoice(ask_who, self:objectName(), table.concat(choices, "+"))
			if choice == "cancel" then return false end
			choices_done[choice] = true
			if choice == "noJink" then
				local jink_list = ask_who:getTag("Jink_"..use.card:toString()):toList()
				local log = sgs.LogMessage()
				log.type = "#NoJink"
				log.from = player
				room:sendLog(log)
				local index = use.to:indexOf(player)
				jink_list:replace(index, sgs.QVariant(0))
				ask_who:setTag("Jink_" .. use.card:toString(), sgs.QVariant(jink_list))
			elseif choice == "damage" then
				local msg = sgs.LogMessage()
				if use.card:isVirtualCard() then
					msg.type, msg.from = "#LiegongLBInvoke", ask_who
					msg.arg = use.card:objectName()
				else
					msg.type, msg.from = "$LiegongLBInvoke", ask_who
					msg.card_str = use.card:toString()
				end
				msg.to:append(player)
				room:sendLog(msg)
				local tag = room:getTag("LiegongLBAddDamage" .. use.card:toString() .. player:objectName()):toInt()
				if tag then
					tag = tag + 1
				else
					tag = 1
				end
				room:setTag("LiegongLBAddDamage" .. use.card:toString() .. player:objectName(), sgs.QVariant(tag))
			end
			cancelable = true
		until #choices == 0
		return false
	end,
}
LiegongLBAddDamage = sgs.CreateTriggerSkill{
	name = "#LiegongLB-adddamage", 
	events = {sgs.ConfirmDamage, sgs.CardFinished},
	frequency = sgs.Skill_Wake,
	global = true,
	on_record = function(self, event, room, player, data)
		if event == sgs.CardFinished then
			local use = data:toCardUse()
			for _,p in sgs.qlist(room:getAllPlayers(true)) do
				if room:getTag("LiegongLBAddDamage" .. use.card:toString() .. p:objectName()) and (room:getTag("LiegongLBAddDamage" .. use.card:toString() .. p:objectName()):toInt() > 0) then
					room:removeTag("LiegongLBAddDamage" .. use.card:toString() .. p:objectName())
				end
			end
		end
	end,
	can_trigger = function(self, event, room, player, data)
		if event == sgs.ConfirmDamage then
			local damage = data:toDamage()
			if damage.card and damage.from then
				if room:getTag("LiegongLBAddDamage" .. damage.card:toString() .. damage.to:objectName()):toInt() then
					local x = room:getTag("LiegongLBAddDamage" .. damage.card:toString() .. damage.to:objectName()):toInt()
					if x <= 0 then return "" end
					return self:objectName() .. "->" .. damage.to:objectName()
				end
			end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		return true
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		local damage = data:toDamage()
		local x = room:getTag("LiegongLBAddDamage" .. damage.card:toString() .. damage.to:objectName()):toInt()
		local msg = sgs.LogMessage()
		msg.type, msg.from, msg.arg, msg.arg2 = "#LiegongLBBuff", ask_who, damage.damage, damage.damage + x
		room:sendLog(msg)
		damage.damage = damage.damage + x
		data:setValue(damage)
		room:removeTag("LiegongLBAddDamage" .. damage.card:toString() .. damage.to:objectName())
	end,
}
LiegongLBTargetMod = sgs.CreateTargetModSkill{
	name = "#LiegongLB-target",
	distance_limit_func = function(self, from, card)
		if from:hasSkill("LiegongLB") and not (card:isVirtualCard() and card:subcardsLength() ~= 1) then
			local number = card:getNumber()
			local targetFilter_rangefix = 0  --Slash::targetFilter
			if from:getWeapon() and card:getSubcards():contains(from:getWeapon():getId()) then
				local weapon = from:getWeapon():getRealCard():toWeapon()
				targetFilter_rangefix = targetFilter_rangefix + weapon:getRange() - from:getAttackRange(false)
			end
			return math.max(number + targetFilter_rangefix - from:getAttackRange(), 0)  --追击双将可能有bug，因为distanceTo是加rangefix之后再将负值改为1
		end																				--FixedDistance也应该有bug，同样是因为distanceTo里直接return值了
		return 0
	end
}
HuangZhong_LB:addSkill(LiegongLB)
HuangZhong_LB:addSkill(LiegongLBAddDamage)
HuangZhong_LB:addSkill(LiegongLBTargetMod)
sgs.insertRelatedSkills(extensionLegendLB, "LiegongLB", "#LiegongLB-adddamage", "#LiegongLB-target")

----------------------------------------------------------------------------------------------------

--[[ SHU 009 魏延
	武将：WeiYan_LB
	武将名：魏延-界
	体力上限：4
	武将技能：
		狂骨：当你对距离1以内的一名角色造成1点伤害后，你可以选择一项：1. 回复1点体力；2. 摸一张牌。
		奇谋：限定技，出牌阶段，你可以失去X点体力，令你于此回合内与其他角色的距离-X且可以多使用X张【杀】。（X至多为你的体力值）
	状态：验证通过
]]--
WeiYan_LB = sgs.General(extensionLegendLB, "WeiYan_LB", "shu", 4, true, true)
WeiYan_LB:addCompanion("huangzhong")
WeiYan_LB:addCompanion("HuangZhong_LB")

--[[
	技能名：狂骨
	技能：KuangguLB
	描述：当你对距离1以内的一名角色造成1点伤害后，你可以选择一项：1. 回复1点体力；2. 摸一张牌。
	状态：验证通过
]]--
KuangguLBRecord = sgs.CreateTriggerSkill{
	name = "#KuangguLB-record",
	events = {sgs.PreDamageDone},
	frequency = sgs.Skill_Frequent,
	on_record = function(self, event, room, player, data)
		local damage = data:toDamage()
		local weiyan = damage.from
		if weiyan then
			if weiyan:distanceTo(damage.to) ~= -1 and weiyan:distanceTo(damage.to) <= 1 then
				weiyan:setTag("InvokeKuangguLB", sgs.QVariant(damage.damage))
			else
				weiyan:removeTag("InvokeKuangguLB")
			end
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
KuangguLB = sgs.CreateTriggerSkill{
	name = "KuangguLB",
	events = {sgs.Damage},
	frequency = sgs.Skill_Frequent,
	can_trigger = function(self, event, room, player, data)
		if not player or player:isDead() or not player:hasSkill(self) then return false end
		local recorded_damage = player:getTag("InvokeKuangguLB"):toInt()
		if recorded_damage and recorded_damage > 0 then
			local skill_list = {}
			local damage = data:toDamage()
			for i = 1, damage.damage, 1 do
				table.insert(skill_list, self:objectName())
			end
			return table.concat(skill_list, ",")
		end
	end,
	on_cost = function(self, event, room, player, data)
		if player:askForSkillInvoke(self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), player)
			return true
		end
		return false
	end,
	on_effect = function(self, event, room, player, data)
		local choiceList = {"draw"}
		if player:isWounded() then
			table.insert(choiceList, 1, "recover")
		end
		local choice = room:askForChoice(player, self:objectName(), table.concat(choiceList, "+"))
		if choice == "recover" then
			local recover = sgs.RecoverStruct()
			recover.who = player
			room:recover(player, recover)
		elseif choice == "draw" then
			room:drawCards(player, 1, self:objectName())
		end
	end,
}
WeiYan_LB:addSkill(KuangguLB)
WeiYan_LB:addSkill(KuangguLBRecord)
sgs.insertRelatedSkills(extensionLegendLB, "KuangguLB", "#KuangguLB-record")

--[[
	技能名：奇谋
	技能：Qimou
	描述：限定技，出牌阶段，你可以失去X点体力，令你于此回合内与其他角色的距离-X且可以多使用X张【杀】。（X至多为你的体力值）
	状态：验证通过
]]--
QimouCard = sgs.CreateSkillCard{
	name = "QimouCard", 
	skill_name = "Qimou",
	target_fixed = true,
	mute = true,
	extra_cost = function(self, room, card_use)
		local source = card_use.from
		if source:isDead() or source:getHp() < 1 then return false end
		local x = math.max(source:getHp(), 1)
		local nums = "1"
		for i = 2, x do
			nums = (math.mod(i, 5) == 1) and nums .. "|" .. i or nums .. "+" .. i
		end
		local choice = room:askForChoice(source, "Qimou_hp", nums)
		room:loseHp(source, tonumber(choice))
		source:setTag("QimouLostHp", sgs.QVariant(tonumber(choice)))
	end,
	about_to_use = function(self, room, cardUse)
		room:removePlayerMark(cardUse.from, "@strategy")
		room:broadcastSkillInvoke("Qimou", cardUse.from)
		room:doSuperLightbox("WeiYan_LB", "Qimou")
		self:cardOnUse(room, cardUse)
	end,
	on_use = function(self, room, source, targets)
		local losthp = source:getTag("QimouLostHp"):toInt()
		source:removeTag("QimouLostHp")
		if not losthp then return end
		room:addPlayerMark(source, "@strategy_hp", losthp)
	end, 
	on_turn_broken = function(self, function_name, room, data)
		data:toCardUse().from:removeTag("QimouLostHp")
	end,
}
QimouVS = sgs.CreateZeroCardViewAsSkill{
	name = "Qimou", 
	view_as = function(self)
		local card = QimouCard:clone()
		card:setSkillName(self:objectName())
		card:setShowSkill(self:objectName())
		return card
	end,
	enabled_at_play = function(self, player)
		return player:getMark("@strategy") >= 1 and player:getHp() >= 1
	end
}
Qimou = sgs.CreateTriggerSkill{
	name = "Qimou", 
	frequency = sgs.Skill_Limited, 
	limit_mark = "@strategy",
	events = {sgs.EventPhaseStart},
	priority = 8,
	view_as_skill = QimouVS, 
	on_record = function(self, event, room, player, data)
		if player:getPhase() ~= sgs.Player_NotActive then return end
		room:setPlayerMark(player, "@strategy_hp", 0)
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
QimouDist = sgs.CreateDistanceSkill{
	name = "#Qimou-dist", 
	correct_func = function(self, from, to)
		return - from:getMark("@strategy_hp")
	end
}
QimouTargetMod = sgs.CreateTargetModSkill{
	name = "#Qimou-target",
	pattern = "Slash",
	residue_func = function(self, from, card)
		return from:getMark("@strategy_hp")
	end,
}
WeiYan_LB:addSkill(Qimou)
WeiYan_LB:addSkill(QimouDist)
WeiYan_LB:addSkill(QimouTargetMod)
sgs.insertRelatedSkills(extensionLegendLB, "Qimou", "#Qimou-dist", "#Qimou-target")

-------------------------------------------------神-------------------------------------------------

extensionGod = sgs.Package("God", sgs.Package_GeneralPack)

--[[ LE 001 神关羽
	武将：ShenGuanYu
	武将名：神关羽
	体力上限：5
	武将技能：
		武神：锁定技，你的红桃手牌视为【杀】；你使用红桃【杀】无距离限制。
		武魂：锁定技，当你受到1点伤害后，你令伤害来源获得1枚“梦魇”标记；当你死亡时，你令一名拥有最多“梦魇”标记的其他角色进行判定，若结果不为【桃】或【桃园结义】，该角色死亡。
	状态：验证通过
]]--
ShenGuanYu = sgs.General(extensionGod, "ShenGuanYu", "god", 5, true)

--[[
	技能名：武神
	技能：Wushen
	描述：锁定技，你的红桃手牌视为【杀】；你使用红桃【杀】无距离限制。
	状态：验证通过
	注：亮将代码在showTMSkillForSlash中
]]--
WushenFilter = sgs.CreateFilterSkill{
	name = "#Wushen-filter",
	view_filter = function(self, card)
		local room = sgs.Sanguosha:currentRoom()
		if room then
			local owner = room:getCardOwner(card:getId())
			if owner and owner:hasShownSkill("Wushen") then
				return card:getSuit() == sgs.Card_Heart and room:getCardPlace(card:getEffectiveId()) == sgs.Player_PlaceHand
			end
			--[[for _,p in sgs.qlist(room:getPlayers()) do
				if p:hasShownSkill("Wushen") then
					return card:getSuit() == sgs.Card_Heart and room:getCardPlace(card:getEffectiveId()) == sgs.Player_PlaceHand
				end
			end
		else  --因为国战还没涉及到其他锁定视为技，所以我也不知道应不应该允许高顺自己点禁酒按钮将酒当杀……而且好像没法实现
			for _,p in sgs.qlist(sgs.Self:getAliveSiblings()) do
				if p:ownSkill("Jinjiu") and p:hasShownSkill(self:objectName()) then
					return card:objectName() == "analeptic"
				end
			end]]
		end
	end,
	view_as = function(self, card)
		local slash = sgs.Sanguosha:cloneCard("slash", card:getSuit(), card:getNumber())
		slash:setSkillName("Wushen")
		local wrap = sgs.Sanguosha:getWrappedCard(card:getId())
		wrap:takeOver(slash)
		return wrap
	end
}
WushenVS = sgs.CreateOneCardViewAsSkill{
	name = "Wushen",
	filter_pattern = ".|heart|.|hand",
	view_as = function(self, originalCard)
		local slash = sgs.Sanguosha:cloneCard("slash", originalCard:getSuit(), originalCard:getNumber())
		slash:addSubcard(originalCard:getId())
		slash:setSkillName(self:objectName())
		slash:setShowSkill(self:objectName())
		return slash
	end,
	enabled_at_play = function(self, player)
		return not player:hasShownSkill(self:objectName()) and sgs.Slash_IsAvailable(player)
	end,
	enabled_at_response = function(self, player, pattern)
		return not player:hasShownSkill(self:objectName()) and (pattern == "slash")
	end,
}
Wushen = sgs.CreateTriggerSkill{
	name = "Wushen",
	can_preshow = false,  --设为true则无法使用VSSkill
	events = {sgs.EventAcquireSkill, sgs.EventLoseSkill},
	frequency = sgs.Skill_Compulsory,
	view_as_skill = WushenVS,
	on_record = function(self, event, room, player, data)
		if (event == sgs.EventAcquireSkill and data:toString() == self:objectName() and player:hasSkill(self:objectName()))  --注意WushenFilter为隐藏技能，因此不会自动在这两个时机filterCards
			or (event == sgs.EventLoseSkill and data:toString() == self:objectName()) then
			room:filterCards(player, player:getCards("he"), true)
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end
}
WushenTargetMod = sgs.CreateTargetModSkill{
	name = "#Wushen-target",
	distance_limit_func = function(self, from, card)
		if from:hasSkill("Wushen") and card:getSuit() == sgs.Card_Heart then
			return 1000
		else
			return 0
		end
	end
}
ShenGuanYu:addSkill(Wushen)
ShenGuanYu:addSkill(WushenFilter)
ShenGuanYu:addSkill(WushenTargetMod)
sgs.insertRelatedSkills(extensionGod, "Wushen", "#Wushen-filter", "#Wushen-target")

--[[
	技能名：武魂
	技能：Wuhun
	描述：锁定技，当你受到1点伤害后，你令伤害来源获得1枚“梦魇”标记；当你死亡时，你令一名拥有最多“梦魇”标记的其他角色进行判定，若结果不为【桃】或【桃园结义】，该角色死亡。
	状态：验证通过
]]--
Wuhun = sgs.CreateTriggerSkill{
	name = "Wuhun",
	can_preshow = true,
	events = {sgs.Damaged, sgs.Death},
	frequency = sgs.Skill_Compulsory,
	can_trigger = function(self, event, room, player, data)
		if event == sgs.Damaged then
			if not (player and player:isAlive() and player:hasSkill(self:objectName())) then return "" end
			local damage = data:toDamage()
			if damage.from and damage.from:isAlive() then
				local trigger_list = {}
				for i = 1, damage.damage do
					table.insert(trigger_list, self:objectName())
				end
				return table.concat(trigger_list, ",")
			end
		elseif event == sgs.Death then
			if not player or not player:hasSkill(self:objectName()) then return "" end
			local death = data:toDeath()
			if (death.who:objectName() == player:objectName()) then
				local maxnum = 0
				for _,p in sgs.qlist(room:getOtherPlayers(player)) do
					maxnum = math.max(maxnum, p:getMark("@nightmare"))
				end
				if maxnum == 0 then return "" end
				return self:objectName()
			end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		if event == sgs.Damaged then
			if player:hasShownSkill(self:objectName()) or player:askForSkillInvoke(self:objectName(), data) then
				local skin_id = player:property((player:inHeadSkills(self) and "head" or "deputy") .. "_skin_id"):toInt()
				room:broadcastSkillInvoke(self:objectName(), (skin_id == 1) and 1 or -1, player)
				return true
			end
			return false
		elseif event == sgs.Death then
			local maxnum = 0
			for _,p in sgs.qlist(room:getOtherPlayers(player)) do
				maxnum = math.max(maxnum, p:getMark("@nightmare"))
			end
			if maxnum == 0 then return false end
			local foes = sgs.SPlayerList()
			for _,p in sgs.qlist(room:getOtherPlayers(player)) do
				if p:getMark("@nightmare") == maxnum then
					foes:append(p)
				end
			end
			if foes:isEmpty() then return false end
			
			local foe
			if foes:length() == 1 then
				foe = foes:first()
				room:notifySkillInvoked(player, self:objectName())  --把askForPlayerChosen的内容手动搬过来
				room:doAnimate(1, player:objectName(), foe:objectName())
				local msg = sgs.LogMessage()
				msg.type, msg.from, msg.arg = "#ChoosePlayerWithSkill", player, self:objectName()
				msg.to:append(foe)
				room:sendLog(msg)
			else
				foe = room:askForPlayerChosen(player, foes, self:objectName(), "@Wuhun-revenge", false, true)
			end
			if foe then
				local _data = sgs.QVariant()
				_data:setValue(foe)
				player:setTag("Wuhun_invoke", _data)
				return true
			end
			return false
		end
	end,
	on_effect = function(self, event, room, player, data)
		if event == sgs.Damaged then
			room:sendCompulsoryTriggerLog(player, self:objectName(), true)
			local damage = data:toDamage()
			if damage.from then
				damage.from:gainMark("@nightmare")
			end
		elseif event == sgs.Death then
			local foe = player:getTag("Wuhun_invoke"):toPlayer()
			player:removeTag("Wuhun_invoke")
			if not foe then
				for _,p in sgs.qlist(room:getAllPlayers()) do
					p:loseAllMarks("@nightmare")
				end
				return false
			end
			
			local judge = sgs.JudgeStruct()
			judge.pattern, judge.good, judge.negative, judge.reason, judge.who = "Peach,GodSalvation", true, true, self:objectName(), foe
			room:judge(judge)
			local skin_id = player:property((player:inHeadSkills(self) and "head" or "deputy") .. "_skin_id"):toInt()
			if judge:isBad() then
				room:broadcastSkillInvoke(self:objectName(), (skin_id == 1) and 2 or -1, player)
				room:doSuperLightbox("ShenGuanYu", self:objectName())
				local msg = sgs.LogMessage()
				msg.type, msg.from, msg.arg, msg.arg2 = "#WuhunRevenge", player, foe:getMark("@nightmare"), self:objectName()
				msg.to:append(foe)
				room:sendLog(msg)
				room:killPlayer(foe)
			else
				if skin_id == 1 then room:broadcastSkillInvoke(self:objectName(), 3, player) end
			end
		end
		return false
	end,
	on_turn_broken = function(self, function_name, event, room, player, data, ask_who)
		player:removeTag("Wuhun_invoke")
	end
}
WuhunClear = sgs.CreateTriggerSkill{
	name = "#Wuhun-clear",
	events = {sgs.EventLoseSkill, sgs.Death},
	priority = 1,
	global = true,
	on_record = function(self, event, room, player, data)
		if event == sgs.Death then
			if not player or not player:hasSkill("Wuhun") then return end
			local death = data:toDeath()
			if (death.who:objectName() ~= player:objectName()) then return end
		elseif event == sgs.EventLoseSkill and data:toString() ~= "Wuhun" then return end
		for _,p in sgs.qlist(room:getAllPlayers()) do
			p:loseAllMarks("@nightmare")
		end
		return ""
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
ShenGuanYu:addSkill(Wuhun)
ShenGuanYu:addSkill(WuhunClear)
sgs.insertRelatedSkills(extensionGod, "Wuhun", "#Wuhun-clear")

----------------------------------------------------------------------------------------------------

--[[ LE 002 神吕蒙
	武将：ShenLyuMeng
	武将名：神吕蒙
	体力上限：3
	武将技能：
		涉猎：摸牌阶段开始时，你可以放弃摸牌，亮出牌堆顶的五张牌，然后获得其中每种花色的牌各一张，将其余的牌置入弃牌堆。
		攻心：出牌阶段限一次，你可以观看一名其他角色的手牌并可展示其中的一张红桃牌，然后选择一项：1. 弃置之；2. 将之置于牌堆顶。
	状态：验证通过
]]--
ShenLyuMeng = sgs.General(extensionGod, "ShenLyuMeng", "god", 3, true)

--[[
	技能名：涉猎
	技能：Shelie
	描述：摸牌阶段开始时，你可以放弃摸牌，亮出牌堆顶的五张牌，然后获得其中每种花色的牌各一张，将其余的牌置入弃牌堆。
	状态：复制手册并微调ShelieAsMovePattern
]]--
function ShelieAsMovePattern(selected, to_select)
	if to_select ~= -1 then
		for _, id in ipairs(selected) do
			if sgs.Sanguosha:getCard(to_select):getSuit() == sgs.Sanguosha:getCard(id):getSuit() then
				return false
			end
		end
	end
	return true
end
Shelie = sgs.CreatePhaseChangeSkill{
	name = "Shelie",
	can_preshow = true,
	frequency = sgs.Skill_Frequent,
	can_trigger = function(self, event, room, player, data)
		if not (player and player:isAlive() and player:hasSkill(self:objectName()) and player:getPhase() == sgs.Player_Draw) then return "" end
		return self:objectName()
	end,
	on_cost = function(self, event, room, player, data)
		if player:askForSkillInvoke(self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), player)
			return true 
		end
	end,
	on_phasechange = function(self, player)
		local room = player:getRoom()
		local card_ids, suits = room:getNCards(5), {}
		for _, id in sgs.qlist(card_ids) do table.insert(suits, sgs.Sanguosha:getCard(id):getSuit()) end
		local AsMove = room:askForMoveCards(player, card_ids, sgs.IntList(), true, self:objectName(), "ShelieAsMovePattern", self:objectName(), #table.toSet(suits), #table.toSet(suits), false, true)

		local dummy = sgs.DummyCard()
		dummy:deleteLater()
		if not AsMove.bottom:isEmpty() then
			dummy:addSubcards(AsMove.bottom)
			player:obtainCard(dummy)
		end
		dummy:clearSubcards()
		if not AsMove.top:isEmpty() then
			dummy:addSubcards(AsMove.top)
			local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_NATURAL_ENTER, player:objectName(), self:objectName(), "")
			room:throwCard(dummy, reason, nil)
		end

		return true
	end
}
ShenLyuMeng:addSkill(Shelie)

--[[
	技能名：攻心
	技能：Gongxin_ShenLyuMeng
	描述：出牌阶段限一次，你可以观看一名其他角色的手牌并可展示其中的一张红桃牌，然后选择一项：1. 弃置之；2. 将之置于牌堆顶。
	状态：验证通过
	注：技能代码在界吕蒙
]]--
GongxinCard_ShenLyuMeng = sgs.CreateGongxinCard("ShenLyuMeng")
Gongxin_ShenLyuMeng = sgs.CreateGongxinSkill("ShenLyuMeng", GongxinCard_ShenLyuMeng)
ShenLyuMeng:addSkill(Gongxin_ShenLyuMeng)

----------------------------------------------------------------------------------------------------

--[[ LE 003 神周瑜
	武将：ShenZhouYu
	武将名：神周瑜
	体力上限：4
	武将技能：
		琴音：弃牌阶段结束时，若你于此阶段内弃置过你的至少两张手牌，你可以选择一项：1. 令所有角色各回复1点体力；2. 令所有角色各失去1点体力。
		业炎：限定技，出牌阶段，你可以对一至三名角色各造成1点火焰伤害，或弃置四张花色各不相同的手牌并选择一至两名角色，失去3点体力，然后对这些角色造成共计至多3点火焰伤害且对其中一名角色造成至少2点火焰伤害。
	状态：复制手册
]]--
ShenZhouYu = sgs.General(extensionGod, "ShenZhouYu", "god", 4, true)

--[[
	技能名：琴音
	技能：Qinyin
	描述：弃牌阶段结束时，若你于此阶段内弃置过你的至少两张手牌，你可以选择一项：1. 令所有角色各回复1点体力；2. 令所有角色各失去1点体力。
	状态：复制手册
]]--
QinyinRecord = sgs.CreateTriggerSkill{
	name = "#Qinyin-record",
	events = {sgs.CardsMoveOneTime, sgs.EventPhaseChanging},
	on_record = function(self, event, room, player, data)
		if event == sgs.EventPhaseChanging then
			if data:toPhaseChange().from == sgs.Player_Discard then player:setMark("Qinyin", 0) end
		elseif event == sgs.CardsMoveOneTime and player:getPhase() == sgs.Player_Discard then
			local move = data:toMoveOneTime()
			if move.from and move.from:objectName() == player:objectName() and move.reason.m_playerId == player:objectName() and bit32.band(move.reason.m_reason, sgs.CardMoveReason_S_MASK_BASIC_REASON) == sgs.CardMoveReason_S_REASON_DISCARD then
				for i = 0, move.card_ids:length()-1, 1 do
					if move.from_places:at(i) == sgs.Player_PlaceHand then player:addMark("Qinyin") end
				end
			end	
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end
}
Qinyin = sgs.CreateTriggerSkill{
	name = "Qinyin",
	can_preshow = true,
	events = {sgs.EventPhaseEnd},
	frequency = sgs.Skill_Frequent,
	can_trigger = function(self, event, room, player, data)
		if player and player:isAlive() and player:hasSkill(self:objectName()) then
			if player:getPhase() == sgs.Player_Discard and player:getMark(self:objectName()) >= 2 then
				return self:objectName()
			end
		end
		return ""
	end,
	
	on_cost = function(self, event, room, player, data)
		if player:askForSkillInvoke(self:objectName(), data) then
			return true 
		end
		return false 
	end,
	
	on_effect = function(self, event, room, player, data)
		local choices = {}
		for _, p in sgs.qlist(room:getAlivePlayers()) do
			if p:isWounded() then
				table.insert(choices, "up")
				break
			end
		end
		table.insert(choices, "down")
		local choice = room:askForChoice(player, self:objectName(), table.concat(choices, "+"))
		local players = room:getAlivePlayers()
		room:sortByActionOrder(players)  --由于不明原因导致顺序混乱
		if choice == "up" then
			room:broadcastSkillInvoke(self:objectName(), 2, player)
			for _, p in sgs.qlist(players) do
				local recover = sgs.RecoverStruct()
				recover.who = player
				room:recover(p, recover)
			end
		elseif choice == "down" then
			local skin_id = player:property((player:inHeadSkills(self) and "head" or "deputy") .. "_skin_id"):toInt()
			local index = 1
			if skin_id == 1 and room:findPlayer("caocao+CaoCao_LB+ShenCaoCao") then index = 3 end
			room:broadcastSkillInvoke(self:objectName(), index, player)
			for _, p in sgs.qlist(players) do
				room:loseHp(p)
			end
		end
		return false 
	end,
}
ShenZhouYu:addSkill(Qinyin)
ShenZhouYu:addSkill(QinyinRecord)
sgs.insertRelatedSkills(extensionGod, "Qinyin", "#Qinyin-record")

--[[
	技能名：业炎
	技能：Yeyan
	描述：限定技，出牌阶段，你可以对一至三名角色各造成1点火焰伤害，或弃置四张花色各不相同的手牌并选择一至两名角色，失去3点体力，然后对这些角色造成共计至多3点火焰伤害且对其中一名角色造成至少2点火焰伤害。
	状态：复制手册
]]--
YeyanCard = sgs.CreateSkillCard{
	name = "YeyanCard",
	skill_name = "Yeyan",
	target_fixed = false,
	will_throw = true,
	mute = true,

	filter = function(self, targets, to_select, player)
		if self:subcardsLength() == 4 then
			local n = 0
			for _, target in ipairs(targets) do
				if target:objectName() == to_select:objectName() then n = n+1 end
			end
			return (#table.toSet(targets) < 2 or table.contains(targets, to_select)) and (3 - #targets) + n or 0
		end
		return #targets < 3
	end,
	
	feasible = function(self, targets, player)
		if self:subcardsLength() == 4 then
			return #targets - #table.toSet(targets) >= 1
		end
		return #targets > 0
	end,

	about_to_use = function(self, room, cardUse)
		local victims = {}
		for _,to in sgs.qlist(cardUse.to) do
			if not table.contains(victims, to) then table.insert(victims, to) end
		end
		local skin_id = cardUse.from:property((cardUse.from:inHeadSkills("Yeyan") and "head" or "deputy") .. "_skin_id"):toInt()
		if skin_id == 1 then
			local index = self:subcardsLength() == 4 and 1 or (4 - #victims)
			room:broadcastSkillInvoke("Yeyan", index, cardUse.from)
		else
			room:broadcastSkillInvoke("Yeyan", cardUse.from)
		end
		room:doSuperLightbox("ShenZhouYu", self:getSkillName())
		room:removePlayerMark(cardUse.from, "@flame")
		self:cardOnUse(room, cardUse)
	end,

	on_use = function(self, room, source, targets)
		if self:subcardsLength() == 4 then room:loseHp(source, 3) end

		local targets2 = sgs.SPlayerList()
		for _, tar in ipairs(table.toSet(targets)) do targets2:append(tar) end
		room:sortByActionOrder(targets2)

		for _, target in sgs.qlist(targets2) do
			local point = 0
			for _, tar in ipairs(targets) do 
				if tar == target then point = point + 1 end
			end
			room:damage(sgs.DamageStruct(self:objectName(), source, target, point, sgs.DamageStruct_Fire))
		end
	end,
}
Yeyan = sgs.CreateViewAsSkill{   
	name = "Yeyan",
	limit_mark = "@flame",
	
	view_filter = function(self, selected, to_select)
		for _, card in ipairs(selected) do 
			if to_select:getSuit() == card:getSuit() then return false end
		end
		return #selected < 4 and not to_select:isEquipped() and not sgs.Self:isJilei(to_select)
	end, 

	view_as = function(self, originalCards) 
		if #originalCards == 0 or #originalCards == 4 then
			local skillcard = YeyanCard:clone()
			for _, card in ipairs(originalCards) do
				skillcard:addSubcard(card)
			end
			skillcard:setSkillName(self:objectName())
			skillcard:setShowSkill(self:objectName())
			return skillcard
		end
	end, 

	enabled_at_play = function(self, player)
		return player:getMark("@flame") > 0
	end,
}
ShenZhouYu:addSkill(Yeyan)

----------------------------------------------------------------------------------------------------

--[[ LE 004 神诸葛亮
	武将：ShenZhuGeLiang
	武将名：神诸葛亮
	体力上限：3
	武将技能：
		七星：当你首次明置此武将牌后，你摸七张牌，然后将七张手牌扣置于武将牌旁，称为“星”；摸牌阶段结束时，你可以用至少一张手牌替换等量的“星”。
		狂风：结束阶段开始时，你可以移去一张“星”并选择一名角色，若如此做，直到你的回合开始之前，当其受到的火焰伤害结算开始时，你令此伤害+1。
		大雾：结束阶段开始时，你可以移去至少一张“星”并选择等量的角色，若如此做，直到你的回合开始之前，当其受到的非雷电伤害结算开始时，你防止此伤害。
	状态：验证通过
]]--
ShenZhuGeLiang = sgs.General(extensionGod, "ShenZhuGeLiang", "god", 3, true)

--[[
	技能名：七星
	技能：Qixing
	描述：当你首次明置此武将牌后，你摸七张牌，然后将七张手牌扣置于武将牌旁，称为“星”；摸牌阶段结束时，你可以用至少一张手牌替换等量的“星”。
	状态：验证通过
]]--
QixingVS = sgs.CreateViewAsSkill{
	name = "Qixing",
	response_pattern = "@@Qixing",
	expand_pile = "stars",
	view_filter = function(self, selected, to_select)
		if #selected < sgs.Self:getPile("stars"):length() then
			return not to_select:isEquipped()
		end
		return false
	end,
	view_as = function(self, cards)
		if #cards == 0 then return nil end  --奇葩bug
		if #cards == sgs.Self:getPile("stars"):length() then
			local card = sgs.DummyCard()
			for _, c in ipairs(cards) do
				card:addSubcard(c)
			end  --注意这里不能亮将，因为如果选择了7张手牌的话不算发动技能（这就是为什么不用askForUseCard）（其实另一个做法是在about_to_use强行掐断）
			return card
		end
		return nil
	end,
}
Qixing = sgs.CreateTriggerSkill{
	name = "Qixing",
	can_preshow = true,
	events = {sgs.EventPhaseEnd, sgs.EventLoseSkill},
	view_as_skill = QixingVS,
	on_record = function(self, event, room, player, data)
		if event == sgs.EventLoseSkill and data:toString() == self:objectName() then
			player:clearOnePrivatePile("stars")
		end
	end,
	can_trigger = function(self, event, room, player, data)
		if not (player and player:isAlive() and player:hasSkill(self:objectName())) then return "" end
		if event == sgs.EventPhaseEnd and player:getPhase() == sgs.Player_Draw and player:getPile("stars"):length() > 0 then
			return self:objectName()
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		--local exchange_card = room:askForExchange(player, self:objectName(), player:getPile("stars"):length(), player:getPile("stars"):length(), "@Qixing-exchange", "stars", ".|.|.|hand,stars")  --askForExchange是强制性的，而七星的要求是选择0或7张，因此不适用
		local card = room:askForCard(player, "@@Qixing", "@Qixing-exchange", data, sgs.Card_MethodNone)
		if card then
			for _,id in sgs.qlist(card:getSubcards()) do
				if room:getCardPlace(id) == sgs.Player_PlaceHand then
					local dat = sgs.QVariant()
					dat:setValue(card)
					player:setTag("QixingExchangeCard", dat)
					room:broadcastSkillInvoke(self:objectName(), player)
					return true
				end
			end
		end
		return false
	end,
	on_effect = function(self, event, room, player, data)
		local card = player:getTag("QixingExchangeCard"):toCard()
		player:removeTag("QixingExchangeCard")
		local pile = player:getPile("stars")
		local subCards = card:getSubcards()
		local to_handcard = sgs.IntList()
		local to_pile = sgs.IntList()
		local set = player:getPile("stars")
		for _,id in sgs.qlist(subCards) do
			set:append(id)
		end
		for _,id in sgs.qlist(set) do
			if not subCards:contains(id) then
				to_handcard:append(id)
			elseif not pile:contains(id) then
				to_pile:append(id)
			end
		end
		assert(to_handcard:length() == to_pile:length())
		if to_pile:length() == 0 or to_handcard:length() ~= to_pile:length() then return end
		
		player:addToPile("stars", to_pile, false)
		local to_handcard_x = sgs.DummyCard(to_handcard)
		local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_EXCHANGE_FROM_PILE, player:objectName())
		room:obtainCard(player, to_handcard_x, reason, false)
		
		local msg = sgs.LogMessage()
		msg.type, msg.from, msg.arg, msg.arg2 = "#QixingExchange", player, to_pile:length(), self:objectName()
		room:sendLog(msg)
		return false
	end,
	on_turn_broken = function(self, function_name, event, room, player, data, ask_who)
		player:removeTag("QixingExchangeCard")
	end
}
QixingShowGeneral = sgs.CreateTriggerSkill{
	name = "#Qixing-show",
	frequency = sgs.Skill_Compulsory,
	events = {sgs.GeneralShown, sgs.DFDebut},
	can_trigger = function(self, event, room, player, data)
		if not (player and player:isAlive() and player:hasSkill("Qixing")) then return "" end
		if (event == sgs.GeneralShown) and (player:getMark("Qixing") == 0) then
			return (data:toBool() == player:inHeadSkills("Qixing")) and self:objectName() or ""
		elseif (event == sgs.DFDebut) and (player:getMark("Qixing") == 0) then
			return self:objectName()
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		room:broadcastSkillInvoke("Qixing", player)
		room:setPlayerMark(player, "Qixing", 1)
		return true
	end,
	on_effect = function(self, event, room, player, data)
		room:sendCompulsoryTriggerLog(player, "Qixing", true)
		room:drawCards(player, 7, self:objectName())
		local num = math.min(player:getHandcardNum(), 7)
		if num == 0 or player:isDead() then return false end
		local exchange_card = room:askForExchange(player, self:objectName(), num, num, "", "", ".|.|.|hand")
		if not exchange_card then
			local card_ids = sgs.IntList()
			local card_id
			for i = 1, num do
				card_id = player:getHandcards():at(math.random(0, player:getHandcards():length() - 1))
				while card_ids:contains(card_id) do
					card_id = player:getHandcards():at(math.random(0, player:getHandcards():length() - 1))
				end
				card_ids:append(card_id)
			end
			exchange_card = sgs.DummyCard(card_ids)
		end
		player:addToPile("stars", exchange_card:getSubcards(), false)
		exchange_card:deleteLater()
		return false
	end,
}
ShenZhuGeLiang:addSkill(Qixing)
ShenZhuGeLiang:addSkill(QixingShowGeneral)
sgs.insertRelatedSkills(extensionGod, "Qixing", "#Qixing-show")

--[[
	技能名：狂风
	技能：Kuangfeng
	描述：结束阶段开始时，你可以移去一张“星”并选择一名角色，若如此做，直到你的回合开始之前，当其受到的火焰伤害结算开始时，你令此伤害+1。
	状态：验证通过
]]--
KuangfengCard = sgs.CreateSkillCard{
	name = "KuangfengCard",
	skill_name = "Kuangfeng",
    will_throw = false,
	handling_method = sgs.Card_MethodNone,
	filter = function(self, selected, to_select)
		return #selected == 0
	end,
	extra_cost = function(self, room, use)
		local card_id = self:getSubcards():first()
		local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_REMOVE_FROM_PILE, "", "Kuangfeng", "")
		room:throwCard(self, reason, nil)
	end,
	on_effect = function(self, effect)
		effect.from:setTag("Kuangfeng_user", sgs.QVariant(true))
		effect.to:gainMark("@gale_ShenZhuGeLiang")
		local list = effect.from:getTag("Kuangfeng_targets"):toList() or sgs.VariantList()
		local dat = sgs.QVariant()
		dat:setValue(effect.to)
		list:append(dat)
		effect.from:setTag("Kuangfeng_targets", sgs.QVariant(list))  --确定效果执行者（多个神诸葛同时在场情况）
	end,
}
KuangfengVS = sgs.CreateOneCardViewAsSkill{
	name = "Kuangfeng",
	expand_pile = "stars",
	filter_pattern = ".|.|.|stars",
	response_pattern = "@@Kuangfeng",
	view_as = function(self, card)
        local kuangfeng_card = KuangfengCard:clone()
		kuangfeng_card:addSubcard(card)
        kuangfeng_card:setShowSkill(self:objectName())
        return kuangfeng_card
	end,
}
Kuangfeng = sgs.CreatePhaseChangeSkill{
	name = "Kuangfeng",  
	can_preshow = true,
	view_as_skill = KuangfengVS,
	can_trigger = function(self, event, room, player, data)
		if not player or player:isDead() or not player:hasSkill(self:objectName()) then return false end
		if (player:getPhase() == sgs.Player_Finish) and player:getPile("stars"):length() > 0 then return self:objectName() end
	end,
	on_cost = function(self, event, room, player, data)
		return room:askForUseCard(player, "@@Kuangfeng", "@Kuangfeng-card", -1, sgs.Card_MethodNone)
	end,
	on_phasechange = function(self, player)
		return false
	end,
}
KuangfengEffect = sgs.CreateTriggerSkill{
	name = "#Kuangfeng-effect",
	can_preshow = false,
	events = {sgs.DamageForseen},
	frequency = sgs.Skill_Compulsory,
	can_trigger = function(self, event, room, player, data)
		local damage = data:toDamage()
		if player and player:getMark("@gale_ShenZhuGeLiang") > 0 and damage.nature == sgs.DamageStruct_Fire then
			local skill_list, player_list = {}, {}
			for _,p in sgs.qlist(room:getAllPlayers()) do
				if not p:getTag("Kuangfeng_user"):toBool() then continue end
				local targets_qvar = p:getTag("Kuangfeng_targets"):toList()
				local target
				for _,target_qvar in sgs.qlist(targets_qvar) do
					target = target_qvar:toPlayer()
					if target and (target:objectName() == player:objectName()) then
						table.insert(skill_list, self:objectName())
						table.insert(player_list, p:objectName())
					end
				end
			end
			return table.concat(skill_list, "|"), table.concat(player_list, "|")
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		return true
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		local damage = data:toDamage()
		local msg = sgs.LogMessage()
		msg.type, msg.from, msg.arg, msg.arg2 = "#GalePower", ask_who, damage.damage, damage.damage + 1
		msg.to:append(player)
		room:sendLog(msg)
		damage.damage = damage.damage + 1
		data:setValue(damage)
		return false
	end,
}
KuangfengClear = sgs.CreateTriggerSkill{
	name = "#Kuangfeng-clear",  
	events = {sgs.EventPhaseStart, sgs.Death},
	priority = 8,  --严格来说sgs.Death应该是2
	global = true,
	on_record = function(self, event, room, player, data)
		if event == sgs.Death then
			local death = data:toDeath()
			if death.who:objectName() ~= player:objectName() then return end
		elseif event == sgs.EventPhaseStart then
			if player:getPhase() ~= sgs.Player_RoundStart then return end
		end
		if not player:getTag("Kuangfeng_user"):toBool() then return end
		player:removeTag("Kuangfeng_user")
		local targets_qvar = player:getTag("Kuangfeng_targets"):toList()
		local target
		for _,target_qvar in sgs.qlist(targets_qvar) do
			target = target_qvar:toPlayer()
			if target then
				target:loseMark("@gale_ShenZhuGeLiang")
			end
		end
		player:removeTag("Kuangfeng_targets")
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
ShenZhuGeLiang:addSkill(Kuangfeng)
ShenZhuGeLiang:addSkill(KuangfengEffect)
ShenZhuGeLiang:addSkill(KuangfengClear)
sgs.insertRelatedSkills(extensionGod, "Kuangfeng", "#Kuangfeng-effect", "#Kuangfeng-clear")

--[[
	技能名：大雾
	技能：Dawu
	描述：结束阶段开始时，你可以移去至少一张“星”并选择等量的角色，若如此做，直到你的回合开始之前，当其受到的非雷电伤害结算开始时，你防止此伤害。
	状态：验证通过
]]--
DawuCard = sgs.CreateSkillCard{
	name = "DawuCard",
	skill_name = "Dawu",
    will_throw = false,
	handling_method = sgs.Card_MethodNone,
	filter = function(self, selected, to_select)
		return #selected < self:subcardsLength()
	end,
	feasible = function(self, selected)
		return #selected == self:subcardsLength()
	end,
	extra_cost = function(self, room, use)
		local card_id = self:getSubcards():first()
		local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_REMOVE_FROM_PILE, "", "Dawu", "")
		room:throwCard(self, reason, nil)
	end,
	on_effect = function(self, effect)
		effect.from:setTag("Dawu_user", sgs.QVariant(true))
		effect.to:gainMark("@fog_ShenZhuGeLiang")
		local list = effect.from:getTag("Dawu_targets"):toList() or sgs.VariantList()
		local dat = sgs.QVariant()
		dat:setValue(effect.to)
		list:append(dat)
		effect.from:setTag("Dawu_targets", sgs.QVariant(list))  --确定效果执行者（多个神诸葛同时在场情况）
	end,
}
DawuVS = sgs.CreateViewAsSkill{
	name = "Dawu",
	expand_pile = "stars",
	response_pattern = "@@Dawu",
	view_filter = function(self, selected, to_select)
		return sgs.Self:getPile("stars"):contains(to_select:getId())
	end,
	view_as = function(self, cards)
		if #cards > 0 then
			local dawu_card = DawuCard:clone()
			for _, c in ipairs(cards) do
				dawu_card:addSubcard(c)
			end
			dawu_card:setShowSkill(self:objectName())
			return dawu_card
		end
		return nil
	end,
}
Dawu = sgs.CreatePhaseChangeSkill{
	name = "Dawu",  
	can_preshow = true,
	view_as_skill = DawuVS,
	can_trigger = function(self, event, room, player, data)
		if not player or player:isDead() or not player:hasSkill(self:objectName()) then return false end
		if (player:getPhase() == sgs.Player_Finish) and player:getPile("stars"):length() > 0 then return self:objectName() end
	end,
	on_cost = function(self, event, room, player, data)
		return room:askForUseCard(player, "@@Dawu", "@Dawu-card", -1, sgs.Card_MethodNone)
	end,
	on_phasechange = function(self, player)
		return false
	end,
}
DawuEffect = sgs.CreateTriggerSkill{
	name = "#Dawu-effect",
	can_preshow = false,
	events = {sgs.DamageForseen},
	frequency = sgs.Skill_Compulsory,
	can_trigger = function(self, event, room, player, data)
		local damage = data:toDamage()
		if player and player:getMark("@fog_ShenZhuGeLiang") > 0 and damage.nature ~= sgs.DamageStruct_Thunder then
			local skill_list, player_list = {}, {}
			for _,p in sgs.qlist(room:getAllPlayers()) do
				if not p:getTag("Dawu_user"):toBool() then continue end
				local targets_qvar = p:getTag("Dawu_targets"):toList()
				local target
				for _,target_qvar in sgs.qlist(targets_qvar) do
					target = target_qvar:toPlayer()
					if target and (target:objectName() == player:objectName()) then
						table.insert(skill_list, self:objectName())
						table.insert(player_list, p:objectName())
					end
				end
			end
			return table.concat(skill_list, "|"), table.concat(player_list, "|")
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		return true
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		local damage = data:toDamage()
		local msg = sgs.LogMessage()
		msg.type, msg.from, msg.arg = "#FogProtect", ask_who, damage.damage
		msg.to:append(player)
		if damage.nature == sgs.DamageStruct_Normal then
			msg.arg2 = "normal_nature"
		elseif damage.nature == sgs.DamageStruct_Fire then
			msg.arg2 = "fire_nature"
		end
		room:sendLog(msg)
		return true
	end,
}
DawuClear = sgs.CreateTriggerSkill{
	name = "#Dawu-clear",  
	events = {sgs.EventPhaseStart, sgs.Death},
	priority = 8,  --严格来说sgs.Death应该是2
	global = true,
	on_record = function(self, event, room, player, data)
		if event == sgs.Death then
			local death = data:toDeath()
			if death.who:objectName() ~= player:objectName() then return end
		elseif event == sgs.EventPhaseStart then
			if player:getPhase() ~= sgs.Player_RoundStart then return end
		end
		if not player:getTag("Dawu_user"):toBool() then return end
		player:removeTag("Dawu_user")
		local targets_qvar = player:getTag("Dawu_targets"):toList()
		local target
		for _,target_qvar in sgs.qlist(targets_qvar) do
			target = target_qvar:toPlayer()
			if target then
				target:loseMark("@fog_ShenZhuGeLiang")
			end
		end
		player:removeTag("Dawu_targets")
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
ShenZhuGeLiang:addSkill(Dawu)
ShenZhuGeLiang:addSkill(DawuEffect)
ShenZhuGeLiang:addSkill(DawuClear)
sgs.insertRelatedSkills(extensionGod, "Dawu", "#Dawu-effect", "#Dawu-clear")

----------------------------------------------------------------------------------------------------

--[[ LE 005 神曹操
	武将：ShenCaoCao
	武将名：神曹操
	体力上限：3
	武将技能：
		归心：当你受到1点伤害后，你可以获得每名其他角色区域内的一张牌，然后叠置。
		飞影：锁定技，其他角色与你的距离+1。
	状态：验证通过
]]--
ShenCaoCao = sgs.General(extensionGod, "ShenCaoCao", "god", 3, true)

--[[
	技能名：归心
	技能：Guixin
	描述：当你受到1点伤害后，你可以获得每名其他角色区域内的一张牌，然后叠置。
	状态：验证通过
]]--
Guixin = sgs.CreateMasochismSkill{
	name = "Guixin",
	can_preshow = true,
	on_record = function(self, event, room, player, data)	
		if not player or player:isDead() or not player:hasSkill(self:objectName()) then return false end
		player:setMark("OldGuixinTimes", player:getMark("GuixinTimes"))  --插入结算（但是很难维护，而且没法处理三重嵌套）
		player:setMark("GuixinTimes", 0)  --for AI
	end,
	can_trigger = function(self, event, room, player, data)	
		if not player or player:isDead() or not player:hasSkill(self:objectName()) then return false end
		local canGet = false
		for _,p in sgs.qlist(room:getOtherPlayers(player)) do
			if p:isAlive() and not p:isAllNude() then canGet = true break end
		end
		if not canGet then return "" end
		local trigger_list = {}
		local damage = data:toDamage()
		for i = 1, damage.damage, 1 do
			table.insert(trigger_list, self:objectName())
		end
		return table.concat(trigger_list, ",")
	end,
	on_cost = function(self, event, room, player, data)
		player:addMark("GuixinTimes")
		if room:askForSkillInvoke(player, self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), player)
			room:doSuperLightbox("ShenCaoCao", self:objectName())
			return true
		end
		player:setMark("GuixinTimes", player:getMark("OldGuixinTimes"))
		player:setMark("OldGuixinTimes", 0)
		return false
	end,
	on_damaged = function(self, player, damage)
		local room = player:getRoom()
		player:setFlags("GuixinUsing")  --Useless flag?
		for _,p in sgs.qlist(room:getOtherPlayers(player)) do
			if p:isAlive() and not p:isAllNude() then
				local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_EXTRACTION, player:objectName(), self:objectName(), "")
				local card_id = room:askForCardChosen(player, p, "hej", self:objectName())
				room:obtainCard(player, sgs.Sanguosha:getCard(card_id), reason, false)
				
				if player:isDead() then
					player:setFlags("-GuixinUsing")
					player:setMark("GuixinTimes", 0)
					player:setMark("OldGuixinTimes", 0)
					return
				end
			end
		end
		player:turnOver()
		player:setFlags("-GuixinUsing")
		if player:getMark("GuixinTimes") == damage.damage then
			player:setMark("GuixinTimes", player:getMark("OldGuixinTimes"))
			player:setMark("OldGuixinTimes", 0)
		end
	end,
	on_turn_broken = function(self, function_name, event, room, player, data, ask_who)
		player:setFlags("-GuixinUsing")
		player:setMark("GuixinTimes", player:getMark("OldGuixinTimes"))
		player:setMark("OldGuixinTimes", 0)
	end
}
ShenCaoCao:addSkill(Guixin)

--[[
	技能名：飞影
	技能：feiying_ShenCaoCao
	描述：锁定技，其他角色与你的距离+1。
	状态：验证通过
]]--
function sgs.CreateFeiyingSkill(name)
	local feiying_skill = {
		name = "feiying_" .. name, 
		correct_func = function(self, from, to)
			if to:hasShownSkill(self:objectName()) then
				return 1
			else
				return 0
			end
		end
	}
	return sgs.CreateDistanceSkill(feiying_skill)
end
feiying_ShenCaoCao = sgs.CreateFeiyingSkill("ShenCaoCao")
ShenCaoCao:addSkill(feiying_ShenCaoCao)

----------------------------------------------------------------------------------------------------

--[[ LE 006 神吕布
	武将：ShenLyuBu
	武将名：神吕布
	体力上限：5
	武将技能：
		狂暴：锁定技，当你首次明置此武将牌后，你获得2枚“暴怒”标记；当你造成或受到1点伤害后，你获得1枚“暴怒”标记。
		无谋：锁定技，当你使用普通锦囊牌时，你选择一项：失去1点体力，或弃1枚“暴怒”标记。
		无前：出牌阶段，你可以弃2枚“暴怒”标记并选择一名角色，你拥有“无双”且其防具无效，直到回合结束。
		神愤：出牌阶段限一次，你可以弃6枚“暴怒”标记，对所有其他角色各造成1点伤害，然后这些角色先各弃置装备区的所有牌再弃置四张手牌，最后你叠置。
	状态：验证通过
]]--
ShenLyuBu = sgs.General(extensionGod, "ShenLyuBu", "god", 5, true)

--[[
	技能名：狂暴
	技能：Kuangbao
	描述：锁定技，当你首次明置此武将牌后，你获得2枚“暴怒”标记；当你造成或受到1点伤害后，你获得1枚“暴怒”标记。
	状态：验证通过
]]--
Kuangbao = sgs.CreateTriggerSkill{
	name = "Kuangbao",
	can_preshow = true,
	frequency = sgs.Skill_Compulsory,
	events = {sgs.GeneralShown, sgs.DFDebut, sgs.Damage, sgs.Damaged, sgs.EventLoseSkill},
	on_record = function(self, event, room, player, data)
		if event == sgs.EventLoseSkill and data:toString():split(":")[1] == self:objectName() then
			player:loseAllMarks("@wrath")
		end
	end,
	can_trigger = function(self, event, room, player, data)
		if not (player and player:isAlive() and player:hasSkill(self)) then return "" end
		if (event == sgs.GeneralShown) and (player:getMark(self:objectName()) == 0) then
			return (data:toBool() == player:inHeadSkills(self:objectName())) and self:objectName() or ""
		elseif (event == sgs.DFDebut) and (player:getMark(self:objectName()) == 0) then
			return self:objectName()
		elseif event == sgs.Damage or event == sgs.Damaged then
			local damage = data:toDamage()
			local trigger_list = {}
			for i = 1, damage.damage do
				table.insert(trigger_list, self:objectName())
			end
			return table.concat(trigger_list, ",")
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		if (event == sgs.DFDebut) or (event == sgs.GeneralShown) then
			room:setPlayerMark(player, self:objectName(), 1)
			return true
		end
		if player:hasShownSkill(self) or player:askForSkillInvoke(self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), player)
			return true
		end
		return false
	end,
	on_effect = function(self, event, room, player, data)
		room:notifySkillInvoked(player, self:objectName())
		if event == sgs.Damage or event == sgs.Damaged then
			player:gainMark("@wrath", 1)
		else
			player:gainMark("@wrath", 2)
		end
		return false
	end,
}
ShenLyuBu:addSkill(Kuangbao)

--[[
	技能名：无谋
	技能：Wumou
	描述：锁定技，当你使用普通锦囊牌时，你选择一项：失去1点体力，或弃1枚“暴怒”标记。
	状态：验证通过
]]--
Wumou = sgs.CreateTriggerSkill{
	name = "Wumou",
	events = {sgs.CardUsed},
	can_preshow = true,
	frequency = sgs.Skill_Compulsory,
	can_trigger = function(self, event, room, player, data)
		if not (player and player:isAlive() and player:hasSkill(self)) then return "" end
		local use = data:toCardUse()
		if use.card and use.card:isNDTrick() then
			return self:objectName()
		end	
	end,
	on_cost = function(self, event, room, player, data)
		if player:hasShownSkill(self) or player:askForSkillInvoke(self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), player)
			return true
		end
		return false
	end,
	on_effect = function(self, event, room, player, data)
		room:sendCompulsoryTriggerLog(player, self:objectName(), true)
		if player:getMark("@wrath") >= 1 and room:askForChoice(player, self:objectName(), "discard+losehp") == "discard" then
			player:loseMark("@wrath")
		else
			room:loseHp(player)
		end
		return false
	end
}
ShenLyuBu:addSkill(Wumou)

--[[
	技能名：无前
	技能：Wuqian
	描述：出牌阶段，你可以弃2枚“暴怒”标记并选择一名角色，你拥有“无双”且其防具无效，直到回合结束。
	状态：验证通过
]]--
WuqianCard = sgs.CreateSkillCard{
	name = "WuqianCard",
	skill_name = "Wuqian",
	filter = function(self, targets, to_select, player)
		return #targets == 0 and to_select:objectName() ~= player:objectName()
	end,
	extra_cost = function(self, room, use)
		use.from:loseMark("@wrath", 2)
	end,
	on_effect = function(self, effect)
		local room = effect.from:getRoom()
		room:setPlayerMark(effect.from, "WuqianSource", 1)
		room:acquireSkill(effect.from, "wushuang_ShenLyuBu", true, effect.from:inHeadSkills("Wuqian"))
		room:setPlayerFlag(effect.to, "WuqianTarget")
		room:addPlayerMark(effect.to, "Armor_Nullified")
	end
}
WuqianVS = sgs.CreateZeroCardViewAsSkill{
	name = "Wuqian",
	view_as = function(self, cards)
		local card = WuqianCard:clone()
		card:setShowSkill(self:objectName())
		return card
	end, 
	enabled_at_play = function(self, player)
		return player:getMark("@wrath") >= 2
	end,
}
Wuqian = sgs.CreateTriggerSkill{
	name = "Wuqian",
	can_preshow = false,
	events = {sgs.EventPhaseStart},
	priority = 8,
	view_as_skill = WuqianVS,
	on_record = function(self, event, room, player, data)
		if player:getPhase() ~= sgs.Player_NotActive or player:getMark("WuqianSource") <= 0 then return false end
		for _,p in sgs.qlist(room:getAllPlayers()) do
			if p:hasFlag("WuqianTarget") then
				room:setPlayerFlag(p, "-WuqianTarget")
				if p:getMark("Armor_Nullified") > 0 then
					room:removePlayerMark(p, "Armor_Nullified")
				end
			end
		end
		room:setPlayerMark(player, "WuqianSource", 0)
		room:detachSkillFromPlayer(player, "wushuang_ShenLyuBu", false, true)
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end
}
wushuang_ShenLyuBu = sgs.CreateWushuangSkill("ShenLyuBu")
ShenLyuBu:addSkill(Wuqian)
local skillList = sgs.SkillList()
if not sgs.Sanguosha:getSkill("wushuang_ShenLyuBu") then skillList:append(wushuang_ShenLyuBu) end
sgs.Sanguosha:addSkills(skillList)
ShenLyuBu:addRelateSkill("wushuang_ShenLyuBu")

--[[
	技能名：神愤
	技能：Shenfen
	描述：出牌阶段限一次，你可以弃6枚“暴怒”标记，对所有其他角色各造成1点伤害，然后这些角色先各弃置装备区的所有牌再弃置四张手牌，最后你叠置。
	状态：验证通过
]]--
ShenfenCard = sgs.CreateSkillCard{
	name = "ShenfenCard",
	skill_name = "Shenfen",
	target_fixed = true,
	mute = true,
	extra_cost = function(self, room, use)
		use.from:loseMark("@wrath", 6)
	end,
	about_to_use = function(self, room, cardUse)
		room:broadcastSkillInvoke("Shenfen", cardUse.from)
		room:doSuperLightbox("ShenLyuBu", "Shenfen")
		self:cardOnUse(room, cardUse)
	end,
	on_use = function(self, room, source, targets)
		source:setFlags("ShenfenUsing")
		for _,player in sgs.qlist(room:getOtherPlayers(source)) do
			room:damage(sgs.DamageStruct("Shenfen", source, player))
			room:getThread():delay()
		end
		for _,player in sgs.qlist(room:getOtherPlayers(source)) do
			local equips = player:getEquips()
			player:throwAllEquips()
			if not equips:isEmpty() then
				room:getThread():delay()
			end
		end
		for _,player in sgs.qlist(room:getOtherPlayers(source)) do
			local delay = not player:isKongcheng()
			room:askForDiscard(player, "Shenfen", 4, 4)
			if delay then
				room:getThread():delay()
			end
		end
		source:turnOver()
		source:setFlags("-ShenfenUsing")
	end,
	on_turn_broken = function(self, function_name, room, data)
		if function_name == "on_use" then
			data:toCardUse().from:setFlags("-ShenfenUsing")
		end
	end,
}
Shenfen = sgs.CreateZeroCardViewAsSkill{
	name = "Shenfen",
	view_as = function(self, cards)
		local card = ShenfenCard:clone()
		card:setShowSkill(self:objectName())
		return card
	end, 
	enabled_at_play = function(self, player)
		return player:getMark("@wrath") >= 6 and not player:hasUsed("#ShenfenCard")
	end,
}
ShenLyuBu:addSkill(Shenfen)

----------------------------------------------------------------------------------------------------

--[[ LE 007 神赵云
	武将：ShenZhaoYun
	武将名：神赵云
	体力上限：3
	武将技能：
		绝境：锁定技，当你首次明置此武将牌后，你减1点体力上限；摸牌阶段，若你已受伤，你多摸X张牌（X为你已损失的体力值）；你的手牌上限+2。
		龙魂：你可以将X张花色相同的牌按以下规则使用或打出：红桃当【桃】，方块当火【杀】，黑桃当【无懈可击】，梅花当【闪】（X为你的体力值且至少为1）。
	状态：
]]--
ShenZhaoYun = sgs.General(extensionGod, "ShenZhaoYun", "god", 3, true)

--[[
	技能名：绝境
	技能：Juejing
	描述：锁定技，当你首次明置此武将牌后，你减1点体力上限；摸牌阶段，若你已受伤，你多摸X张牌（X为你已损失的体力值）；你的手牌上限+2。
	状态：
]]--
Juejing = sgs.CreateTriggerSkill{
	name = "Juejing",
	can_preshow = true,
	frequency = sgs.Skill_Compulsory,
	events = {sgs.GeneralShown, sgs.DFDebut, sgs.DrawNCards},
	can_trigger = function(self, event, room, player, data)
		if not (player and player:isAlive() and player:hasSkill(self)) then return "" end
		if (event == sgs.GeneralShown) and (player:getMark(self:objectName()) == 0) then
			return (data:toBool() == player:inHeadSkills(self:objectName())) and self:objectName() or ""
		elseif (event == sgs.DFDebut) and (player:getMark(self:objectName()) == 0) then
			return self:objectName()
		elseif event == sgs.DrawNCards then
			return (player:isWounded() and player:getLostHp() > 0) and self:objectName() or ""
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		if (event == sgs.DFDebut) or (event == sgs.GeneralShown) then
			room:setPlayerMark(player, self:objectName(), 1)
			return true
		end
		if player:hasShownSkill(self) or player:askForSkillInvoke(self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), player)
			return true
		end
		return false
	end,
	on_effect = function(self, event, room, player, data)
		if event == sgs.DrawNCards then
			if player:getLostHp() <= 0 then return end
			local msg = sgs.LogMessage()
			msg.type, msg.from, msg.arg, msg.arg2 = "#Juejing", player, player:getLostHp(), self:objectName()
			room:sendLog(msg)
			room:notifySkillInvoked(player, self:objectName())
			local n = data:toInt() + player:getLostHp()
			data:setValue(n)
		else
			room:loseMaxHp(player, 1)
		end
		return false
	end,
}
JuejingMaxCards = sgs.CreateMaxCardsSkill{
	name = "#Juejing-maxcards",
	extra_func = function(self, target)
		if target:hasShownSkill("Juejing") then
			return 2
		else
			return 0
		end
	end,
}
JuejingShowMaxCards = sgs.CreateTriggerSkill{
	name = "#Juejing-showmaxcards",
	can_preshow = true,
	frequency = sgs.Skill_Compulsory,  --因为此技能必须尚未亮将，所以不需要处理无法取消的问题
	events = {sgs.EventPhaseProceeding},
	can_trigger = function(self, event, room, player, data)
		if not player or player:isDead() or not player:hasSkill(self:objectName()) then return "" end
		if (player:getPhase() == sgs.Player_Discard) and not player:hasShownSkill(self) then  --进入弃牌阶段询问是否发动绝境存牌
			if (player:getMaxCards(sgs.Max) < player:getHandcardNum()) then
				return self:objectName()
			end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		if player:hasShownSkill(self) or room:askForSkillInvoke(player, self:objectName(), sgs.QVariant("keep")) then
			player:showGeneral(player:inHeadSkills(self))
			return true
		end
	end,
	on_effect = function(self, event, room, player, data)
		room:notifySkillInvoked(player, self:objectName())
	end,
}
ShenZhaoYun:addSkill(Juejing)
ShenZhaoYun:addSkill(JuejingMaxCards)
ShenZhaoYun:addSkill(JuejingShowMaxCards)
sgs.insertRelatedSkills(extensionGod, "Juejing", "#Juejing-maxcards", "#Juejing-showmaxcards")

--[[
	技能名：龙魂
	技能：Longhun
	描述：你可以将X张花色相同的牌按以下规则使用或打出：红桃当【桃】，方块当火【杀】，黑桃当【无懈可击】，梅花当【闪】（X为你的体力值且至少为1）。
	状态：
]]--
Longhun = sgs.CreateViewAsSkill{
	name = "Longhun",
	response_or_use = true,
	view_filter = function(self, selected, to_select)
		local n = math.max(1, sgs.Self:getHp())
		if #selected >= n or to_select:hasFlag("using") then return false end
		if n > 1 and #selected > 0 then
			local suit = selected[1]:getSuit()
			return to_select:getSuit() == suit
		end
		
		if sgs.Sanguosha:getCurrentCardUseReason() == sgs.CardUseStruct_CARD_USE_REASON_PLAY then
			local card
			if sgs.Self:isWounded() and to_select:getSuit() == sgs.Card_Heart then
				card = sgs.Sanguosha:cloneCard("peach", sgs.Card_SuitToBeDecided, -1)
			elseif to_select:getSuit() == sgs.Card_Diamond then
				card = sgs.Sanguosha:cloneCard("fire_slash", sgs.Card_SuitToBeDecided, -1)
			end
			if card then
				for _,c in ipairs(selected) do
					card:addSubcard(c)
				end
				card:addSubcard(to_select)
				card:deleteLater()
				return card:isAvailable(sgs.Self)
			end
			return false
		elseif sgs.Sanguosha:getCurrentCardUseReason() == sgs.CardUseStruct_CARD_USE_REASON_RESPONSE or sgs.Sanguosha:getCurrentCardUseReason() == sgs.CardUseStruct_CARD_USE_REASON_RESPONSE_USE then
			local pattern = sgs.Sanguosha:getCurrentCardUsePattern()
			if pattern == "jink" then
				return to_select:getSuit() == sgs.Card_Club
			elseif pattern == "nullification" then
				return to_select:getSuit() == sgs.Card_Spade
			elseif pattern == "peach" or pattern == "peach+analeptic" then
				return to_select:getSuit() == sgs.Card_Heart
			elseif pattern == "slash" then
				return to_select:getSuit() == sgs.Card_Diamond
			end
		end
		return false
	end,
	view_as = function(self, cards)
		local n = math.max(1, sgs.Self:getHp())
		if #cards ~= n then return nil end
		local card = cards[1]
		local new_card
		
		if card:getSuit() == sgs.Card_Spade then
			new_card = sgs.Sanguosha:cloneCard("nullification", sgs.Card_SuitToBeDecided, 0)
		elseif card:getSuit() == sgs.Card_Heart then
			new_card = sgs.Sanguosha:cloneCard("peach", sgs.Card_SuitToBeDecided, 0)
		elseif card:getSuit() == sgs.Card_Club then
			new_card = sgs.Sanguosha:cloneCard("jink", sgs.Card_SuitToBeDecided, 0)
		elseif card:getSuit() == sgs.Card_Diamond then
			new_card = sgs.Sanguosha:cloneCard("fire_slash", sgs.Card_SuitToBeDecided, 0)
		end
		if new_card then
			new_card:setSkillName(self:objectName())
			new_card:setShowSkill(self:objectName())
			for _,c in ipairs(cards) do
				new_card:addSubcard(c)
			end
		end
		return new_card
	end,
	enabled_at_play = function(self, player)
		return player:isWounded() or sgs.Slash_IsAvailable(player)
	end,
	enabled_at_response = function(self, player, pattern)
		return pattern == "slash" or pattern == "jink" or (string.find(pattern, "peach") and player:getMark("Global_PreventPeach") == 0) or pattern == "nullification"
	end,
	enabled_at_nullification = function(self, player)
		local n, count = math.max(1, player:getHp()), 0
		for _,card in sgs.qlist(player:getHandcards()) do
			if card:getSuit() == sgs.Card_Spade then count = count + 1 end
		end
		for _,card in sgs.qlist(player:getEquips()) do
			if card:getSuit() == sgs.Card_Spade then count = count + 1 end
		end
		for _,id in sgs.qlist(player:getHandPile()) do
			if sgs.Sanguosha:getCard(id):getSuit() == sgs.Card_Spade then count = count + 1 end
		end
		return count >= n
    end
}
ShenZhaoYun:addSkill(Longhun)

----------------------------------------------------------------------------------------------------

--[[ LE 008 神司马懿
	武将：ShenSiMaYi
	武将名：神司马懿
	体力上限：3
	武将技能：
		忍戒：锁定技，当你受到1点伤害后或于弃牌阶段内因弃置而失去一张手牌后，你获得1枚“忍”标记。
		极略：若你的“忍”标记数不小于势力数，你可以弃1枚“忍”标记，发动以下技能之一：“鬼才”、“放逐”、“集智”、“制衡”、“完杀”。
		连破：一名角色的回合结束后，若你于此回合内杀死过至少一名角色，你可以获得一个额外的回合。
	状态：
]]--
ShenSiMaYi = sgs.General(extensionGod, "ShenSiMaYi", "god", 3, true)

--[[
	技能名：忍戒
	技能：Renjie
	描述：锁定技，当你受到1点伤害后或于弃牌阶段内因弃置而失去一张手牌后，你获得1枚“忍”标记。
	状态：验证通过
]]--
Renjie = sgs.CreateTriggerSkill{
	name = "Renjie",
	can_preshow = true,
	events = {sgs.Damaged, sgs.CardsMoveOneTime, sgs.EventLoseSkill},
	frequency = sgs.Skill_Compulsory,
	on_record = function(self, event, room, player, data)
		if event == sgs.EventLoseSkill and data:toString():split(":")[1] == self:objectName() then
			player:loseAllMarks("@bear")
		end
	end,
	can_trigger = function(self, event, room, player, data)
		if not (player and player:isAlive() and player:hasSkill(self)) then return "" end
		if event == sgs.Damaged then
			return self:objectName()
		elseif event == sgs.CardsMoveOneTime and player:getPhase() == sgs.Player_Discard then
			local move = data:toMoveOneTime()
			if move.from and move.from:objectName() == player:objectName() and bit32.band(move.reason.m_reason, sgs.CardMoveReason_S_MASK_BASIC_REASON) == sgs.CardMoveReason_S_REASON_DISCARD then
				if move.from_places:contains(sgs.Player_PlaceHand) then return self:objectName() end
			end	
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		if player:hasShownSkill(self) or player:askForSkillInvoke(self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), player)
			return true
		end
		return false
	end,
	on_effect = function(self, event, room, player, data)
		room:notifySkillInvoked(player, self:objectName())
		if event == sgs.Damaged then
			local damage = data:toDamage()
			player:gainMark("@bear", damage.damage)
		elseif event == sgs.CardsMoveOneTime then
			local move = data:toMoveOneTime()
			local n = 0
			for i = 0, move.card_ids:length() - 1, 1 do
				if move.from_places:at(i) == sgs.Player_PlaceHand then n = n + 1 end
			end
			player:gainMark("@bear", n)
		end
	end,
}
ShenSiMaYi:addSkill(Renjie)

--[[
	技能名：极略
	技能：Jilyue
	描述：若你的“忍”标记数不小于势力数，你可以弃1枚“忍”标记，发动以下技能之一：“鬼才”、“放逐”、“集智”、“制衡”、“完杀”。
	状态：验证通过
]]--
function getJilyueSkill(event)
	local skill_name
	if event == sgs.CardUsed then skill_name = "jizhi"
	elseif event == sgs.AskForRetrial then skill_name = "guicai"
	elseif event == sgs.Damaged then skill_name = "fangzhu"
	elseif event == sgs.Dying then skill_name = "wansha"
	else assert(false) return end
	return sgs.Sanguosha:getTriggerSkill(skill_name)
end
JilyueCard = sgs.CreateSkillCard{
	name = "JilyueCard",
	skill_name = "Jilyue",
	target_fixed = true,
	mute = true,
	about_to_use = function(self, room, cardUse)
		local shensimayi = cardUse.from
		local choices = {}
		if not shensimayi:hasFlag("JilyueZhiheng") and shensimayi:canDiscard(shensimayi, "he") then
			table.insert(choices, "zhiheng")
		end
		if not shensimayi:hasFlag("JilyueWansha") then
			table.insert(choices, "wansha")
		end
		table.insert(choices, "cancel")
		if #choices == 1 then
			room:setPlayerFlag(shensimayi, "Global_JilyueFailed") 
			return
		end
		local choice = room:askForChoice(shensimayi, "Jilyue", table.concat(choices, "+"))
		if choice == "cancel" then
			room:addPlayerHistory(shensimayi, "#JilyueCard", -1)
			return
		end
		
		local msg = sgs.LogMessage()
		msg.type, msg.from, msg.arg = "#InvokeSkill", shensimayi, "Jilyue"
		room:sendLog(msg)
		shensimayi:loseMark("@bear")
		if shensimayi:ownSkill(cardUse.card:showSkill()) and not shensimayi:hasShownSkill(cardUse.card:showSkill()) then
			shensimayi:showGeneral(shensimayi:inHeadSkills(cardUse.card:showSkill()))
		end
		room:notifySkillInvoked(shensimayi, "Jilyue")
		if shensimayi:isDead() then return end
		if choice == "wansha" then
			room:setPlayerFlag(shensimayi, "JilyueWansha")
			room:acquireSkill(shensimayi, "wansha", true, shensimayi:inHeadSkills("Jilyue"))
		else
			room:setPlayerFlag(shensimayi, "JilyueZhiheng")
			room:setPlayerFlag(shensimayi, "JilyueZhihengAudio")  --控制EffectIndex
			room:askForUseCard(shensimayi, "@@Jilyue", "@Jilyue-zhiheng", -1, sgs.Card_MethodDiscard)
			room:setPlayerFlag(shensimayi, "-JilyueZhihengAudio")
		end
	end,
}
JilyueVS = sgs.CreateViewAsSkill{
	name = "Jilyue",
	view_filter = function(self, selected, to_select)
		if sgs.Sanguosha:getCurrentCardUseReason() == sgs.CardUseStruct_CARD_USE_REASON_PLAY then
			return false
		elseif sgs.Sanguosha:getCurrentCardUsePattern() == "@@Jilyue" then  --重写ZhihengCard::viewFilter
			if #selected >= sgs.Self:getMaxHp() then
				return not sgs.Self:isJilei(to_select) and sgs.Self:getTreasure() and sgs.Self:getTreasure():isKindOf("Luminouspearl")
						and to_select ~= sgs.Self:getTreasure() and not table.contains(selected, sgs.Self:getTreasure())
			end
			return not sgs.Self:isJilei(to_select) and #selected < sgs.Self:getMaxHp()
		end
		return false
	end,
	view_as = function(self, cards)
		if sgs.Sanguosha:getCurrentCardUseReason() == sgs.CardUseStruct_CARD_USE_REASON_PLAY then
			local card = JilyueCard:clone()
			card:setShowSkill(self:objectName())
			return card
		elseif sgs.Sanguosha:getCurrentCardUsePattern() == "@@Jilyue" and #cards > 0 then
			local zhiheng_card = sgs.Sanguosha:cloneSkillCard("ZhihengCard")
			zhiheng_card:setSkillName(self:objectName())
			for _,c in ipairs(cards) do
				zhiheng_card:addSubcard(c)
			end
			return zhiheng_card
		end
		return nil
	end,
	enabled_at_play = function(self, player)
		if player:getMark("@bear") >= math.max(getKingdomCount(player), 1) then
			return (not player:hasFlag("JilyueZhiheng") and player:canDiscard(player, "he")) or not player:hasFlag("JilyueWansha")
		end
		return false
	end,
	enabled_at_response = function(self, player, pattern)
		return pattern == "@@Jilyue"  --v2源码是@@zhiheng，但是需要耦合至制衡的isEnabledAtResponse（因为这种pattern调用的VSSkill是制衡不是极略）
	end,
}
Jilyue = sgs.CreateTriggerSkill{
	name = "Jilyue",
	--can_preshow = true,
	events = {sgs.CardUsed, sgs.AskForRetrial, sgs.Damaged, sgs.Dying, sgs.EventPhaseChanging},
	frequency = sgs.Skill_NotFrequent,
	view_as_skill = JilyueVS,
	on_record = function(self, event, room, player, data)
		if event == sgs.EventPhaseChanging and data:toPhaseChange().to == sgs.Player_NotActive and player:hasFlag("JilyueWansha") then
			room:detachSkillFromPlayer(player, "wansha", false, true)
		end
	end,
	can_trigger = function(self, event, room, player, data, ask_who)
		if not (player and player:isAlive() and player:hasSkill(self)) then return "" end
		if event == sgs.EventPhaseChanging then return "" end
		if player:getMark("@bear") < math.max(getKingdomCount(player), 1) then return "" end
		local skill = getJilyueSkill(event)
		if skill then
			--[[player:setTag("JilyueCurrentSkill", sgs.QVariant(skill:objectName()))  --不行的话考虑用property
			local trigger_str_list = skill:triggerable(event, room, player, data, ask_who)
			player:setTag("JilyueCurrentSkill", sgs.QVariant())]]  --以上方法一直提示参数错误，原因不明（即使加了ViewHas）
			local canTrigger = ""
			if skill:objectName() == "guicai" then  --手动重写triggerable
				if not player or player:isDead() then canTrigger = ""  --Replacement for TriggerSkill::triggerable
				elseif player:isKongcheng() and player:getHandPile():isEmpty() then canTrigger = ""
				else canTrigger = self:objectName()
				end
			elseif skill:objectName() == "fangzhu" then
				if player and player:isAlive() then canTrigger = self:objectName() end
			elseif skill:objectName() == "jizhi" then
				if not player or player:isDead() then canTrigger = ""
				else
					local use = data:toCardUse()
					if use.card and use.card:isNDTrick() then
						if not use.card:isVirtualCard() or use.card:getSubcards():isEmpty() then
							canTrigger = self:objectName()
						elseif use.card:getSubcards():length() == 1 then
							if sgs.Sanguosha:getCard(use.card:getEffectiveId()):objectName() == use.card:objectName() then
								canTrigger = self:objectName()
							end
						end
					end
				end
			elseif skill:objectName() == "wansha" and not player:hasFlag("JilyueWansha") then  --单独处理
				if player and player:isAlive() then
					if room:getCurrent() == player and player:isAlive() and player:getPhase() ~= sgs.Player_NotActive then
						canTrigger = self:objectName()
					end
				end
			end
			return canTrigger
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		local skill = getJilyueSkill(event)
		if skill then
			if skill:cost(event, room, player, data, ask_who) then
				player:loseMark("@bear")
				return true
			end
		end
		return false
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		local skill = getJilyueSkill(event)
		if skill then
			if skill:objectName() == "wansha" then
				room:setPlayerFlag(player, "JilyueWansha")
				room:acquireSkill(player, "wansha", true, player:inHeadSkills(self))
			else  --完杀也执行effect的话提示信息会发两遍，因为完杀随后还会触发
				skill:effect(event, room, player, data, ask_who)
			end
		end
	end,
}
JilyueClear = sgs.CreateTriggerSkill{
	name = "#Jilyue-clear",
	events = {sgs.EventPhaseEnd},
	priority = 0,
	global = true,
	on_record = function(self, event, room, player, data)
		if player:getPhase() ~= sgs.Player_Play then return end
		if player:hasFlag("JilyueZhiheng") then
			room:setPlayerFlag(player, "-JilyueZhiheng")
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
ShenSiMaYi:addSkill(Jilyue)
ShenSiMaYi:addSkill(JilyueClear)
sgs.insertRelatedSkills(extensionGod, "Jilyue", "#Jilyue-clear")

--[[
	技能名：连破
	技能：Lianpo
	描述：一名角色的回合结束后，若你于此回合内杀死过至少一名角色，你可以获得一个额外的回合。
	状态：验证通过
]]--
LianpoRecord = sgs.CreateTriggerSkill{
	name = "#Lianpo-record",
	events = {sgs.Death},
	global = true,
	on_record = function(self, event, room, player, data)
		if event == sgs.Death then
			local death = data:toDeath()
			if death.who ~= player then return end
			local killer = death.damage and death.damage.from or nil
			local current = room:getCurrent()
			if killer and current and current:getPhase() ~= sgs.Player_NotActive then
				killer:addMark("LianpoCount")
				if killer:hasShownSkill("Lianpo") then  --源码误写成player
					local msg = sgs.LogMessage()
					msg.type, msg.from, msg.arg = "#LianpoRecord", killer, current:getGeneralName()
					msg.to:append(player)
					room:sendLog(msg)
				end
			end
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
Lianpo = sgs.CreateTriggerSkill{
	name = "Lianpo",
	can_preshow = true,
	events = {sgs.EventPhaseStart},
	frequency = sgs.Skill_NotFrequent,
	can_trigger = function(self, event, room, player, data)
		if player:getPhase() == sgs.Player_NotActive then
			local skill_list = {}
			local name_list = {}
			for _, p in sgs.qlist(room:findPlayersBySkillName(self:objectName())) do
				if p:getMark("LianpoCount") > 0 then
					table.insert(skill_list, self:objectName())
					table.insert(name_list, p:objectName())
				end
			end
			return table.concat(skill_list, "|"), table.concat(name_list, "|")
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		if ask_who:askForSkillInvoke(self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), ask_who)
			return true
		end
		return false
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		local msg = sgs.LogMessage()
		msg.type, msg.from, msg.arg = "#LianpoCanInvoke", ask_who, ask_who:getMark("LianpoCount")
		room:sendLog(msg)
		ask_who:gainAnExtraTurn()
	end,
}
LianpoClear = sgs.CreateTriggerSkill{
	name = "#Lianpo-clear",
	events = {sgs.EventPhaseStart},
	priority = -1,
	global = true,
	on_record = function(self, event, room, player, data)
		if player:getPhase() == sgs.Player_NotActive then
			for _, p in sgs.qlist(room:getAllPlayers()) do
				if p:getMark("LianpoCount") > 0 then
					room:setPlayerMark(p, "LianpoCount", 0)
				end
			end
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
ShenSiMaYi:addSkill(Lianpo)
ShenSiMaYi:addSkill(LianpoRecord)
ShenSiMaYi:addSkill(LianpoClear)
sgs.insertRelatedSkills(extensionGod, "Lianpo", "#Lianpo-record", "#Lianpo-clear")

----------------------------------------------一将成名----------------------------------------------

extensionYJCM = sgs.Package("YJCM", sgs.Package_GeneralPack)

--[[ YJ 001 曹植
	武将：CaoZhi
	武将名：曹植
	体力上限：3
	武将技能：
		落英：当其他角色的牌因判定或弃置而置入弃牌堆后，你可以获得其中至少一张梅花牌。
		酒诗：当你需要使用【酒】时，若你处于平置状态，你可以叠置，视为使用一张【酒】；当你受到伤害扣减体力前，若你处于叠置状态，你可以于伤害结算后将武将牌改为平置状态。 
	状态：复制手册
]]--
CaoZhi = sgs.General(extensionYJCM, "CaoZhi", "wei", 3, true)
CaoZhi:addCompanion("caopi")
CaoZhi:addCompanion("zhenji")

--[[
	技能名：落英
	技能：Luoying
	描述：当其他角色的牌因判定或弃置而置入弃牌堆后，你可以获得其中至少一张梅花牌。
	状态：复制手册
]]--
Luoying = sgs.CreateTriggerSkill{
	name = "Luoying",
	can_preshow = true,
	events = {sgs.CardsMoveOneTime},
	frequency = sgs.Skill_Frequent,
 	can_trigger = function(self, event, room, player, data)
		if event == sgs.CardsMoveOneTime then
			if not player or player:isDead() then return "" end
			local move = data:toMoveOneTime()
			if move.from and move.from:objectName() ~= player:objectName() then
				local dis = (bit32.band(move.reason.m_reason, sgs.CardMoveReason_S_MASK_BASIC_REASON) == sgs.CardMoveReason_S_REASON_DISCARD)
				local jud = (move.reason.m_reason == sgs.CardMoveReason_S_REASON_JUDGEDONE)
				local LuoyingRemains = {}
				
				if jud and move.from_places:contains(sgs.Player_PlaceJudge) and move.to_place == sgs.Player_DiscardPile then  --不需要用栈的判定牌
					if player:hasSkill(self) then
						for i, id in sgs.qlist(move.card_ids) do
							if move.from_places:at(i) == sgs.Player_PlaceJudge and room:getCardPlace(id) == sgs.Player_DiscardPile
								and sgs.Sanguosha:getCard(id):getSuit() == sgs.Card_Club then
								table.insert(LuoyingRemains, id)
							end
						end
					end
				elseif dis and move.from_places:contains(sgs.Player_PlaceTable) and move.to_place == sgs.Player_DiscardPile then  --条件B（弃置）
					local LuoyingStack_str = player:getTag("LuoyingStack"):toString()
					if LuoyingStack_str == "" then return end
					local LuoyingStack = LuoyingStack_str:split("|")
					
					if player:hasSkill(self) and player:getTag("LuoyingPopIndex"):toInt() ~= #LuoyingStack then
						local LuoyingOneTime_str = LuoyingStack[#LuoyingStack]
						local LuoyingOneTime = LuoyingOneTime_str:split("+")
						table.removeAll(LuoyingOneTime, "-1")
						for i, id in sgs.qlist(move.card_ids) do
							if table.contains(LuoyingOneTime, tostring(id)) and room:getCardPlace(id) == sgs.Player_DiscardPile
								and sgs.Sanguosha:getCard(id):getSuit() == sgs.Card_Club then
								table.insert(LuoyingRemains, id)
							end
						end
					end
				end
				
				if next(LuoyingRemains) then
					room:setPlayerProperty(player, "LuoyingToGet", sgs.QVariant(table.concat(LuoyingRemains, "+")))
					return self:objectName()
				end
			end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		if not player or player:isDead() then return "" end
		local move = data:toMoveOneTime()
		if (bit32.band(move.reason.m_reason, sgs.CardMoveReason_S_MASK_BASIC_REASON) == sgs.CardMoveReason_S_REASON_DISCARD) then
			local LuoyingStack_str = player:getTag("LuoyingStack"):toString()
			local LuoyingStack = LuoyingStack_str:split("|")
			player:setTag("LuoyingPopIndex", sgs.QVariant(#LuoyingStack))
		end
		
		local LuoyingToGet = player:property("LuoyingToGet"):toString():split("+")
		local cards = sgs.IntList()
		for _, idstring in ipairs(LuoyingToGet) do 
			cards:append(tonumber(idstring))
		end
		
		local ids = room:notifyChooseCards(player, cards, self:objectName(), sgs.Player_DiscardPile, sgs.Player_PlaceTable, cards:length(), 0, "@Luoying-get")
		room:setPlayerProperty(player, "LuoyingToGet", sgs.QVariant())
		if ids:length() > 0 then
			local LuoyingGet = sgs.QList2Table(ids)
			room:setPlayerProperty(player, "LuoyingGet", sgs.QVariant(table.concat(LuoyingGet, "+")))
			local log = sgs.LogMessage()
			log.type = "#InvokeSkill"
			log.from = player
			log.arg = self:objectName()
			room:sendLog(log)
			local skin_id = player:property((player:inHeadSkills(self) and "head" or "deputy") .. "_skin_id"):toInt()
			if skin_id == 1 then
				room:broadcastSkillInvoke(self:objectName(), matchPlayerName(move.from, "zhenji") and 2 or 1, player)
			else
				room:broadcastSkillInvoke(self:objectName(), player)
			end
			return true
		end
		return false
	end,
	on_effect = function(self, event, room, player, data)
		local move = data:toMoveOneTime()
		local dummy = sgs.DummyCard()
		local LuoyingGet = player:property("LuoyingGet"):toString():split("+")
		room:setPlayerProperty(player, "LuoyingGet", sgs.QVariant())
		for _, idstring in ipairs(LuoyingGet) do
			dummy:addSubcard(tonumber(idstring))
		end
		room:obtainCard(player, dummy)
		dummy:deleteLater()
		return false 
	end,
}
LuoyingRecord = sgs.CreateTriggerSkill{
	name = "#Luoying-record",
	events = {sgs.CardsMoveOneTime},
	priority = 1,
	global = true,
	on_record = function(self, event, room, player, data)
		if not (player and player:isAlive()) then return end
		local move = data:toMoveOneTime()
		if move.from and move.from:objectName() ~= player:objectName() then
			local dis = (bit32.band(move.reason.m_reason, sgs.CardMoveReason_S_MASK_BASIC_REASON) == sgs.CardMoveReason_S_REASON_DISCARD)
			local jud = (move.reason.m_reason == sgs.CardMoveReason_S_REASON_JUDGEDONE)
			if not dis then return end  --判定无需用栈，直接即时判断即可
			
			if (move.from_places:contains(sgs.Player_PlaceHand) or move.from_places:contains(sgs.Player_PlaceEquip))
				and move.to_place == sgs.Player_PlaceTable then  --条件A（弃置）
				local card_ids = {-1}
				for i, id in sgs.qlist(move.card_ids) do
					if (move.from_places:at(i) == sgs.Player_PlaceHand or move.from_places:at(i) == sgs.Player_PlaceEquip) and room:getCardPlace(id) == sgs.Player_PlaceTable then
						table.insert(card_ids, id)
					end
				end
				
				local LuoyingStack_str = player:getTag("LuoyingStack"):toString()
				local LuoyingStack = LuoyingStack_str:split("|")
				table.removeAll(LuoyingStack, "")
				table.insert(LuoyingStack, table.concat(card_ids, "+"))
				player:setTag("LuoyingStack", sgs.QVariant(table.concat(LuoyingStack, "|")))
			elseif move.from_places:contains(sgs.Player_PlaceTable) and move.to_place == sgs.Player_DiscardPile then  --条件B（弃置）
				local LuoyingStack_str = player:getTag("LuoyingStack"):toString()			--注：判定区的锦囊被弃置的话，Table到DiscardPile时没有move.from
				if LuoyingStack_str == "" then return end									--因此不用担心这种情况没入栈却出栈了，因为不满足条件B
				local LuoyingStack = LuoyingStack_str:split("|")
				
				table.remove(LuoyingStack, #LuoyingStack)
				if next(LuoyingStack) then player:setTag("LuoyingStack", sgs.QVariant(table.concat(LuoyingStack, "|")))
				else player:removeTag("LuoyingStack") end
				player:removeTag("LuoyingPopIndex")
			end
		end
	end,
 	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
CaoZhi:addSkill(Luoying)
CaoZhi:addSkill(LuoyingRecord)
sgs.insertRelatedSkills(extensionYJCM, "Luoying", "#Luoying-record")

--[[
	技能名：酒诗
	技能：Jiushi
	描述：当你需要使用【酒】时，若你处于平置状态，你可以叠置，视为使用一张【酒】；当你受到伤害扣减体力前，若你处于叠置状态，你可以于伤害结算后将武将牌改为平置状态。
	状态：复制手册并大改
]]--
JiushiVS = sgs.CreateZeroCardViewAsSkill{   
	name = "Jiushi",
	
	view_as = function(self)
		local analeptic = sgs.Sanguosha:cloneCard("analeptic", sgs.Card_NoSuit, 0)
		analeptic:setSkillName(self:objectName())
		analeptic:setShowSkill(self:objectName())
		return analeptic
	end,

	enabled_at_play = function(self, player)
		return sgs.Analeptic_IsAvailable(player) and player:faceUp()
	end,

	enabled_at_response = function(self, player, pattern)
		return string.find(pattern, "analeptic") and player:faceUp()
	end
}
Jiushi = sgs.CreateTriggerSkill{
	name = "Jiushi",
	can_preshow = false,
	events = {sgs.DamageComplete, sgs.ChoiceMade},
	view_as_skill = JiushiVS,
	on_record = function(self, event, room, player, data)  --此段代码是在发动技能后才执行的on_record，因此不用global
		if not (player and player:isAlive()) then return "" end
		if event == sgs.ChoiceMade then
			if data:toString() == "" then  --只能这样判断是否为CardUseStruct
				if data:toCardUse().card and data:toCardUse().card:getSkillName() == self:objectName() then
					player:turnOver()
					if player:ownSkill(self:objectName()) and not player:hasShownSkill(self:objectName()) then
						player:showGeneral(player:inHeadSkills(self:objectName()))  --作为消耗，亮将时机应该与翻面同时
					end
				end
			else
				local str = data:toString():split(":")
				if (#str >= 4) and (str[1] == "peach") and (str[2] == player:objectName()) then
					table.remove(str, 3)
					table.remove(str, 2)
					table.remove(str, 1)  --因为虚拟卡的字符串本来就有冒号，split就被分开了，需要重新合并
					local analeptic = sgs.Card_Parse(table.concat(str, ":"))
					if analeptic and analeptic:getSkillName() == self:objectName() then
						player:turnOver()
						if player:ownSkill(self:objectName()) and not player:hasShownSkill(self:objectName()) then
							player:showGeneral(player:inHeadSkills(self:objectName()))
						end
					end
				end
			end
		end
	end,
	can_trigger = function(self, event, room, player, data)
		if not (player and player:isAlive()) then return "" end
		if event == sgs.DamageComplete and player:hasSkill(self:objectName()) then
			local facedown = player:getTag("PredamagedFace"):toBool()
			if facedown and not player:faceUp() then return self:objectName() end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		if player:askForSkillInvoke(self:objectName(), data) then
			local skin_id = player:property((player:inHeadSkills(self) and "head" or "deputy") .. "_skin_id"):toInt()
			room:broadcastSkillInvoke(self:objectName(), (skin_id == 1) and 3 or -1, player)
			return true 
		end
		return false 
	end,
	on_effect = function(self, event, room, player, data)
		player:turnOver()
		return false 
	end,
}
JiushiRecord = sgs.CreateTriggerSkill{
	name = "#Jiushi-record",
	events = {sgs.PreDamageDone},
	global = true,
	on_record = function(self, event, room, player, data)
		if not (player and player:isAlive()) then return "" end
		if event == sgs.PreDamageDone then
			player:setTag("PredamagedFace", sgs.QVariant(not player:faceUp()))
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
JiushiClear = sgs.CreateTriggerSkill{
	name = "#Jiushi-clear",
	events = {sgs.DamageComplete},
	priority = 1,
	global = true,
	on_record = function(self, event, room, player, data)
		player:removeTag("PredamagedFace")
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
CaoZhi:addSkill(Jiushi)
CaoZhi:addSkill(JiushiRecord)
CaoZhi:addSkill(JiushiClear)
sgs.insertRelatedSkills(extensionYJCM, "Jiushi", "#Jiushi-record", "#Jiushi-clear")

----------------------------------------------------------------------------------------------------

--[[ YJ 002 陈宫
	武将：ChenGong
	武将名：陈宫
	体力上限：3
	武将技能：
		明策：出牌阶段限一次，你可以将一张装备牌或【杀】交给一名其他角色，若如此做，该角色可以视为对其攻击范围内你选择的一名角色使用【杀】，否则其摸一张牌。
		智迟：锁定技，当你于回合外受到伤害后，【杀】和普通锦囊牌对你无效，直到回合结束。
	状态：验证通过
]]--
ChenGong = sgs.General(extensionYJCM, "ChenGong", "qun", 3, true)
ChenGong:addCompanion("lvbu")
ChenGong:addCompanion("LyuBu_LB")

--[[
	技能名：明策
	技能：Mingce
	描述：出牌阶段限一次，你可以将一张装备牌或【杀】交给一名其他角色，若如此做，该角色可以视为对其攻击范围内你选择的一名角色使用【杀】，否则其摸一张牌。
	状态：验证通过
]]--
function findMingceTarget(source)
	local slash_targets = sgs.PlayerList()
	if sgs.Slash_IsAvailable(source) then
		for _, p in sgs.qlist(source:getAliveSiblings()) do
			if source:canSlash(p) then  --严格来说，进行杀的合法性检测时，应该假设明策牌已经给出去了。但是这无法实现
				slash_targets:append(p)
			end
		end
	end
	return slash_targets
end
MingceCard = sgs.CreateSkillCard{
	name = "MingceCard",
	skill_name = "Mingce",
    will_throw = false,
    handling_method = sgs.Card_MethodNone,
	filter = function(self, selected, to_select)
		if #selected == 0 then 
			return to_select:objectName() ~= sgs.Self:objectName()
		elseif #selected == 1 then
			return findMingceTarget(selected[1]):contains(to_select)
		end
		return false
	end,
	feasible = function(self, selected)
		if #selected == 1 then
			return findMingceTarget(selected[1]):isEmpty()
		elseif #selected == 2 then
			return true
		end
		return false
	end,
	about_to_use = function(self, room, card_use)  --翻译Card::onUse
		local player = card_use.from
		local target = card_use.to:first()
		--源码处理SkillPosition的那段未提供lua接口
		
		local msg = sgs.LogMessage()
		msg.from = player
		msg.to:append(target)
		msg.type = "#UseCard"
		msg.card_str = card_use.card:toString(true)
		room:sendLog(msg)
		
		if card_use.to:length() == 2 then
			local dat = sgs.QVariant()
			dat:setValue(card_use.to:last())
			target:setTag("MingceTarget", dat)
			local msg = sgs.LogMessage()
			msg.type = "#CollateralSlash"
			msg.from = player
			msg.to:append(card_use.to:last())
			room:sendLog(msg)
			room:doAnimate(1, target:objectName(), card_use.to:last():objectName())  --S_ANIMATE_INDICATE
			card_use.to:removeAt(1)
		end
		
		local data = sgs.QVariant()
		data:setValue(card_use)
		local thread = room:getThread()
		assert(thread)
		thread:trigger(sgs.PreCardUsed, room, player, data)
		card_use = data:toCardUse()
		
		--self:extraCost(room, card_use)  --无法将self转化为SkillCard
		local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_GIVE, player:objectName(), target:objectName(), "Mingce", "")
		room:obtainCard(target, self, reason)
		if player:ownSkill(card_use.card:showSkill()) and not player:hasShownSkill(card_use.card:showSkill()) then
			player:showGeneral(player:inHeadSkills(card_use.card:showSkill()))
		end
		
		thread:trigger(sgs.CardUsed, room, player, data)
		thread:trigger(sgs.CardFinished, room, player, data)
	end,
	on_effect = function(self, effect)
		local room = effect.to:getRoom()
		local source = effect.from
		local target = effect.to
		if target:isDead() then return false end
		local choicelist = {"draw"}
		local slash_target = target:getTag("MingceTarget"):toPlayer()
		target:removeTag("MingceTarget")
		if slash_target and target:canSlash(slash_target, nil, false) then
			table.insert(choicelist, "use")
		end
		local choice = room:askForChoice(target, "Mingce", table.concat(choicelist, "+"))
		
		if choice == "use" and slash_target then
			local slash = sgs.Sanguosha:cloneCard("slash", sgs.Card_NoSuit, 0)
			slash:setSkillName("_Mingce")
			room:useCard(sgs.CardUseStruct(slash, target, slash_target), false)
		elseif choice == "draw" then
			target:drawCards(1, "Mingce")
		end
	end,
	on_turn_broken = function(self, function_name, room, data)
		local target
		if function_name == "about_to_use" or function_name == "extra_cost" then
			target = data:toCardUse().to:first()
		elseif function_name == "on_effect" then
			target = data:toCardEffect().to
		end
		target:removeTag("MingceTarget")
	end,
}
Mingce = sgs.CreateOneCardViewAsSkill{
	name = "Mingce",
	filter_pattern = "EquipCard,Slash",
	view_as = function(self, card)
        local mingce_card = MingceCard:clone()
		mingce_card:addSubcard(card)
        mingce_card:setShowSkill(self:objectName())
        return mingce_card
	end,
	enabled_at_play = function(self, player)
        return not player:hasUsed("#MingceCard")
	end,
}
ChenGong:addSkill(Mingce)

--[[
	技能名：智迟
	技能：Zhichi
	描述：锁定技，当你于回合外受到伤害后，【杀】和普通锦囊牌对你无效，直到回合结束。
	状态：验证通过
]]--
Zhichi = sgs.CreateTriggerSkill{
	name = "Zhichi",
	can_preshow = true,
	events = {sgs.Damaged},
	frequency = sgs.Compulsory,
	can_trigger = function(self, event, room, player, data)
		if not (player and player:isAlive() and player:hasSkill(self:objectName())) then return "" end
		local current = room:getCurrent()
		return (current and (current:objectName() ~= player:objectName())) and self:objectName() or ""
	end,
	on_cost = function(self, event, room, player, data)
		if player:hasShownSkill(self:objectName()) or player:askForSkillInvoke(self:objectName()) then
			room:broadcastSkillInvoke(self:objectName(), 1, player)
			return true
		end
		return false
	end,
	on_effect = function(self, event, room, player, data)
		if player:getMark("@late") == 0 then
			room:addPlayerMark(player, "@late")
		end
		local msg = sgs.LogMessage()
		msg.type, msg.from = "#ZhichiDamaged", player
		room:sendLog(msg)
	end,
}
ZhichiProtect = sgs.CreateTriggerSkill{
	name = "#Zhichi-protect",
	can_preshow = false,
	frequency = sgs.Skill_Compulsory,
	events = {sgs.CardEffected, sgs.SlashEffected},
	can_trigger = function(self, event, room, player, data)
		if not (player and player:isAlive()) then return "" end
		if event == sgs.CardEffected then
			local effect = data:toCardEffect()
			if effect.card:isNDTrick() then
				return (effect.to:getMark("@late") > 0) and self:objectName(), effect.to or ""
			end
		elseif event == sgs.SlashEffected then
			local effect = data:toSlashEffect()
			return (effect.to:getMark("@late") > 0) and self:objectName(), effect.to or ""
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		room:broadcastSkillInvoke("Zhichi", 2, ask_who)
		room:notifySkillInvoked(ask_who, "Zhichi")
		return true
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		local msg = sgs.LogMessage()
		msg.type, msg.from, msg.arg = "#ZhichiAvoid", ask_who, "Zhichi"
		room:sendLog(msg)
		return true
	end,
}
ZhichiClear = sgs.CreateTriggerSkill{
	name = "#Zhichi-clear",
	events = {sgs.EventPhaseStart},
	priority = 8,
	global = true,
	on_record = function(self, event, room, player, data)
		if player:getPhase() ~= sgs.Player_NotActive then return end
		for _,p in sgs.qlist(room:getAllPlayers()) do
			if p:getMark("@late") > 0 then
				room:setPlayerMark(p, "@late", 0)
			end
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end
}
ChenGong:addSkill(Zhichi)
ChenGong:addSkill(ZhichiProtect)
ChenGong:addSkill(ZhichiClear)
sgs.insertRelatedSkills(extensionYJCM, "Zhichi", "#Zhichi-protect", "#Zhichi-clear")

----------------------------------------------------------------------------------------------------

--[[ YJ 003 法正
	武将：FaZheng
	武将名：法正
	体力上限：3
	武将技能：
		恩怨：当你获得一名其他角色的两张或更多的牌后，你可以令其摸一张牌；当你受到1点伤害后，你可以令伤害来源选择一项：1. 将一张手牌交给你；2. 失去1点体力。 
		眩惑：摸牌阶段开始时，你可以放弃摸牌并选择一名其他角色，令其摸两张牌，然后该角色可以对其攻击范围内由你选择的一名角色使用一张【杀】，否则你获得其两张牌。
	状态：复制手册
]]--
FaZheng = sgs.General(extensionYJCM, "FaZheng", "shu", 3, true)
FaZheng:addCompanion("huangzhong")
FaZheng:addCompanion("HuangZhong_LB")

--[[
	技能名：恩怨
	技能：Enyuan
	描述：当你获得一名其他角色的两张或更多的牌后，你可以令其摸一张牌；当你受到1点伤害后，你可以令伤害来源选择一项：1. 将一张手牌交给你；2. 失去1点体力。
	状态：复制手册并修bug
]]--
Enyuan = sgs.CreateTriggerSkill{
	name = "Enyuan",
	can_preshow = true,
	frequency = sgs.Skill_NotFrequent,
	events = {sgs.CardsMoveOneTime, sgs.Damaged},
	
	can_trigger = function(self, event, room, player, data)
		if not (player and player:isAlive() and player:hasSkill(self:objectName())) then return "" end
		if event == sgs.Damaged then
			local trigger_list, damage = {}, data:toDamage()
			if damage.from and damage.from:isAlive() then
				for i = 1, damage.damage do
					table.insert(trigger_list, self:objectName())
				end
			end
			return table.concat(trigger_list, ",")
		elseif event == sgs.CardsMoveOneTime then
			local move = data:toMoveOneTime()
			if move.to and move.to:objectName() == player:objectName() and move.from and move.from:isAlive() and (move.from:objectName() ~= player:objectName()) and move.to_place == sgs.Player_PlaceHand
					and move.reason.m_reason ~= sgs.CardMoveReason_S_REASON_PREVIEWGIVE then
				local count = 0
				for i = 0, move.from_places:length() - 1 do
					if (move.from_places:at(i) == sgs.Player_PlaceHand) or (move.from_places:at(i) == sgs.Player_PlaceEquip) then
						count = count + 1
						if count >= 2 then return self:objectName() end
					end
				end
			end
		end
		return ""
	end,
	
	on_cost = function(self, event, room, player, data)
		if player:askForSkillInvoke(self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), (event == sgs.Damaged and 2 or 1), player)
			return true 
		end
		return false 
	end,
	
	on_effect = function(self, event, room, player, data)
		if event == sgs.Damaged then
			local damage = data:toDamage()
			if player and player:isAlive() and not damage.from:isKongcheng() then
				local card = room:askForExchange(damage.from, self:objectName(), 1, 0, self:objectName().."Give::"..player:objectName(), "", ".|.|.|hand")
				if card then
					local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_GIVE, damage.from:objectName(), player:objectName(), self:objectName(), "")
					room:obtainCard(player, card, reason, false)
					return false
				end
			end
			room:loseHp(damage.from)
		elseif event  == sgs.CardsMoveOneTime then
			local move, source = data:toMoveOneTime()
			for _, p in sgs.qlist(room:getAlivePlayers()) do
				if p:objectName() == move.from:objectName() then source = p end
			end
			if source then source:drawCards(1, self:objectName()) end
		end
		return false 
	end,
}
FaZheng:addSkill(Enyuan)

--[[
	技能名：眩惑
	技能：Xuanhuo
	描述：摸牌阶段开始时，你可以放弃摸牌并选择一名其他角色，令其摸两张牌，然后该角色可以对其攻击范围内由你选择的一名角色使用一张【杀】，否则你获得其两张牌。
	状态：复制手册
]]--
Xuanhuo = sgs.CreateTriggerSkill{
	name = "Xuanhuo",
	can_preshow = true,
	frequency = sgs.Skill_NotFrequent,
	events = sgs.EventPhaseStart,
	
	can_trigger = function(self, event, room, player, data)
		if player and player:isAlive() and player:hasSkill(self:objectName()) and player:getPhase() == sgs.Player_Draw then
			if true then return self:objectName() end
		end
		return ""
	end,
	
	on_cost = function(self, event, room, player, data)
		local target = room:askForPlayerChosen(player, room:getOtherPlayers(player), self:objectName(), self:objectName().."-invoke", true, true)
		if target then
			local target_data = sgs.QVariant()
			target_data:setValue(target)
			player:setTag(self:objectName(), target_data)
			room:broadcastSkillInvoke(self:objectName(), 1, player)
			return true 
		end
		return false 
	end,
	
	on_effect = function(self, event, room, player, data)
		local target = player:getTag(self:objectName()):toPlayer()
		player:removeTag(self:objectName())
		target:drawCards(2, self:objectName())

		if player:isAlive() and target:isAlive() then
			local victims, victim = sgs.SPlayerList()
			for _, p in sgs.qlist(room:getOtherPlayers(target)) do
				if target:canSlash(p) then victims:append(p) end
			end
			if not victims:isEmpty() then
				victim = room:askForPlayerChosen(player, victims, self:objectName().."_slash", "@dummy-slash2:"..target:objectName())
				local log = sgs.LogMessage()
				log.type = "#CollateralSlash";
				log.from = player
				log.to:append(victim)
				room:sendLog(log)
			end

			if not victim or not room:askForUseSlashTo(target, victim, self:objectName().."-slash::"..victim:objectName()) then		
				room:broadcastSkillInvoke(self:objectName(), 2, player)
				if not target:isNude() then
					local cards = room:askForCardsChosen(player, target, "he^false|he^false", self:objectName())
					local dummy = sgs.DummyCard()
					dummy:addSubcards(cards)
					room:obtainCard(player, dummy, sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_EXTRACTION, player:objectName(), target:objectName(), self:objectName(), ""), false)
					dummy:deleteLater() 
				end
			end
		end
		return true
	end,
}
FaZheng:addSkill(Xuanhuo)

----------------------------------------------------------------------------------------------------

--[[ YJ 004 高顺
	武将：GaoShun
	武将名：高顺
	体力上限：4
	武将技能：
		陷阵：出牌阶段限一次，你可以与一名其他角色拼点：若你赢，本回合，该角色的防具无效，你无视与该角色的距离，你对该角色使用【杀】无次数限制；若你没赢，你不能使用【杀】，直到回合结束。
		禁酒：锁定技，你的【酒】视为【杀】。
	状态：验证通过
]]--
GaoShun = sgs.General(extensionYJCM, "GaoShun", "qun", 4, true)

--[[
	技能名：陷阵
	技能：Xianzhen
	描述：出牌阶段限一次，你可以与一名其他角色拼点：若你赢，本回合，该角色的防具无效，你无视与该角色的距离，你对该角色使用【杀】无次数限制；若你没赢，你不能使用【杀】，直到回合结束。
	状态：验证通过
]]--
XianzhenCard = sgs.CreateSkillCard{  --QinggangTag（？）
	name = "XianzhenCard", 
	skill_name = "Xianzhen",
	filter = function(self, targets, to_select)
		return #targets == 0 and (not to_select:isKongcheng()) and to_select:objectName() ~= sgs.Self:objectName()
	end,
	extra_cost = function(self, room, use)
		local pd = sgs.PindianStruct()
		pd = use.from:pindianSelect(use.to:first(), "Xianzhen")
		local d = sgs.QVariant()
		d:setValue(pd)
		use.from:setTag("Xianzhen_pd", d)
	end,
	on_effect = function(self, effect)
		local room = effect.from:getRoom()
		local source = effect.from
		local target = effect.to
		local pd = source:getTag("Xianzhen_pd"):toPindian()
		source:removeTag("Xianzhen_pd")
		if pd then
			local success = source:pindian(pd)
			pd = nil
			if success then
				local list = source:getTag("XianzhenTargets"):toList() or sgs.VariantList()
				local to = sgs.QVariant()
				to:setValue(target)
				if list:contains(to) then return end
				list:append(to)
				source:setTag("XianzhenTargets", sgs.QVariant(list))
				if source:isAlive() then
					room:setPlayerFlag(source, "XianzhenSuccess")
					local assignee_list = effect.from:property("extra_slash_specific_assignee"):toString():split("+")
					table.insert(assignee_list, target:objectName())
					room:setPlayerProperty(source, "extra_slash_specific_assignee", sgs.QVariant(table.concat(assignee_list,"+")))
					room:setFixedDistance(source, target, 1)
				end
				if target:isAlive() then room:addPlayerMark(target, "Armor_Nullified") end
			else
				if source:isAlive() then room:setPlayerCardLimitation(source, "use", "Slash", true) end
			end
		end
	end,
}
XianzhenVS = sgs.CreateZeroCardViewAsSkill{
	name = "Xianzhen",
	view_as = function(self)
		local card = XianzhenCard:clone()
		card:setShowSkill(self:objectName())
		card:setSkillName(self:objectName())
		return card
	end, 
	enabled_at_play = function(self, player)
		return not player:hasUsed("#XianzhenCard") and not player:isKongcheng()
	end, 
}
Xianzhen = sgs.CreateTriggerSkill{
	name = "Xianzhen",
	can_preshow = false,
	frequency = sgs.Skill_NotFrequent,
	events = {sgs.EventPhaseStart, sgs.Death},
	priority = 8,
	view_as_skill = XianzhenVS,
	on_record = function(self, event, room, player, data)
		if event == sgs.Death then
			local death = data:toDeath()
			if death.who:objectName() ~= player:objectName() then
				local targets_qvar = player:getTag("XianzhenTargets"):toList()
				local target
				for i, target_qvar in sgs.qlist(targets_qvar) do
					target = target_qvar:toPlayer()
					if target and (death.who:objectName() == target:objectName()) then
						room:setFixedDistance(player, target, -1)  --removeFixedDistance未出现在国战
						targets_qvar:removeAt(i)
						if targets_qvar:isEmpty() then room:setPlayerFlag(player, "-XianzhenSuccess") end
						break
					end
				end
				if targets_qvar:isEmpty() then player:removeTag("XianzhenTargets")
				else player:setTag("XianzhenTargets", sgs.QVariant(targets_qvar)) end
			end
			return
		end
		if player:getPhase() ~= sgs.Player_NotActive then return end
		local target = player:getTag("XianzhenTarget"):toPlayer()
		local targets_qvar = player:getTag("XianzhenTargets"):toList()
		local target
		for i, target_qvar in sgs.qlist(targets_qvar) do
			target = target_qvar:toPlayer()
			if target then
				local assignee_list = player:property("extra_slash_specific_assignee"):toString():split("+")
				table.removeOne(assignee_list, target:objectName())
				room:setPlayerProperty(player, "extra_slash_specific_assignee", sgs.QVariant(table.concat(assignee_list,"+")))
				room:setFixedDistance(player, target, -1)
				room:removePlayerMark(target, "Armor_Nullified")
			end
		end
		player:removeTag("XianzhenTargets")
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end
}
GaoShun:addSkill(Xianzhen)

--[[
	技能名：禁酒
	技能：Jinjiu
	描述：锁定技，你的【酒】视为【杀】。
	状态：验证通过
]]--
JinjiuFilter = sgs.CreateFilterSkill{
	name = "#Jinjiu-filter",
	view_filter = function(self, card)
		local room = sgs.Sanguosha:currentRoom()
		if room then
			local id = card:getEffectiveId()
			local owner = room:getCardOwner(id)
			if owner and owner:hasShownSkill("Jinjiu") then
				return card:objectName() == "analeptic" and (room:getCardPlace(id) == sgs.Player_PlaceEquip or room:getCardPlace(id) == sgs.Player_PlaceHand or room:getCardPlace(id) == sgs.Player_PlaceJudge)
			end
			--[[for _,p in sgs.qlist(room:getPlayers()) do
				if p:hasShownSkill("Jinjiu") then  --源码的ownSkill似乎是bug（化身会有问题）；而且这红颜来的代码会导致只要场上有禁酒，所有没亮的高顺就都受影响
					return card:objectName() == "analeptic"
				end
			end
		else  --似乎是以前FilterSkill作用在客户端时的产物，但是现在filterCards只在服务器触发就没必要了
			for _,p in sgs.qlist(sgs.Self:getAliveSiblings()) do
				if p:ownSkill("Jinjiu") and p:hasShownSkill(self:objectName()) then
					return card:objectName() == "analeptic"
				end
			end]]
		end
	end,
	view_as = function(self, card)
		local slash = sgs.Sanguosha:cloneCard("slash", card:getSuit(), card:getNumber())
		slash:setSkillName("Jinjiu")
		local wrap = sgs.Sanguosha:getWrappedCard(card:getId())
		wrap:takeOver(slash)
		return wrap
	end
}
JinjiuVS = sgs.CreateOneCardViewAsSkill{
	name = "Jinjiu",
	filter_pattern = "Analeptic",  --不设response_or_use是因为木马里的牌不能禁酒
	view_as = function(self, originalCard)
		local slash = sgs.Sanguosha:cloneCard("slash", originalCard:getSuit(), originalCard:getNumber())
		slash:addSubcard(originalCard:getId())
		slash:setSkillName(self:objectName())
		slash:setShowSkill(self:objectName())
		return slash
	end,
	enabled_at_play = function(self, player)
		return not player:hasShownSkill(self:objectName()) and sgs.Slash_IsAvailable(player)
	end,
	enabled_at_response = function(self, player, pattern)
		return not player:hasShownSkill(self:objectName()) and (pattern == "slash")
	end,
}
Jinjiu = sgs.CreateTriggerSkill{
	name = "Jinjiu",
	can_preshow = false,  --设为true则无法使用VSSkill
	events = {sgs.FinishRetrial, sgs.EventAcquireSkill, sgs.EventLoseSkill},
	frequency = sgs.Skill_Compulsory,
	view_as_skill = JinjiuVS,
	on_record = function(self, event, room, player, data)
		if not (player and player:isAlive() and player:hasSkill(self:objectName())) and event ~= sgs.EventLoseSkill then return "" end
		if (event == sgs.EventAcquireSkill and data:toString() == self:objectName())  --注意JinjiuFilter为隐藏技能，因此不会自动在这两个时机filterCards
			or (event == sgs.EventLoseSkill and data:toString() == self:objectName()) then
			room:filterCards(player, player:getCards("he"), true)
		end
	end,
	can_trigger = function(self, event, room, player, data)
		if not player or player:isDead() or not player:hasSkill(self:objectName()) then return "" end
		if event == sgs.FinishRetrial then
			if player:hasShownSkill(self:objectName()) then return "" end
			local judge = data:toJudge()
			if judge.who:objectName() == player:objectName() and judge.card:objectName() == "analeptic" then
				return self:objectName()
			end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
        return player:askForSkillInvoke(self:objectName(), data)
	end,
	on_effect = function(self, event, room, player, data)
		local judge = data:toJudge()
		local cards = sgs.CardList()
		cards:append(judge.card)
        room:filterCards(player, cards, true)
        judge:updateResult()
        return false
	end,
}
GaoShun:addSkill(Jinjiu)
GaoShun:addSkill(JinjiuFilter)
sgs.insertRelatedSkills(extensionYJCM, "Jinjiu", "#Jinjiu-filter")

----------------------------------------------------------------------------------------------------

--[[ YJ 006 马谡
	武将：MaSu_YJ
	武将名：马谡-一将
	体力上限：3
	武将技能：
		心战：出牌阶段限一次，若你的手牌数大于你的体力上限，你可以观看牌堆顶的三张牌，然后你可以展示并获得其中至少一张红桃牌，然后将其余的牌置于牌堆顶。
		挥泪：锁定技，当你死亡时，你令杀死你的角色弃置其所有牌。
	状态：验证通过
]]--
MaSu_YJ = sgs.General(extensionYJCM, "MaSu_YJ", "shu", 3, true)

--[[
	技能名：心战
	技能：Xinzhan
	描述：出牌阶段限一次，若你的手牌数大于你的体力上限，你可以观看牌堆顶的三张牌，然后你可以展示并获得其中至少一张红桃牌，然后将其余的牌置于牌堆顶。
	状态：验证通过
]]--
function XinzhanAsMovePattern(selected, to_select)
	for _,id in ipairs(selected) do
		if sgs.Sanguosha:getCard(id):getSuit() ~= sgs.Card_Heart then
			return false
		end
	end
	if to_select ~= -1 then  --判断是否可以点击确定时，to_select为-1；判断是否可以点击某卡牌时（仅在moveRestricted为真时有效），to_select为被判断的卡牌
		if sgs.Sanguosha:getCard(to_select):getSuit() ~= sgs.Card_Heart then
			return false
		end
	end
	return true
end
XinzhanCard = sgs.CreateSkillCard{
	name = "XinzhanCard",
	skill_name = "Xinzhan",
	target_fixed = true,
	on_use = function(self, room, source, targets)
		local cards = room:getNCards(3)
		local msg = sgs.LogMessage()
		msg.type, msg.from, msg.card_str = "$ViewDrawPile", source, table.concat(sgs.QList2Table(cards), "+")
		room:doNotify(source, sgs.CommandType.S_COMMAND_LOG_SKILL, msg:toVariant())
			
		local hearts = 0
		for _,id in sgs.qlist(cards) do
			if sgs.Sanguosha:getCard(id):getSuit() == sgs.Card_Heart then
				hearts = hearts + 1
			end
		end
		if hearts > 0 then
			local notify_visible_list = sgs.IntList()
			notify_visible_list:append(-1)--源码bug：如果允许移动卡牌顺序，程序没有禁止把非红桃牌移到获得一栏（君孙权之所以能正常用pattern函数是因为它的moveRestricted是true，而这对心战不适用）
			--因此只能在pattern函数里再加判断条件，确保在下面有非红桃牌时无法点确定
			local result = room:askForMoveCards(source, cards, sgs.IntList(), true, "Xinzhan", "XinzhanAsMovePattern", "Xinzhan", 0, hearts, true, false, notify_visible_list)
			if not result.bottom:isEmpty() then
				local dummy = sgs.DummyCard(result.bottom)
				source:obtainCard(dummy)  --描述是展示牌堆顶的牌而不是亮出，因此我觉得不用置入处理区（因此君孙权的结算有问题）
				dummy:deleteLater()
			end
			if not result.top:isEmpty() then
				room:returnToDrawPile(result.top, false)
				local msg = sgs.LogMessage()
				msg.type, msg.from, msg.card_str = "$GuanxingTop", source, table.concat(sgs.QList2Table(result.top), "+")
				room:doNotify(source, sgs.CommandType.S_COMMAND_LOG_SKILL, msg:toVariant())
			end
		else
			room:askForGuanxing(source, cards, sgs.Room_GuanxingUpOnly)
		end
	end
}
Xinzhan = sgs.CreateZeroCardViewAsSkill{
	name = "Xinzhan",
	view_as = function(self)
		local card = XinzhanCard:clone()
		card:setShowSkill(self:objectName())
		card:setSkillName(self:objectName())
		return card
	end, 
	enabled_at_play = function(self, player)
		return not player:hasUsed("#XinzhanCard") and (player:getHandcardNum() > player:getMaxHp())
	end
}
MaSu_YJ:addSkill(Xinzhan)

--[[
	技能名：挥泪
	技能：Huilei
	描述：锁定技，当你死亡时，你令杀死你的角色弃置其所有牌。
	状态：验证通过
]]--
Huilei = sgs.CreateTriggerSkill{
	name = "Huilei",
	can_preshow = false,
	events = {sgs.Death},
	frequency = sgs.Skill_Compulsory,
	can_trigger = function(self, event, room, player, data)
		if not player or not player:hasSkill(self:objectName()) then return "" end
		local death = data:toDeath()
		if (death.who:objectName() == player:objectName()) and death.damage and death.damage.from and death.damage.from:isAlive() then
			return self:objectName() .. "->" .. death.damage.from:objectName()
		end
		return ""
	end,
	on_cost = function(self, event, room, target, data, player)
		local death = data:toDeath()
		if death.damage and death.damage.from and matchPlayerName(death.damage.from, "zhugeliang") then
			room:broadcastSkillInvoke(self:objectName(), 1, player)
		else
			room:broadcastSkillInvoke(self:objectName(), 2, player)
		end
		return true
	end,
	on_effect = function(self, event, room, target, data, player)
		local msg = sgs.LogMessage()
		msg.type = "#HuileiThrow"
		msg.from = player
		msg.to:append(target)
		msg.arg = self:objectName()
		room:sendLog(msg)
		room:notifySkillInvoked(player, self:objectName())
		target:throwAllHandCardsAndEquips()
	end
}
MaSu_YJ:addSkill(Huilei)

----------------------------------------------------------------------------------------------------

--[[ YJ 007 吴国太
	武将：WuGuoTai
	武将名：吴国太
	体力上限：3
	武将技能：
		甘露：出牌阶段限一次，你可以令装备区的牌数之差不大于你已损失体力值的两名角色交换他们装备区的牌。
		补益：当一名角色于其回合外进入濒死状态时，你可以展示其一张手牌，若此牌不为基本牌，该角色弃置此牌，然后回复1点体力。
	状态：验证通过
]]--
WuGuoTai = sgs.General(extensionYJCM, "WuGuoTai", "wu", 3, false)
WuGuoTai:addCompanion("sunjian")

--[[
	技能名：甘露
	技能：Ganlu
	描述：出牌阶段限一次，你可以令装备区的牌数之差不大于你已损失体力值的两名角色交换他们装备区的牌。
	状态：验证通过
]]--
swapEquip = function(first, second)
	local room = first:getRoom()
	local equips1, equips2 = sgs.IntList(), sgs.IntList()
	for _, equip in sgs.qlist(first:getEquips()) do
		equips1:append(equip:getId())
	end
	for _, equip in sgs.qlist(second:getEquips()) do
		equips2:append(equip:getId())
	end
	local exchangeMove1 = sgs.CardsMoveList()
	local move1 = sgs.CardsMoveStruct(equips1, nil, sgs.Player_PlaceTable, 
			sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_SWAP, first:objectName(), second:objectName(), "Ganlu", ""))
	local move2 = sgs.CardsMoveStruct(equips2, nil, sgs.Player_PlaceTable,
			sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_SWAP, first:objectName(), second:objectName(), "Ganlu", ""))
	exchangeMove1:append(move1)
	exchangeMove1:append(move2)
	room:moveCardsAtomic(exchangeMove1, false)
	local exchangeMove2 = sgs.CardsMoveList()
	local move3 = sgs.CardsMoveStruct(equips1, second, sgs.Player_PlaceEquip, 
			sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_SWAP, first:objectName(), second:objectName(), "Ganlu", ""))
	local move4 = sgs.CardsMoveStruct(equips2, first, sgs.Player_PlaceEquip,
			sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_SWAP, first:objectName(), second:objectName(), "Ganlu", ""))
	exchangeMove2:append(move3)
	exchangeMove2:append(move4)
	room:moveCardsAtomic(exchangeMove2, false)
end
GanluCard = sgs.CreateSkillCard{
	name = "GanluCard",
	skill_name = "Ganlu",
	filter = function(self, targets, to_select)
		if #targets == 0 then
			return true
		elseif #targets == 1 then
			local n1 = targets[1]:getEquips():length()
			local n2 = to_select:getEquips():length()
			return math.abs(n1 - n2) <= sgs.Self:getLostHp()
		else
			return false
		end
	end ,
	feasible = function(self, targets)
		return #targets == 2
	end,
	on_use = function(self, room, source, targets)
		swapEquip(targets[1], targets[2])
	end
}
Ganlu = sgs.CreateZeroCardViewAsSkill{
	name = "Ganlu",
	view_as = function(self)
		local card = GanluCard:clone()
		card:setShowSkill(self:objectName())
		card:setSkillName(self:objectName())
		return card
	end, 
	enabled_at_play = function(self, player)
		return not player:hasUsed("#GanluCard")
	end
}
WuGuoTai:addSkill(Ganlu)

--[[
	技能名：补益
	技能：Buyi
	描述：当一名角色于其回合外进入濒死状态时，你可以展示其一张手牌，若此牌不为基本牌，该角色弃置此牌，然后回复1点体力。
	状态：复制手册
]]--
Buyi = sgs.CreateTriggerSkill{
	name = "Buyi",
	can_preshow = true,
	frequency = sgs.Skill_NotFrequent,
	events = sgs.Dying,
	can_trigger = function(self, event, room, player, data)
		if player and player:isAlive() and player:hasSkill(self:objectName()) then
			local dying = data:toDying()
			if dying.who:getPhase() ~= sgs.Player_NotActive then return "" end  --技能修改
			if dying.who:isAlive() and dying.who:getHp() < 1 and not dying.who:isKongcheng() then 
				return self:objectName() 
			end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		if player:askForSkillInvoke(self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), player)
			return true 
		end
		return false 
	end,
	on_effect = function(self, event, room, player, data)
		local dying, card = data:toDying()
		if player:objectName() == dying.who:objectName() then
			card = room:askForCardShow(dying.who, player, self:objectName())
		else
			local id = room:askForCardChosen(player, dying.who, "h", self:objectName())
			card = sgs.Sanguosha:getCard(id)
		end
		room:showCard(dying.who, card:getEffectiveId())
		if card:getTypeId() ~= sgs.Card_TypeBasic then
			if dying.who:canDiscard(dying.who, card:getEffectiveId()) then
				local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_THROW, dying.who:objectName(), self:objectName(), nil)
				room:throwCard(card, reason, dying.who)
				local recover = sgs.RecoverStruct()
				recover.who = dying.who
				room:recover(dying.who, recover)
			else
				local msg = sgs.LogMessage()
				msg.type, msg.from, msg.card_str = "$BuyiCannotDiscard", dying.who, card:getEffectiveId()
				room:sendLog(msg)
			end
		end
		return false 
	end,
}
WuGuoTai:addSkill(Buyi)

----------------------------------------------------------------------------------------------------

--[[ YJ 008 徐盛
	武将：XuSheng_YJ
	武将名：徐盛-一将
	体力上限：4
	武将技能：
		破军：当你使用【杀】对目标角色造成伤害后，你可以令其摸X张牌（X为其体力值且至多为5），然后其叠置。
	状态：验证通过
]]--
XuSheng_YJ = sgs.General(extensionYJCM, "XuSheng_YJ", "wu", 4, true)
XuSheng_YJ:addCompanion("dingfeng")

--[[
	技能名：破军
	技能：Pojun
	描述：当你使用【杀】对目标角色造成伤害后，你可以令其摸X张牌（X为其体力值且至多为5），然后其叠置。
	状态：验证通过
]]--
Pojun = sgs.CreateTriggerSkill{
	name = "Pojun",
	can_preshow = true,
	frequency = sgs.Skill_NotFrequent,
	events = {sgs.Damage},
	can_trigger = function(self, event, room, player, data)
		if not (player and player:isAlive() and player:hasSkill(self:objectName())) then return "" end
		local damage = data:toDamage()
		if damage.card and damage.card:isKindOf("Slash") and (not damage.chain) and (not damage.transfer) and damage.to:isAlive() and (not damage.to:hasFlag("Global_DebutFlag")) then
			return self:objectName() .. "->" .. damage.to:objectName()
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		local damage = data:toDamage()
		local x = math.min(5, damage.to:getHp())
		if ask_who:askForSkillInvoke(self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), (x >= 3 or not damage.to:faceUp()) and 2 or 1, ask_who)
			return true 
		end
		return false 
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		local damage = data:toDamage()
		local x = math.min(5, damage.to:getHp())
		damage.to:drawCards(x)
		damage.to:turnOver()
	end,
}
XuSheng_YJ:addSkill(Pojun)

----------------------------------------------------------------------------------------------------

--[[ YJ 009 徐庶
	武将：XuShu_YJ
	武将名：徐庶-一将
	体力上限：3
	武将技能：
		无言：锁定技，当你因锦囊牌造成伤害时，你防止此伤害；当你受到锦囊牌造成的伤害时，你防止此伤害。
		举荐：结束阶段开始时，你可以弃置一张非基本牌并选择一名其他角色，令其选择一项：1. 摸两张牌；2. 回复1点体力；3. 复原武将牌。
	状态：验证通过
]]--
XuShu_YJ = sgs.General(extensionYJCM, "XuShu_YJ", "shu", 3, true)
XuShu_YJ:addCompanion("wolong")
XuShu_YJ:addCompanion("pangtong")

--[[
	技能名：无言
	技能：Wuyan
	描述：锁定技，当你因锦囊牌造成伤害时，你防止此伤害；当你受到锦囊牌造成的伤害时，你防止此伤害。
	状态：验证通过
]]--
Wuyan = sgs.CreateTriggerSkill{
	name = "Wuyan",
	can_preshow = true,
	frequency = sgs.Skill_Compulsory,
	events = {sgs.DamageCaused, sgs.DamageInflicted},
	can_trigger = function(self, event, room, player, data)
		if not (player and player:isAlive() and player:hasSkill(self:objectName())) then return "" end
		local damage = data:toDamage()
		return (damage.card and (damage.card:getTypeId() == sgs.Card_TypeTrick)) and self:objectName() or ""
	end,
	on_cost = function(self, event, room, player, data)
		if player:hasShownSkill(self:objectName()) or player:askForSkillInvoke(self:objectName()) then
			room:broadcastSkillInvoke(self:objectName(), (event == sgs.DamageInflicted) and 2 or 1, player)
			return true
		end
		return false
	end,
	on_effect = function(self, event, room, player, data)
		local damage = data:toDamage()
		local msg = sgs.LogMessage()
		msg.from, msg.arg2 = player, self:objectName()
		if event == sgs.DamageInflicted then
			msg.type = "#WuyanGood"
		elseif event == sgs.DamageCaused then
			msg.type = "#WuyanBad"
		end
		room:sendLog(msg)
		room:notifySkillInvoked(player, self:objectName())
		return true
	end,
}
XuShu_YJ:addSkill(Wuyan)

--[[
	技能名：举荐
	技能：Jujian
	描述：结束阶段开始时，你可以弃置一张非基本牌并选择一名其他角色，令其选择一项：1. 摸两张牌；2. 回复1点体力；3. 复原武将牌。
	状态：验证通过
]]--
JujianCard = sgs.CreateSkillCard{
	name = "JujianCard",
	skill_name = "Jujian",
    will_throw = true,
	mute = true,
	filter = function(self, selected, to_select)
		return (#selected == 0) and (to_select:objectName() ~= sgs.Self:objectName())
	end,
	on_effect = function(self, effect)
		local room = effect.to:getRoom()
		if matchPlayerName(effect.to, "zhugeliang") then
			room:broadcastSkillInvoke("Jujian", 2)
		else
			room:broadcastSkillInvoke("Jujian", 1)
		end
		local choiceList = {"draw"}
		if effect.to:isWounded() then
			table.insert(choiceList, "recover")
		end
		if (not effect.to:faceUp()) or effect.to:isChained() then
			table.insert(choiceList, "reset")
		end
		local choice = room:askForChoice(effect.to, "Jujian", table.concat(choiceList, "+"))
		if choice == "draw" then
			effect.to:drawCards(2)
		elseif choice == "recover" then
			local recover = sgs.RecoverStruct()
			recover.who = effect.from
			room:recover(effect.to, recover)
		elseif choice == "reset" then
			if effect.to:isChained() then
				room:setPlayerProperty(effect.to, "chained", sgs.QVariant(false))
			end
			if not effect.to:faceUp() then
				effect.to:turnOver()
			end
		end
	end,
}
JujianVS = sgs.CreateOneCardViewAsSkill{
	name = "Jujian",
	filter_pattern = "^BasicCard!",
	response_pattern = "@@Jujian",
	view_as = function(self, card)
        local jujian_card = JujianCard:clone()
		jujian_card:addSubcard(card)
        jujian_card:setShowSkill(self:objectName())
        return jujian_card
	end,
}
Jujian = sgs.CreatePhaseChangeSkill{
	name = "Jujian",  
	can_preshow = true,
	frequency = sgs.Skill_NotFrequent,
	view_as_skill = JujianVS,
	can_trigger = function(self, event, room, player, data)
		if not player or player:isDead() or not player:hasSkill(self:objectName()) then return false end
		if (player:getPhase() == sgs.Player_Finish) and player:canDiscard(player, "he") then return self:objectName() end
	end,
	on_cost = function(self, event, room, player, data)
		return room:askForUseCard(player, "@@Jujian", "@Jujian-Card", -1, sgs.Card_MethodDiscard)
	end,
	on_phasechange = function(self, player)
		return false
	end,
}
XuShu_YJ:addSkill(Jujian)

----------------------------------------------------------------------------------------------------

--[[ YJ 010 于禁
	武将：YuJin
	武将名：于禁
	体力上限：4
	武将技能：
		毅重：锁定技，若你的装备区没有防具牌，黑色【杀】对你无效。
	状态：验证通过
]]--
YuJin = sgs.General(extensionYJCM, "YuJin", "wei", 4, true)

--[[
	技能名：毅重
	技能：Yizhong
	描述：锁定技，若你的装备区没有防具牌，黑色【杀】对你无效。
	状态：验证通过
]]--
Yizhong = sgs.CreateTriggerSkill{
	name = "Yizhong",
	can_preshow = true,
	frequency = sgs.Skill_Compulsory,
	events = {sgs.SlashEffected},
	can_trigger = function(self, event, room, player, data)
		if not (player and player:isAlive() and player:hasSkill(self:objectName())) then return "" end
		local effect = data:toSlashEffect()
		return (effect.slash:isBlack() and (player:getArmor() == nil)) and self:objectName() or ""
	end,
	on_cost = function(self, event, room, player, data)
		if player:hasShownSkill(self:objectName()) or player:askForSkillInvoke(self:objectName()) then
			room:broadcastSkillInvoke(self:objectName(), player)
			return true
		end
		return false
	end,
	on_effect = function(self, event, room, player, data)
		local effect = data:toSlashEffect()
		room:notifySkillInvoked(player, self:objectName())
		local msg = sgs.LogMessage()
		msg.from, msg.arg, msg.arg2 = player, self:objectName(), effect.slash:objectName()
		msg.type = "#SkillNullify"
		room:sendLog(msg)
		return true
	end,
}
YuJin:addSkill(Yizhong)

----------------------------------------------------------------------------------------------------

--[[ YJ 011 张春华
	武将：ZhangChunHua
	武将名：张春华
	体力上限：3
	武将技能：
		绝情：锁定技，当你造成的伤害结算开始前，你将此伤害视为失去体力。
		伤逝：当你的手牌数、体力值或体力上限变化后，若你的手牌数小于X，你可以将手牌补至X张（X为你已损失的体力值且至多为2）。
	状态：验证通过
]]--
ZhangChunHua = sgs.General(extensionYJCM, "ZhangChunHua", "wei", 3, false)
ZhangChunHua:addCompanion("simayi")
ZhangChunHua:addCompanion("SiMaYi_LB")

--[[
	技能名：绝情
	技能：Jueqing
	描述：锁定技，当你造成的伤害结算开始前，你将此伤害视为失去体力。
	状态：验证通过
]]--
Jueqing = sgs.CreateTriggerSkill{
	name = "Jueqing",
	can_preshow = true,
	frequency = sgs.Skill_Compulsory,
	events = {sgs.Predamage},
	can_trigger = function(self, event, room, player, data)
		return (player and player:isAlive() and player:hasSkill(self:objectName())) and self:objectName() or ""
	end,
	on_cost = function(self, event, room, player, data)
		if player:hasShownSkill(self:objectName()) or player:askForSkillInvoke(self:objectName()) then
			room:broadcastSkillInvoke(self:objectName(), player)
			return true
		end
		return false
	end,
	on_effect = function(self, event, room, player, data)
		local damage = data:toDamage()
		room:loseHp(damage.to, damage.damage)
		return true
	end,
}
ZhangChunHua:addSkill(Jueqing)

--[[
	技能名：伤逝
	技能：Shangshi
	描述：当你的手牌数、体力值或体力上限变化后，若你的手牌数小于X，你可以将手牌补至X张（X为你已损失的体力值且至多为2）。
	状态：验证通过
]]--
Shangshi = sgs.CreateTriggerSkill{
	name = "Shangshi",
	can_preshow = true,
	frequency = sgs.Skill_Frequent,
	events = {sgs.CardsMoveOneTime, sgs.MaxHpChanged, sgs.HpChanged},
	can_trigger = function(self, event, room, player, data)
		if not (player and player:isAlive() and player:hasSkill(self:objectName())) then return "" end
		local losthp = math.min(player:getLostHp(), 2)
		if (event == sgs.CardsMoveOneTime) then
			local move = data:toMoveOneTime()
			local can_invoke = false
			if move.from and (move.from:objectName() == player:objectName()) and move.from_places:contains(sgs.Player_PlaceHand) then
				can_invoke = true
			end
			if move.to and (move.to:objectName() == player:objectName()) and (move.to_place == sgs.Player_PlaceHand) then
				can_invoke = true
			end
			if not can_invoke then
				return ""
			end
		end
		if player:getHandcardNum() < losthp then
			return self:objectName()
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		if player:askForSkillInvoke(self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), player)
			return true 
		end
		return false 
	end,
	on_effect = function(self, event, room, player, data)
		local losthp = math.min(player:getLostHp(), 2)
		if player:getHandcardNum() < losthp then
			--player:drawCards(losthp - player:getHandcardNum(), self:objectName())
			local draw_num = losthp - player:getHandcardNum()  --重写room::drawCards，为了和清俭配合（源码既没有REASON_DRAW也没有m_skillName）
			local card_ids = room:getNCards(draw_num, false)
			local move = sgs.CardsMoveStruct(card_ids, player, sgs.Player_PlaceHand, sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_DRAW, player:objectName(), self:objectName(), ""))
			room:moveCardsAtomic(move, false)
		end
	end,
}
ZhangChunHua:addSkill(Shangshi)

----------------------------------------------------------------------------------------------------

--[[ YJ 012 钟会
	武将：ZhongHui
	武将名：钟会
	体力上限：(3)/4
	武将技能：
		权计：当你受到1点伤害后，你可以摸一张牌，然后将一张手牌置于武将牌上，称为“权”；你的手牌上限+X（X为“权”数）。
		排异：主将技，此武将牌上单独的阴阳鱼个数-1；出牌阶段限一次，你可以移去一张“权”并选择一名角色，令其摸两张牌，然后若其手牌多于你，你对其造成1点伤害。
		桀骜：副将技，一名角色的准备阶段开始时，你可将一张“权”置入其一个区域，然后若此区域不为手牌区，你摸一张牌。
	状态：验证通过
]]--
ZhongHui = sgs.General(extensionYJCM, "ZhongHui", "wei", 4, true)

--[[
	技能名：权计
	技能：Quanji
	描述：当你受到1点伤害后，你可以摸一张牌，然后将一张手牌置于武将牌上，称为“权”；你的手牌上限+X（X为“权”数）。
	状态：验证通过
]]--
Quanji = sgs.CreateMasochismSkill{
	name = "Quanji",
	frequency = sgs.Skill_Frequent,
	can_trigger = function(self, event, room, player, data)	
		if not player or player:isDead() or not player:hasSkill(self:objectName()) then return "" end
		local damage = data:toDamage()
		local trigger_list = {}
		for i = 1, damage.damage, 1 do
			table.insert(trigger_list, self:objectName())
		end
		return table.concat(trigger_list,",")
	end,
	on_cost = function(self, event, room, player, data)
		if player:askForSkillInvoke(self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName())
			return true 
		end
		return false 
	end,
	on_damaged = function(self, player, damage)
		local room = player:getRoom()
		room:drawCards(player, 1, self:objectName())
		if player:isAlive() and not player:isKongcheng() then
			local card_id
			if player:getHandcardNum() == 1 then
				card_id = player:handCards():first()
				room:getThread():delay()
			else
				local exc_card = room:askForExchange(player, self:objectName(), 1, 1, "QuanjiPush", "", ".|.|.|hand")
				if exc_card then
					card_id = exc_card:getEffectiveId()
				else
					card_id = player:getHandcards():at(math.random(0, player:getHandcards():length() - 1))
				end
			end
			player:addToPile("power", card_id)
		end
	end,
}
QuanjiKeep = sgs.CreateMaxCardsSkill{
	name = "#Quanji-keep",
	extra_func = function(self, target)
		if target:hasShownSkill(self:objectName()) then
			return target:getPile("power"):length()
		else
			return 0
		end
	end
}
QuanjiClear = sgs.CreateTriggerSkill{
	name = "#Quanji-clear",
	frequency = sgs.Skill_Compulsory,
	events = {sgs.EventLoseSkill},
	on_record = function(self, event, room, player, data)
		if data:toString() == "Quanji" then
			player:clearOnePrivatePile("power")
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
ZhongHui:addSkill(Quanji)
ZhongHui:addSkill(QuanjiKeep)
ZhongHui:addSkill(QuanjiClear)
sgs.insertRelatedSkills(extensionYJCM, "Quanji", "#Quanji-keep", "#Quanji-clear")

--[[
	技能名：排异
	技能：Paiyi
	描述：主将技，此武将牌上单独的阴阳鱼个数-1；出牌阶段限一次，你可以移去一张“权”并选择一名角色，令其摸两张牌，然后若其手牌多于你，你对其造成1点伤害。
	状态：验证通过
]]--
PaiyiCard = sgs.CreateSkillCard{
	name = "PaiyiCard",
	skill_name = "Paiyi",
    will_throw = false,
	handling_method = sgs.Card_MethodNone,
	mute = true,
	filter = function(self, selected, to_select)
		return #selected == 0
	end,
	extra_cost = function(self, room, use)
		local powers = use.from:getPile("power")
		if powers:isEmpty() then return false end
		local card_id = self:getSubcards():first()
		local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_REMOVE_FROM_PILE, "", use.to:first():objectName(), "Paiyi", "")
		room:throwCard(sgs.Sanguosha:getCard(card_id), reason, nil)
	end,
	on_effect = function(self, effect)
		local room = effect.to:getRoom()
		room:broadcastSkillInvoke("Paiyi", (effect.from:objectName() == effect.to:objectName()) and 1 or 2)
		room:drawCards(effect.to, 2, self:objectName())
		if effect.to:isAlive() and effect.to:getHandcardNum() > effect.from:getHandcardNum() then
			room:damage(sgs.DamageStruct("Paiyi", effect.from, effect.to))
		end
	end,
}
Paiyi = sgs.CreateOneCardViewAsSkill{
	name = "Paiyi",
	relate_to_place = "head",
	expand_pile = "power",
	filter_pattern = ".|.|.|power",
	view_as = function(self, card)
        local paiyi_card = PaiyiCard:clone()
		paiyi_card:addSubcard(card)
        paiyi_card:setShowSkill(self:objectName())
        return paiyi_card
	end, 
	enabled_at_play = function(self, player)
		return not player:hasUsed("#PaiyiCard") and not player:getPile("power"):isEmpty()
	end
}
ZhongHui:addSkill(Paiyi)
ZhongHui:setHeadMaxHpAdjustedValue(-1)

--[[
	技能名：桀骜
	技能：Jieao
	描述：副将技，一名角色的准备阶段开始时，你可将一张“权”置入其一个区域，然后若此区域不为手牌区，你摸一张牌。
	状态：验证通过
]]--
Jieao = sgs.CreateTriggerSkill{
	name = "Jieao",  
	relate_to_place = "deputy",
	can_preshow = true,
	frequency = sgs.Skill_NotFrequent,
	events = {sgs.EventPhaseStart},
	can_trigger = function(self, event, room, player, data)
		if not player or player:isDead() then return "" end
		if player:getPhase() == sgs.Player_Start then
			local skill_list, player_list = {}, {}
			for _, zhonghui in sgs.qlist(room:findPlayersBySkillName(self:objectName())) do
				if not zhonghui:getPile("power"):isEmpty() then
					table.insert(skill_list, self:objectName())
					table.insert(player_list, zhonghui:objectName())
				end
			end
			return table.concat(skill_list, "|"), table.concat(player_list, "|")
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		local exc_card = room:askForExchange(ask_who, self:objectName(), 1, 0, "@Jieao:" .. player:objectName(), "power")
		if exc_card then
			ask_who:setTag("JieaoCardId", sgs.QVariant(exc_card:getEffectiveId()))
			local msg = sgs.LogMessage()
			msg.type, msg.from, msg.arg = "#InvokeSkill", ask_who, self:objectName()
			room:sendLog(msg)
			room:broadcastSkillInvoke(self:objectName(), ask_who)
			return true
		end
		ask_who:removeTag("JieaoCardId")
		return false 
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		local id = ask_who:getTag("JieaoCardId"):toInt()
		ask_who:removeTag("JieaoCardId")
		if id then
			local card = sgs.Sanguosha:getCard(id)
			local choices = {"hand"}
			if card:isKindOf("EquipCard") then
				local equip = card:getRealCard():toEquipCard()
				local equip_index = equip:location()
				if player:getEquip(equip_index) == nil then
					table.insert(choices, "equip")
				end
			elseif card:isKindOf("DelayedTrick") then
				if not ask_who:isProhibited(player, card) and not player:containsTrick(card:objectName()) then
					table.insert(choices, "judge")
				end
			end
			local choice = room:askForChoice(ask_who, "Jieao", table.concat(choices, "+"))
			local msg = sgs.LogMessage()
			msg.type = "$JieaoPut"
			msg.from = ask_who
			msg.to:append(player)
			msg.card_str = card:toString()
			msg.arg = "Jieao:" .. choice
			room:sendLog(msg)
			local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_PUT, ask_who:objectName(), self:objectName(), nil)
			if choice == "hand" then
				room:moveCardTo(card, ask_who, player, sgs.Player_PlaceHand, reason)
			elseif choice == "equip" then
				room:moveCardTo(card, ask_who, player, sgs.Player_PlaceEquip, reason)
			elseif choice == "judge" then
				room:moveCardTo(card, ask_who, player, sgs.Player_PlaceDelayedTrick, reason)
			end
			if choice ~= "hand" then
				ask_who:drawCards(1, self:objectName())
			end
		end
		return false
	end,
}
ZhongHui:addSkill(Jieao)

--------------------------------------------一将成名2012--------------------------------------------

extensionYJCM2012 = sgs.Package("YJCM2012", sgs.Package_GeneralPack)

--[[ YJ 101 步练师
	武将：BuLianShi
	武将名：步练师
	体力上限：3
	武将技能：
		安恤：出牌阶段限一次，你可以选择两名手牌数不同的其他角色，令其中手牌少的角色先获得手牌多的角色的一张手牌再展示之，然后若以此法展示的牌不为黑桃，你摸一张牌。
		追忆：当你死亡时，你可以令一名其他角色（杀死你的角色除外）摸三张牌，然后其回复1点体力。
	状态：复制手册
]]--
BuLianShi = sgs.General(extensionYJCM2012, "BuLianShi", "wu", 3, false)
BuLianShi:addCompanion("sunquan")

--[[
	技能名：安恤
	技能：Anxu
	描述：出牌阶段限一次，你可以选择两名手牌数不同的其他角色，令其中手牌少的角色先获得手牌多的角色的一张手牌再展示之，然后若以此法展示的牌不为黑桃，你摸一张牌。
	状态：复制手册
]]--
AnxuCard = sgs.CreateSkillCard{
	name = "AnxuCard",
	skill_name = "Anxu",
	target_fixed = false,
	will_throw = false,
	handling_method = sgs.Card_MethodNone,
	mute = true,
	filter = function(self, targets, to_select, player)
		if to_select:objectName() == player:objectName() then
			return false
		elseif #targets == 0 then
			return true
		elseif #targets == 1 then 
			return to_select:objectName() ~= targets[1]:objectName() and to_select:getHandcardNum() ~= targets[1]:getHandcardNum()
		end
		return false
	end,
	feasible = function(self, targets)
		return #targets == 2
	end,
	on_use = function(self, room, source, targets)
		if targets[1]:getHandcardNum() == targets[2]:getHandcardNum() then return end
		local from = targets[1]:getHandcardNum() < targets[2]:getHandcardNum() and targets[1] or targets[2]
		local to = from:objectName() == targets[1]:objectName() and targets[2] or targets[1]
		
		local skin_id = source:property((source:inHeadSkills("Anxu") and "head" or "deputy") .. "_skin_id"):toInt()
		if skin_id == 1 then
			room:broadcastSkillInvoke("Anxu", matchPlayerName(from, "sunquan") and 2 or 1, source)
		else
			room:broadcastSkillInvoke("Anxu", source)
		end
		if not to:isKongcheng() then
			local id = room:askForCardChosen(from, to, "h", self:getSkillName(), false)
			local card = sgs.Sanguosha:getCard(id)
			room:obtainCard(from, card, sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_EXTRACTION, source:objectName(), "Anxu", ""))
			if from:isDead() then return end
			room:showCard(from, id)
			if card:getSuit() ~= sgs.Card_Spade and source:isAlive() then
				room:drawCards(source, 1, "Anxu")
			end
		end
	end,
}
Anxu = sgs.CreateZeroCardViewAsSkill{   
	name = "Anxu",
	view_as = function(self)
		local skillcard = AnxuCard:clone()
		skillcard:setSkillName(self:objectName())
		skillcard:setShowSkill(self:objectName())
		return skillcard
	end,
	enabled_at_play = function(self, player)
		return not player:hasUsed("#AnxuCard")
	end,
}
BuLianShi:addSkill(Anxu)

--[[
	技能名：追忆
	技能：Zhuiyi_BuLianShi
	描述：当你死亡时，你可以令一名其他角色（杀死你的角色除外）摸三张牌，然后其回复1点体力。
	状态：复制原项目
]]--
function sgs.CreateZhuiyiSkill(name)
	local zhuiyi_skill = {
		name = "Zhuiyi_" .. name,
		events = {sgs.Death},
		can_preshow = false,
		can_trigger = function(self, event, room, player, data)
			if not (player and player:hasSkill(self)) then return "" end
			local death = data:toDeath()
			if death.who:objectName() == player:objectName() then
				for _, p in sgs.qlist(room:getAlivePlayers()) do
					if not (death.damage and death.damage.from and (p:objectName() == death.damage.from:objectName())) then
						return self:objectName()
					end
				end
			end
			return ""
		end,
		on_cost = function(self, event, room, player, data)
			local can_invoke = room:getAlivePlayers()
			local death = data:toDeath()
			if death.damage and death.damage.from then
				can_invoke:removeOne(death.damage.from)
			end
			if not can_invoke:isEmpty() then
				local target
				if death.damage and death.damage.from then
					target = room:askForPlayerChosen(player, can_invoke, self:objectName(), "Zhuiyi-invokex:" .. death.damage.from:objectName(), true, true)
				else
					target = room:askForPlayerChosen(player, can_invoke, self:objectName(), "Zhuiyi-invoke", true, true)
				end
				if target then
					local skin_id = player:property((player:inHeadSkills(self) and "head" or "deputy") .. "_skin_id"):toInt()
					if skin_id == 1 then
						room:broadcastSkillInvoke(self:objectName(), matchPlayerName(from, "sunquan") and 2 or 1, player)
					else
						room:broadcastSkillInvoke(self:objectName(), player)
					end
					local _data = sgs.QVariant()
					_data:setValue(target)
					player:setTag("Zhuiyi" .. name .. "_invoke", _data)
					return true
				end
			end
			return false
		end,
		on_effect = function(self, event, room, player, data)
			local target = player:getTag("Zhuiyi" .. name .. "_invoke"):toPlayer()
			player:removeTag("Zhuiyi" .. name .. "_invoke")
			if target then
				target:drawCards(3)
				if target:isAlive() and target:isWounded() then
					local recover = sgs.RecoverStruct()
					recover.who = player
					room:recover(target, recover, true)
				end
			end
			return false
		end
	}
	return sgs.CreateTriggerSkill(zhuiyi_skill)
end
Zhuiyi_BuLianShi = sgs.CreateZhuiyiSkill("BuLianShi")
BuLianShi:addSkill(Zhuiyi_BuLianShi)

----------------------------------------------------------------------------------------------------

--[[ YJ 102 曹彰
	武将：CaoZhang
	武将名：曹彰
	体力上限：3
	武将技能：
		将驰：摸牌阶段，你可以选择一项：1. 少摸一张牌，然后本回合你使用【杀】无距离限制且可以多使用一张【杀】；2. 多摸一张牌，然后你于此回合内不能使用或打出【杀】。
	状态：验证通过
]]--
CaoZhang = sgs.General(extensionYJCM2012, "CaoZhang", "wei", 4, true)

--[[
	技能名：将驰
	技能：Jiangchi
	描述：摸牌阶段，你可以选择一项：1. 少摸一张牌，然后本回合你使用【杀】无距离限制且可以多使用一张【杀】；2. 多摸一张牌，然后你于此回合内不能使用或打出【杀】。
	状态：验证通过
]]--
Jiangchi = sgs.CreateDrawCardsSkill{
	name = "Jiangchi",
	can_preshow = true,
	frequency = sgs.Skill_Frequent,
	can_trigger = function(self, event, room, player, data)
		if not player or player:isDead() or not player:hasSkill(self:objectName()) then return "" end
		return self:objectName()
	end,
	on_cost = function(self, event, room, player, data)
		if room:askForSkillInvoke(player, self:objectName(), data) then
			return true
		end
		return false
	end,
	draw_num_func = function(self, player, n)
		local room = player:getRoom()
		player:setFlags("JiangchiChoiceMade")
		local choices = {"jiang"}
		if n >= 1 then table.insert(choices, "chi") end
		local choice = room:askForChoice(player, self:objectName(), table.concat(choices, "+"))
		local msg = sgs.LogMessage()
		msg.from, msg.arg = player, self:objectName()
		if choice == "jiang" then
			msg.type = "#Jiangchi1"
			room:sendLog(msg)
			room:broadcastSkillInvoke(self:objectName(), 1, player)
			room:setPlayerMark(player, "JiangchiChoice", 1)
			return n + 1
		else
			msg.type = "#Jiangchi2"
			room:sendLog(msg)
			room:broadcastSkillInvoke(self:objectName(), 2, player)
			room:setPlayerMark(player, "JiangchiChoice", 2)
			return n - 1
		end
		return n
	end,
	on_turn_broken = function(self, function_name, event, room, player, data, ask_who)
		room:setPlayerMark(player, "JiangchiChoice", 0)
	end
}
JiangchiEffect = sgs.CreateTriggerSkill{
	name = "#Jiangchi-effect",
	events = {sgs.AfterDrawNCards},
	frequency = sgs.Skill_Compulsory,
	can_trigger = function(self, event, room, player, data)
		if not player or player:isDead() then return end
		if player:hasFlag("JiangchiChoiceMade") then
			return self:objectName()
		end
	end,
	on_cost = function(self, event, room, player, data)
		return true
	end,
	on_effect = function(self, event, room, player, data)
		local choice = player:getMark("JiangchiChoice")
		room:setPlayerMark(player, "JiangchiChoice", 0)
		if choice == 1 then
			room:setPlayerCardLimitation(player, "use,response", "Slash", true)
		elseif choice == 2 then
			room:addPlayerMark(player, "JiangchiInvoke")
		end
		return false
	end,
	on_turn_broken = function(self, function_name, event, room, player, data, ask_who)
		room:setPlayerMark(player, "JiangchiChoice", 0)
	end
}
JiangchiClear = sgs.CreateTriggerSkill{
	name = "#Jiangchi-clear",
	events = {sgs.AfterDrawNCards},
	priority = -1,
	global = true,
	on_record = function(self, event, room, player, data)
		player:setFlags("-JiangchiChoiceMade")
		room:setPlayerMark(player, "JiangchiChoice", 0)
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
JiangchiClear2 = sgs.CreateTriggerSkill{
	name = "#Jiangchi-clear2",
	events = {sgs.EventPhaseStart},
	priority = 8,
	global = true,
	on_record = function(self, event, room, player, data)
		if player:getPhase() ~= sgs.Player_NotActive then return end
		room:setPlayerMark(player, "JiangchiInvoke", 0)
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
JiangchiTargetMod = sgs.CreateTargetModSkill{
	name = "#Jiangchi-target",
	residue_func = function(self, from)
		return from:getMark("JiangchiInvoke")
	end,
	distance_limit_func = function(self, from)
		if from:getMark("JiangchiInvoke") > 0 then
			return 1000
		else
			return 0
		end
	end
}
CaoZhang:addSkill(Jiangchi)
CaoZhang:addSkill(JiangchiEffect)
CaoZhang:addSkill(JiangchiClear)
CaoZhang:addSkill(JiangchiClear2)
CaoZhang:addSkill(JiangchiTargetMod)
sgs.insertRelatedSkills(extensionYJCM2012, "Jiangchi", "#Jiangchi-effect", "#Jiangchi-clear", "#Jiangchi-clear2", "#Jiangchi-target")

----------------------------------------------------------------------------------------------------

--[[ YJ 103 程普
	武将：ChengPu
	武将名：程普
	体力上限：4
	武将技能：
		疠火：你可以将一张普通【杀】当火【杀】使用，若此【杀】造成过伤害，你失去1点体力；你使用火【杀】可以多选择一名目标。
		醇醪：结束阶段开始时，若你没有“醇”，你可以将至少一张【杀】置于武将牌上，称为“醇”；当一名角色处于濒死状态时，你可以移去一张“醇”，视为该角色使用一张【酒】。
	状态：验证通过
]]--
ChengPu = sgs.General(extensionYJCM2012, "ChengPu", "wu", 4, true)

--[[
	技能名：疠火
	技能：Lihuo
	描述：你可以将一张普通【杀】当火【杀】使用，若此【杀】造成过伤害，你失去1点体力；你使用火【杀】可以多选择一名目标。
	状态：验证通过
	注：亮将代码在showTMSkillForSlash中
]]--
LihuoVS = sgs.CreateOneCardViewAsSkill{
	name = "Lihuo",
	filter_pattern = "%slash",
	response_or_use = true,
	enabled_at_play = function(self, player)
		return sgs.Slash_IsAvailable(player)
	end,
	enabled_at_response = function(self, player, pattern)
		return sgs.Sanguosha:getCurrentCardUseReason() == sgs.CardUseStruct_CARD_USE_REASON_RESPONSE_USE and pattern == "slash"
	end,
	view_as = function(self, card)
		local acard = sgs.Sanguosha:cloneCard("fire_slash", card:getSuit(), card:getNumber())
		acard:addSubcard(card)
		acard:setSkillName(self:objectName())
		acard:setShowSkill(self:objectName())
		return acard
	end,
}
Lihuo = sgs.CreateTriggerSkill{
	name = "Lihuo" ,
	events = {sgs.PreCardUsed, sgs.PreDamageDone} ,
	view_as_skill = LihuoVS,
	on_record = function(self, event, room, player, data)  --此段代码要先用疠火视为技才能执行，因此不用global
		if not (player and player:isAlive()) then return end  --防断肠
		if event == sgs.PreCardUsed then
			local use = data:toCardUse()
			if use.card:isKindOf("Slash") and use.card:getSkillName() == self:objectName() then  --记录原使用者（因为谮毁）
				local dat = sgs.QVariant()
				dat:setValue(use.from)
				room:setTag("LihuoUser" .. use.card:toString(), dat)
			end
		elseif event == sgs.PreDamageDone then
			local damage = data:toDamage()
			if damage.card and damage.card:isKindOf("Slash") and (damage.card:getSkillName() == self:objectName()) then
				local user = room:getTag("LihuoUser" .. damage.card:toString()):toPlayer()
				if not user then return end
				local invokeLihuo = user:getTag("InvokeLihuo"):toString():split("|")
				table.insert(invokeLihuo, damage.card:toString())
				table.removeAll(invokeLihuo, "")
				user:setTag("InvokeLihuo", sgs.QVariant(table.concat(invokeLihuo, "|")))
			end
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
LihuoLoseHp = sgs.CreateTriggerSkill{
	name = "#Lihuo-losehp",
	events = {sgs.CardFinished},
	frequency = sgs.Skill_Compulsory,
	can_trigger = function(self, event, room, player, data)
		if not (player and player:isAlive()) then return "" end
		if (event == sgs.CardFinished) and (not player:hasFlag("Global_ProcessBroken")) then
			local use = data:toCardUse()
			if not use.card:isKindOf("Slash") then return "" end
			local user = room:getTag("LihuoUser" .. use.card:toString()):toPlayer()
			if not user then return "" end
			
			local invokeLihuo = user:getTag("InvokeLihuo"):toString():split("|")
			if table.contains(invokeLihuo, use.card:toString()) then
				return self:objectName(), user
			end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		local skin_id = ask_who:property((ask_who:inHeadSkills("Lihuo") and "head" or "deputy") .. "_skin_id"):toInt()
		if skin_id == 1 then room:broadcastSkillInvoke("Lihuo", 2, ask_who) end
		return true
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		room:sendCompulsoryTriggerLog(ask_who, "Lihuo", false)
		room:loseHp(ask_who, 1)
	end
}
LihuoClear = sgs.CreateTriggerSkill{
	name = "#Lihuo-clear",
	events = {sgs.CardFinished},
	priority = 1,
	global = true,
	on_record = function(self, event, room, player, data)
		local use = data:toCardUse()
		local user = room:getTag("LihuoUser" .. use.card:toString()):toPlayer()
		room:removeTag("LihuoUser" .. use.card:toString())
		if not user then return end
		local invokeLihuo = user:getTag("InvokeLihuo"):toString():split("|")
		if table.contains(invokeLihuo, use.card:toString()) then
			table.removeOne(invokeLihuo, use.card:toString())
			if next(invokeLihuo) ~= nil then
				user:setTag("InvokeLihuo", sgs.QVariant(table.concat(invokeLihuo, "|")))
			else
				user:removeTag("InvokeLihuo")
			end
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
LihuoTargetMod = sgs.CreateTargetModSkill{
	name = "#Lihuo-target",
	pattern = "FireSlash",
	extra_target_func = function(self, from, card)
		--if not sgs.Sanguosha:matchExpPattern(pattern, from, card) then return 0 end
		--if from:hasFlag("LihuoExtraTargetChecker") then return 0 end
		if from:hasSkill(self:objectName()) then
			return 1
		else
			return 0
		end
	end
}
ChengPu:addSkill(Lihuo)
ChengPu:addSkill(LihuoLoseHp)
ChengPu:addSkill(LihuoClear)
ChengPu:addSkill(LihuoTargetMod)
sgs.insertRelatedSkills(extensionYJCM2012, "Lihuo", "#Lihuo-losehp", "#Lihuo-clear", "#Lihuo-target")  --todo：检查孙鲁班转移使用者

--[[
	技能名：醇醪
	技能：Chunlao
	描述：结束阶段开始时，若你没有“醇”，你可以将至少一张【杀】置于武将牌上，称为“醇”；当一名角色处于濒死状态时，你可以移去一张“醇”，视为该角色使用一张【酒】。
	状态：验证通过
]]--
ChunlaoCard = sgs.CreateSkillCard{
	name = "ChunlaoCard",
	skill_name = "Chunlao",
	mute = true,
	target_fixed = true,
	will_throw = false,
	handling_method = sgs.Card_MethodNone,
	extra_cost = function(self, room, use)
		if self:getSubcards():length() ~= 0 then
			local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_REMOVE_FROM_PILE, nil, "Chunlao", nil)
			room:throwCard(self, reason, nil)
		end
	end,
}
ChunlaoVS = sgs.CreateOneCardViewAsSkill{
	name = "Chunlao",
	expand_pile = "wine",
	filter_pattern = ".|.|.|wine",
	response_pattern = "@@Chunlao",
	view_as = function(self, originalCard)
		local wine = ChunlaoCard:clone()
		wine:addSubcard(originalCard)
		return wine
	end,
}
Chunlao = sgs.CreateTriggerSkill{
	name = "Chunlao",  
	can_preshow = true,
	events = {sgs.EventPhaseStart, sgs.AskForPeaches, sgs.EventLoseSkill},
	frequency = sgs.Skill_NotFrequent,
	view_as_skill = ChunlaoVS,
	on_record = function(self, event, room, player, data)
		if event == sgs.EventLoseSkill and data:toString() == self:objectName() then
			player:clearOnePrivatePile("wine")
		end
	end,
	can_trigger = function(self, event, room, player, data)
		if not (player and player:isAlive() and player:hasSkill(self)) then return "" end
		if event == sgs.EventPhaseStart then
			if (player:getPhase() == sgs.Player_Finish) and not player:isKongcheng() and player:getPile("wine"):isEmpty() then return self:objectName() end
		elseif event == sgs.AskForPeaches then
			local dying = data:toDying()
			if not dying or not dying.who or dying.who:getHp() > 0 then return "" end  --体力值回复至1以上则无此时机
			return (not player:getPile("wine"):isEmpty()) and self:objectName() or ""
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		local skin_id = player:property((player:inHeadSkills(self) and "head" or "deputy") .. "_skin_id"):toInt()
		if event == sgs.EventPhaseStart then
			local exc_card = room:askForExchange(player, self:objectName(), 999, 0, "@Chunlao", "", "Slash")
			if exc_card then
				local ids = {}
				for _,id in sgs.qlist(exc_card:getSubcards()) do
					table.insert(ids, id)
				end
				player:setTag("ChunlaoCards", sgs.QVariant(table.concat(ids, "+")))
				local msg = sgs.LogMessage()
				msg.type, msg.from, msg.arg = "#InvokeSkill", player, self:objectName()
				room:sendLog(msg)
				local skin_id = player:property((player:inHeadSkills(self) and "head" or "deputy") .. "_skin_id"):toInt()
				room:broadcastSkillInvoke(self:objectName(), (skin_id == 1) and 1 or 2, player)
				return true
			end
		elseif event == sgs.AskForPeaches then
			local dying = data:toDying()
			if room:askForUseCard(player, "@@Chunlao", "@Chunlao-wine:" .. dying.who:objectName(), -1, sgs.Card_MethodNone) then  --askForExchange的话cardUsePattern为REASON_USE，导致酒的效果为酒1
				if skin_id == 1 then
					room:broadcastSkillInvoke(self:objectName(), matchPlayerName(dying.who, "zhouyu") and 3 or 2, player)
				else
					room:broadcastSkillInvoke(self:objectName(), 1, player)
				end
				room:doAnimate(1, player:objectName(), dying.who:objectName())
				return true
			end
		end
		return false
	end,
	on_effect = function(self, event, room, player, data)
		if event == sgs.EventPhaseStart then
			local ids_str = player:getTag("ChunlaoCards"):toString():split("+")
			player:removeTag("ChunlaoCards")
			local ids = sgs.IntList()
			for _,id_str in ipairs(ids_str) do
				if id_str ~= "" then ids:append(tonumber(id_str)) end
			end
			player:addToPile("wine", ids)
		elseif event == sgs.AskForPeaches then
			local dying = data:toDying()
			if not dying or not dying.who or dying.who:isDead() then return end
			local analeptic = sgs.Sanguosha:cloneCard("Analeptic", sgs.Card_NoSuit, 0)
			analeptic:setSkillName("_Chunlao")
			if not dying.who:isProhibited(dying.who, analeptic) then
				room:useCard(sgs.CardUseStruct(analeptic, dying.who, dying.who, false))
			end
		end
	end,
	on_turn_broken = function(self, function_name, event, room, player, data, ask_who)
		if event == sgs.EventPhaseStart then
			player:removeTag("ChunlaoCards")
		end
	end
}
ChengPu:addSkill(Chunlao)

----------------------------------------------------------------------------------------------------

--[[ YJ 104 关兴张苞
	武将：GuanXingZhangBao
	武将名：关兴张苞
	体力上限：4
	武将技能：
		父魂：你可以将两张手牌当【杀】使用或打出；当你于出牌阶段内以此法使用【杀】造成伤害后，你拥有“武圣”和“咆哮”，直到回合结束。
	状态：验证通过
]]--
GuanXingZhangBao = sgs.General(extensionYJCM2012, "GuanXingZhangBao", "shu", 4, true)

--[[
	技能名：父魂
	技能：Fuhun
	描述：你可以将两张手牌当【杀】使用或打出；当你于出牌阶段内以此法使用【杀】造成伤害后，你拥有“武圣”和“咆哮”，直到回合结束。
	状态：验证通过
	注：张飞小关张双将使用第二张杀还是会亮张飞，这是由于源码咆哮类技能的亮将机制所致
]]--
wusheng_GuanXingZhangBao = sgs.CreateWushengSkill("GuanXingZhangBao")
paoxiao_GuanXingZhangBao = sgs.CreatePaoxiaoSkill("GuanXingZhangBao")
paoxiaoArmorNullificaion_GuanXingZhangBao = sgs.CreatePaoxiaoArmorNullificaionSkill("GuanXingZhangBao")
FuhunVS = sgs.CreateViewAsSkill{
	name = "Fuhun",
	n = 2,
	response_or_use = true,
	view_filter = function(self, selected, to_select)
		return (#selected < 2) and (not to_select:isEquipped())
	end,
	view_as = function(self, cards)
		if #cards ~= 2 then return nil end
		local slash = sgs.Sanguosha:cloneCard("Slash", sgs.Card_SuitToBeDecided, -1)
		slash:setSkillName(self:objectName())
		slash:setShowSkill(self:objectName())
		slash:addSubcard(cards[1])
		slash:addSubcard(cards[2])
		return slash
	end,
	enabled_at_play = function(self, player)
		return (player:getHandcardNum() >= 2) and sgs.Slash_IsAvailable(player)
	end,
	enabled_at_response = function(self, player, pattern)
		return (player:getHandcardNum() >= 2) and (pattern == "slash")
	end
}
Fuhun = sgs.CreateTriggerSkill{
	name = "Fuhun",
	can_preshow = false,
	events = {sgs.EventPhaseStart},
	priority = 8,
	view_as_skill = FuhunVS,
	on_record = function(self, event, room, player, data)
		if (player:getPhase() == sgs.Player_NotActive) and (player:getMark("FuhunSuccess") > 0) then
			room:setPlayerMark(player, "FuhunSuccess", 0)
			room:handleAcquireDetachSkills(player, "-wusheng_GuanXingZhangBao|-paoxiao_GuanXingZhangBao", true)
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
FuhunAcquire = sgs.CreateTriggerSkill{
	name = "#Fuhun-acquire",
	events = {sgs.Damage},
	frequency = sgs.Skill_Compulsory,
	can_trigger = function(self, event, room, player, data)
		if not (player and player:isAlive() and player:hasSkill("Fuhun")) then return "" end
		if (event == sgs.Damage) and (player:getMark("FuhunSuccess") == 0) then
			local damage = data:toDamage()
			if damage.card and damage.card:isKindOf("Slash") and (damage.card:getSkillName() == "Fuhun") and (player:getPhase() == sgs.Player_Play) then
				return self:objectName()
			end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		room:broadcastSkillInvoke("Fuhun", 2, player)
		if player:ownSkill("Fuhun") and not player:hasShownSkill("Fuhun") then
			player:showGeneral(player:inHeadSkills("Fuhun"))
		end
		return true
	end,
	on_effect = function(self, event, room, player, data)
		room:handleAcquireDetachSkills(player, player:inHeadSkills("Fuhun") and "wusheng_GuanXingZhangBao|paoxiao_GuanXingZhangBao" or "wusheng_GuanXingZhangBao!|paoxiao_GuanXingZhangBao!")
		room:setPlayerMark(player, "FuhunSuccess", 1)
	end,
}
GuanXingZhangBao:addSkill(Fuhun)
GuanXingZhangBao:addSkill(FuhunAcquire)
sgs.insertRelatedSkills(extensionYJCM2012, "Fuhun", "#Fuhun-acquire")
local skillList = sgs.SkillList()
if not sgs.Sanguosha:getSkill("wusheng_GuanXingZhangBao") then skillList:append(wusheng_GuanXingZhangBao) end
if not sgs.Sanguosha:getSkill("paoxiao_GuanXingZhangBao") then skillList:append(paoxiao_GuanXingZhangBao) end
if not sgs.Sanguosha:getSkill("#paoxiao-null_GuanXingZhangBao") then skillList:append(paoxiaoArmorNullificaion_GuanXingZhangBao) end
sgs.Sanguosha:addSkills(skillList)
sgs.insertRelatedSkills(extensionYJCM2012, "paoxiao_GuanXingZhangBao", "#paoxiao-null_GuanXingZhangBao")
GuanXingZhangBao:addRelateSkill("wusheng_GuanXingZhangBao")  --会导致重复，但是2.1.0不会显示在技能浏览，而下个版本直接用ViewHas就Ok了
GuanXingZhangBao:addRelateSkill("paoxiao_GuanXingZhangBao")

----------------------------------------------------------------------------------------------------

--[[ YJ 105 韩当
	武将：HanDang
	武将名：韩当
	体力上限：4
	武将技能：
		弓骑：出牌阶段限一次，你可以弃置一张牌，令你的攻击范围于此回合内无限，然后若你以此法弃置的牌为装备牌，你可以弃置一名其他角色的一张牌。
		解烦：限定技，出牌阶段，你可以选择一名角色，令攻击范围内含有该角色的所有角色各一项：1. 弃置一张武器牌；2. 令其摸一张牌。
	状态：验证通过
]]--
HanDang = sgs.General(extensionYJCM2012, "HanDang", "wu", 4, true)

--[[
	技能名：弓骑
	技能：Gongqi
	描述：出牌阶段限一次，你可以弃置一张牌，令你的攻击范围于此回合内无限，然后若你以此法弃置的牌为装备牌，你可以弃置一名其他角色的一张牌。
	状态：验证通过
]]--
GongqiCard = sgs.CreateSkillCard{
	name = "GongqiCard",
	skill_name = "Gongqi",
	target_fixed = true,
	will_throw = true,
	mute = true,
	on_use = function(self, room, source, targets)
		room:setPlayerFlag(source, "InfinityAttackRange")
		local cd = sgs.Sanguosha:getCard(self:getSubcards():first())
		if cd:isKindOf("EquipCard") then
			room:broadcastSkillInvoke("Gongqi", 2, source)
			local _targets = sgs.SPlayerList()
			for _, p in sgs.qlist(room:getOtherPlayers(source)) do
				if source:canDiscard(p, "he") then _targets:append(p) end
			end
			if not _targets:isEmpty() then
				local to_discard = room:askForPlayerChosen(source, _targets, "Gongqi", "@Gongqi-discard", true)
				if to_discard then
					local id = room:askForCardChosen(source, to_discard, "he", "Gongqi", false, sgs.Card_MethodDiscard)
					local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_DISMANTLE, source:objectName(), to_discard:objectName(), "Gongqi", nil)
					room:throwCard(sgs.Sanguosha:getCard(id), reason, to_discard, source)
				end
			end
		else
			room:broadcastSkillInvoke("Gongqi", 1, source)
		end
	end
}
Gongqi = sgs.CreateOneCardViewAsSkill{
	name = "Gongqi",
	filter_pattern = ".!",
	view_as = function(self, card)
		local acard = GongqiCard:clone()
		acard:addSubcard(card)
		acard:setSkillName(self:objectName())
		acard:setShowSkill(self:objectName())
		return acard
	end,
	enabled_at_play = function(self, player)
		return not player:hasUsed("#GongqiCard")
	end
}
HanDang:addSkill(Gongqi)

--[[
	技能名：解烦
	技能：Jiefan
	描述：限定技，出牌阶段，你可以选择一名角色，令攻击范围内含有该角色的所有角色各一项：1. 弃置一张武器牌；2. 令其摸一张牌。
	状态：验证通过
]]--
JiefanCard = sgs.CreateSkillCard{
	name = "JiefanCard",
	skill_name = "Jiefan",
	mute = true,
	filter = function(self, targets, to_select)
		return #targets == 0
	end,
	about_to_use = function(self, room, cardUse)
		room:removePlayerMark(cardUse.from, "@rescue")
		room:broadcastSkillInvoke("Jiefan", cardUse.from)
		room:doSuperLightbox("HanDang", "Jiefan")
		self:cardOnUse(room, cardUse)
	end,
	on_use = function(self, room, source, targets)
		local target = targets[1]
		local _targetdata = sgs.QVariant()
		_targetdata:setValue(target)
		source:setTag("JiefanTarget", _targetdata)
		for _, player in sgs.qlist(room:getOtherPlayers(target)) do
			if player:isAlive() and target:isAlive() and player:inMyAttackRange(target) then
				room:cardEffect(self, source, player)
			end
		end
		source:removeTag("JiefanTarget")
	end,
	on_effect = function(self, effect)
		local room = effect.to:getRoom()
		local target = effect.from:getTag("JiefanTarget"):toPlayer()
		local data = effect.from:getTag("JiefanTarget")
		if target then
			if not room:askForCard(effect.to, ".Weapon", "@Jiefan-discard::" .. target:objectName(), data) then
				target:drawCards(1, "Jiefan")
			end
		end
	end
}
JiefanVS = sgs.CreateZeroCardViewAsSkill{
	name = "Jiefan",
	view_as = function(self)
		local card = JiefanCard:clone()
		card:setSkillName(self:objectName())
		card:setShowSkill(self:objectName())
		return card
	end,
	enabled_at_play = function(self, player)
		return player:getMark("@rescue") >= 1
	end,
}
Jiefan = sgs.CreateTriggerSkill{
	name = "Jiefan",
	frequency = sgs.Skill_Limited,
	limit_mark = "@rescue",
	view_as_skill = JiefanVS,
}
HanDang:addSkill(Jiefan)

----------------------------------------------------------------------------------------------------

--[[ YJ 107 廖化
	武将：LiaoHua
	武将名：廖化
	体力上限：4
	武将技能：
		当先：锁定技，回合开始时，你执行一个额外的出牌阶段。
		伏枥：限定技，当你处于濒死状态时，你可以将体力值回复至X点（X为势力数），然后叠置。
	状态：复制原项目
]]--
LiaoHua = sgs.General(extensionYJCM2012, "LiaoHua", "shu", 4, true)

--[[
	技能名：当先
	技能：Dangxian
	描述：锁定技，回合开始时，你执行一个额外的出牌阶段。
	状态：复制原项目
]]--
function sgs.CreateDangxianSkill(name)
	local dangxian_skill = {
		name = "Dangxian_" .. name,
		can_preshow = true,
		events = {sgs.EventPhaseStart},
		frequency = sgs.Skill_Compulsory,
		can_trigger = function(self, event, room, player, data)
			if not player or player:isDead() or not player:hasSkill(self:objectName()) then
				return ""
			end
			if player:getPhase() == sgs.Player_RoundStart then
				return self:objectName()
			end
			return ""
		end,
		on_cost = function(self, event, room, player, data)
			if player:hasShownSkill(self) or player:askForSkillInvoke(self:objectName(), data) then
				room:broadcastSkillInvoke(self:objectName(), player)
				return true
			end
			return false
		end,
		on_effect = function(self, event, room, player, data)
			room:sendCompulsoryTriggerLog(player, self:objectName(), true)
			local thread = room:getThread()
			player:setPhase(sgs.Player_Play)
			room:broadcastProperty(player, "phase")
			if not thread:trigger(sgs.EventPhaseStart, room, player) then
				thread:trigger(sgs.EventPhaseProceeding, room, player)
			end
			thread:trigger(sgs.EventPhaseEnd, room, player)
			player:setPhase(sgs.Player_RoundStart)
			room:broadcastProperty(player, "phase")
		end
	}
	return sgs.CreateTriggerSkill(dangxian_skill)
end
Dangxian_LiaoHua = sgs.CreateDangxianSkill("LiaoHua")
LiaoHua:addSkill(Dangxian_LiaoHua)

--[[
	技能名：伏枥
	技能：Fuli
	描述：限定技，当你处于濒死状态时，你可以将体力值回复至X点（X为势力数），然后叠置。
	状态：复制原项目
]]--
Fuli = sgs.CreateTriggerSkill{
	name = "Fuli",
	can_preshow = true,
	limit_mark = "@laoji",
	frequency = sgs.Skill_Limited,
	events = {sgs.AskForPeaches},
	can_trigger = function(self, event, room, player, data)
		if player and player:isAlive() and player:hasSkill(self:objectName()) then
			local dying = data:toDying()
			if (player:objectName() == dying.who:objectName()) and (player:getMark("@laoji") > 0) and player:getHp() <= 0 then
				return self:objectName()
			end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		if player:askForSkillInvoke(self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), player)
			room:doSuperLightbox("LiaoHua", self:objectName())
			room:removePlayerMark(player, "@laoji")
			return true
		end
	end,
	on_effect = function(self, event, room, player, data)
		local recover = sgs.RecoverStruct()
		recover.recover = math.min(getKingdomCount(player), player:getMaxHp()) - player:getHp()
		recover.who = player
		room:recover(player, recover)
		player:turnOver()
	end,
}
LiaoHua:addSkill(Fuli)

----------------------------------------------------------------------------------------------------

--[[ YJ 108 刘表
	武将：LiuBiao
	武将名：刘表
	体力上限：4
	武将技能：
		自守：摸牌阶段，若你已受伤，你可以多摸X张牌（X为你已损失的体力值），然后跳过出牌阶段。
		宗室：锁定技，你的手牌上限+X（X为势力数）。
	状态：复制原项目并调整
]]--
LiuBiao = sgs.General(extensionYJCM2012, "LiuBiao", "qun", 4, true)

--[[
	技能名：自守
	技能：Zishou
	描述：摸牌阶段，若你已受伤，你可以多摸X张牌（X为你已损失的体力值），然后跳过出牌阶段。
	状态：复制原项目并调整
]]--
Zishou = sgs.CreateDrawCardsSkill{
	name = "Zishou",
	can_preshow = true,
	can_trigger = function(self, event, room, player, data)
		if not player or player:isDead() or not player:hasSkill(self:objectName()) then
			return false
		end
		if player:isWounded() then
			return self:objectName()
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		if player:askForSkillInvoke(self:objectName(), data) then
			local skin_id = player:property((player:inHeadSkills(self) and "head" or "deputy") .. "_skin_id"):toInt()
			room:broadcastSkillInvoke(self:objectName(), (skin_id == 1) and math.min(3, player:getLostHp()) or -1, player)
			return true
		end
	end,
	draw_num_func = function(self, player, n)
		player:clearHistory()
		player:skip(sgs.Player_Play)
		return n + player:getLostHp()
	end,
}
LiuBiao:addSkill(Zishou)

--[[
	技能名：宗室
	技能：Zongshi_LiuBiao
	描述：锁定技，你的手牌上限+X（X为势力数）。
	状态：复制原项目并调整
]]--
function sgs.CreateZongshiSkill(name)
	local zongshi_skill = {
		name = "Zongshi_" .. name,
		can_preshow = true,
		frequency = sgs.Skill_Compulsory,  --因为此技能必须尚未亮将，所以不需要处理无法取消的问题
		events = {sgs.EventPhaseProceeding},
		can_trigger = function(self, event, room, player, data)
			if not player or player:isDead() or not player:hasSkill(self:objectName()) then return "" end
			if (player:getPhase() == sgs.Player_Discard) and not player:hasShownSkill(self:objectName()) then  --进入弃牌阶段询问是否发动宗室存牌
				if (player:getMaxCards(sgs.Max) < player:getHandcardNum()) and getKingdomCount(player) > 0 then
					return self:objectName()
				end
			end
			return ""
		end,
		on_cost = function(self, event, room, player, data)
			return player:hasShownSkill(self:objectName()) or room:askForSkillInvoke(player, self:objectName(), data)
		end,
		on_effect = function(self, event, room, player, data)
			room:notifySkillInvoked(player, self:objectName())
		end,
	}
	return sgs.CreateTriggerSkill(zongshi_skill)
end
Zongshi_LiuBiao = sgs.CreateZongshiSkill("LiuBiao")
function sgs.CreateZongshiMaxCardsSkill(name)
	local zongshi_maxcards_skill = {
		name = "#Zongshi-MaxCards_" .. name,
		extra_func = function(self, target)
			if target:hasShownSkill("Zongshi_" .. name) then
				return getKingdomCount(target)
			else
				return 0
			end
		end
	}
	return sgs.CreateMaxCardsSkill(zongshi_maxcards_skill)
end
ZongshiMaxCards_LiuBiao = sgs.CreateZongshiMaxCardsSkill("LiuBiao")
LiuBiao:addSkill(Zongshi_LiuBiao)
LiuBiao:addSkill(ZongshiMaxCards_LiuBiao)
sgs.insertRelatedSkills(extensionYJCM2012, "Zongshi_LiuBiao", "#Zongshi-MaxCards_LiuBiao")

----------------------------------------------------------------------------------------------------

--[[ YJ 110 王异
	武将：WangYi
	武将名：王异
	体力上限：3
	武将技能：
		贞烈：当你成为其他角色使用【杀】或普通锦囊牌的目标后，你可以失去1点体力，令此牌对你无效，然后你弃置其一张牌。
		秘计：结束阶段开始时，若你已受伤，你可以摸一至X张牌（X为你已损失的体力值），然后将等量的手牌交给其他角色。
	状态：复制手册
]]--
WangYi = sgs.General(extensionYJCM2012, "WangYi", "wei", 3, false)

--[[
	技能名：贞烈
	技能：Zhenlie
	描述：当你成为其他角色使用【杀】或普通锦囊牌的目标后，你可以失去1点体力，令此牌对你无效，然后你弃置其一张牌。
	状态：复制手册
]]--
function sgs.CreateZhenlieSkill(name)
	local zhenlie_skill = {
		name = "Zhenlie_" .. name,
		can_preshow = true,
		frequency = sgs.Skill_NotFrequent,
		events = sgs.TargetConfirmed,
		can_trigger = function(self, event, room, player, data)
			if player and player:isAlive() and player:hasSkill(self:objectName()) and player:getHp() > 0 then
				local use = data:toCardUse()
				if use.from and use.from:objectName() ~= player:objectName() and use.to:contains(player) then
					if use.card:isKindOf("Slash") or use.card:isNDTrick() then
						local skill_list = {}
						for _,p in sgs.qlist(use.to) do
							if p:objectName() == player:objectName() then
								table.insert(skill_list, self:objectName())
							end
						end
						return table.concat(skill_list, ",")
					end
				end
			end
			return ""
		end,
		on_cost = function(self, event, room, player, data)
			if player:askForSkillInvoke(self:objectName(), data) then
				room:broadcastSkillInvoke(self:objectName(), player)
				room:loseHp(player)
				return true
			end
			return false 
		end,
		on_effect = function(self, event, room, player, data)
			if not player:isAlive() then return false end
			local use = data:toCardUse()
			local nullified_list = use.nullified_list
			table.insert(nullified_list, player:objectName())
			use.nullified_list = nullified_list
			data:setValue(use)
			if player:canDiscard(use.from, "he") then
				local id = room:askForCardChosen(player, use.from, "he", self:objectName(), false, sgs.Card_MethodDiscard)
				local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_DISMANTLE, player:objectName(), use.from:objectName(), self:objectName(), nil)
				room:throwCard(sgs.Sanguosha:getCard(id), reason, use.from, player)
			end
			return false 
		end,
	}
	return sgs.CreateTriggerSkill(zhenlie_skill)
end
Zhenlie_WangYi = sgs.CreateZhenlieSkill("WangYi")
WangYi:addSkill(Zhenlie_WangYi)

--[[
	技能名：秘计
	技能：Miji
	描述：结束阶段开始时，若你已受伤，你可以摸一至X张牌（X为你已损失的体力值），然后将等量的手牌交给其他角色。
	状态：复制手册并小改
]]--
MijiCard = sgs.CreateSkillCard{
	name = "MijiCard",
	skill_name = "Miji",
	target_fixed = false,
	will_throw = false,
	mute = true,
	handling_method = sgs.Card_MethodNone,
	filter = function(self, targets, to_select, player)
		return #targets == 0 and to_select:objectName() ~= player:objectName()
	end,
	feasible = function(self, targets, player)
		return #targets == 1
	end,
	about_to_use = function(self, room, cardUse)
		local source, target = cardUse.from, cardUse.to:at(0)
		room:removePlayerMark(source, self:getSkillName().."_num", self:subcardsLength())
		local data = sgs.QVariant()
		data:setValue(target)
		source:setTag(self:getSkillName().."_target", data)
	end,
}
MijiVS = sgs.CreateViewAsSkill{   
	name = "Miji",
	view_filter = function(self, selected, to_select)
		return sgs.Self:getMark(self:objectName().."_num") > #selected and table.contains(sgs.Self:property(self:objectName().."_hands"):toString():split("+"), tostring(to_select:getId()))
	end, 
	view_as = function(self, originalCards) 
		if #originalCards > 0 then
			local skillcard = MijiCard:clone()
			for _, card in ipairs(originalCards) do
				skillcard:addSubcard(card)
			end
			skillcard:setSkillName(self:objectName())
			return skillcard
		end
	end, 
	enabled_at_play = function(self, player)
		return false
	end,
	enabled_at_response = function(self, player, pattern)
		return string.startsWith(pattern, "@@"..self:objectName())
	end,
}
Miji = sgs.CreateTriggerSkill{
	name = "Miji",
	can_preshow = true,
	events = {sgs.EventPhaseStart},
	view_as_skill = MijiVS,
	can_trigger = function(self, event, room, player, data)
		if player and player:isAlive() and player:hasSkill(self:objectName()) then
			if player:getPhase() == sgs.Player_Finish and player:isWounded() then
				return self:objectName()
			end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		if player:askForSkillInvoke(self:objectName(), data) then
			local skin_id = player:property((player:inHeadSkills(self) and "head" or "deputy") .. "_skin_id"):toInt()
			room:broadcastSkillInvoke(self:objectName(), (skin_id == 1) and 1 or -1, player)
			return true
		end
		return false 
	end,
	on_effect = function(self, event, room, player, data)
		local num = 1
		if player:getLostHp() > 1 then
			local nums = "1"
			for i = 2, player:getLostHp() do
				nums = (math.mod(i, 5) == 1) and nums.."|"..i or nums.."+"..i
			end
			num = tonumber(room:askForChoice(player, "Miji_draw", nums))
		end
		player:drawCards(num, self:objectName())
		num = math.min(num, player:getHandcardNum())
		if num <= 0 then return end
		room:setPlayerMark(player, self:objectName() .. "_num", num)
		
		if player:isKongcheng() then return end
		
		local ids, get = sgs.QList2Table(player:handCards()), {}

		--local pattern, prompt = "@@"..self:objectName(), "@"..self:objectName()..":::"  --For OL Miji
		local pattern, prompt = "@@"..self:objectName() .. "!", "@"..self:objectName()..":::"
		while #ids > 0 and player:getMark(self:objectName().."_num") > 0 do
			room:setPlayerProperty(player, self:objectName().."_hands", sgs.QVariant(table.concat(ids, "+")))
			local u_card = room:askForUseCard(player, pattern, prompt..player:getMark(self:objectName().."_num") )
			if not u_card then
				break
			end
			local target = player:getTag(self:objectName().."_target"):toPlayer()

			for _, id in sgs.qlist(u_card:getSubcards()) do
				table.removeOne(ids, id)
				table.insert(get, target:objectName().."|"..id)
			end
			--pattern = "@@"..self:objectName().."!"  --For OL Miji
			--prompt = "@"..self:objectName().."2:::"  --For OL Miji
		end
		
		if (player:getMark(self:objectName() .. "_num") > 0) and (#ids > 0) and (not player:isKongcheng()) then  --Give the remaining cards randomly
																												 --To be removed for OL Miji
			local rest_num = player:getMark(self:objectName() .. "_num")
			for i = 1, rest_num, 1 do
				id = ids[math.random(1, #ids)]
				local receiver = room:getOtherPlayers(player):at(math.random(0, player:aliveCount() - 2))
				table.insert(get, receiver:objectName() .. "|" .. id) 
				table.removeOne(ids, id)
			end
		end

		local moves = sgs.CardsMoveList()
		local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_GIVE, player:objectName(), self:objectName(), "")
		for _, p in sgs.qlist(room:getAllPlayers()) do
			local _ids = sgs.IntList()
			for _, toget in ipairs(get) do
				if toget:split("|")[1] == p:objectName() then _ids:append(tonumber(toget:split("|")[2])) end
			end
			if not _ids:isEmpty() then
				local move = sgs.CardsMoveStruct(_ids, player, p, sgs.Player_PlaceHand, sgs.Player_PlaceHand, reason)
				moves:append(move)
			end
		end
		player:setMark(self:objectName().."_num", 0)
		if not moves:isEmpty() then 
			local skin_id = player:property((player:inHeadSkills(self) and "head" or "deputy") .. "_skin_id"):toInt()
			if skin_id == 1 then room:broadcastSkillInvoke(self:objectName(), math.random(2, 3), player) end
			room:moveCardsAtomic(moves, false)
		end
		
		return false 
	end,
}
WangYi:addSkill(Miji)

--------------------------------------------一将成名2013--------------------------------------------

extensionYJCM2013 = sgs.Package("YJCM2013", sgs.Package_GeneralPack)

--[[ YJ 201 曹冲
	武将：CaoChong
	武将名：曹冲
	体力上限：3
	武将技能：
		称象：当你受到伤害后，你可以亮出牌堆顶的四张牌，然后获得其中至少一张点数之和不大于13的牌，并将其余的牌置入弃牌堆。
		仁心：当其他角色受到伤害时，若其体力值为1，你可以弃置一张装备牌，叠置，然后防止此伤害。
	状态：验证通过
]]--
CaoChong = sgs.General(extensionYJCM2013, "CaoChong", "wei", 3, true)

--[[
	技能名：称象
	技能：Chengxiang
	描述：当你受到伤害后，你可以亮出牌堆顶的四张牌，然后获得其中至少一张点数之和不大于13的牌，并将其余的牌置入弃牌堆。
	状态：验证通过
]]--
function ChengxiangAsMovePattern(selected, to_select)
	local sum = 0
	for _,id in ipairs(selected) do
		sum = sum + sgs.Sanguosha:getCard(id):getNumber()
	end
	if to_select ~= -1 then
		sum = sum + sgs.Sanguosha:getCard(to_select):getNumber()
	end
	return sum <= 13
end
Chengxiang = sgs.CreateTriggerSkill{
	name = "Chengxiang",
	can_preshow = true,
	frequency = sgs.Skill_Frequent,
	events = sgs.Damaged,
	can_trigger = function(self, event, room, player, data)
		if not (player and player:isAlive() and player:hasSkill(self:objectName())) then return "" end
		return self:objectName()
	end,
	on_cost = function(self, event, room, player, data)
		if player:askForSkillInvoke(self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), player)
			return true 
		end
		return false 
	end,
	on_effect = function(self, event, room, player, data)
		local card_ids = room:getNCards(4, false)
		local move = sgs.CardsMoveStruct()
		move.card_ids = card_ids
		move.to = player
		move.to_place = sgs.Player_PlaceTable
		move.reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_TURNOVER, player:objectName(), self:objectName(), nil)
		room:moveCardsAtomic(move, true)
		
		local numbers = {}
		for _,id in sgs.qlist(card_ids) do
			table.insert(numbers, sgs.Sanguosha:getCard(id):getNumber())
		end
		table.sort(numbers)
		local max_cards, min_sum = 0, 0
		for _,num in ipairs(numbers) do
			min_sum = min_sum + num
			if min_sum <= 13 then max_cards = max_cards + 1 end
		end
		
		local result = room:askForMoveCards(player, card_ids, sgs.IntList(), true, self:objectName(), "ChengxiangAsMovePattern", self:objectName(), 1, max_cards, false, true)
		local dummy = sgs.DummyCard()
		if not result.bottom:isEmpty() then
			dummy:addSubcards(result.bottom)
			player:obtainCard(dummy)
		end
		if not result.top:isEmpty() then
			dummy:clearSubcards()
			dummy:addSubcards(result.top)
			local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_NATURAL_ENTER, player:objectName(), self:objectName(), nil)
			room:throwCard(dummy, reason, nil)
		end
		dummy:deleteLater()
		return false
	end,
}
CaoChong:addSkill(Chengxiang)

--[[
	技能名：仁心
	技能：Renxin
	描述：当其他角色受到伤害时，若其体力值为1，你可以弃置一张装备牌，叠置，然后防止此伤害。
	状态：验证通过
]]--
Renxin = sgs.CreateTriggerSkill{
	name = "Renxin",
	can_preshow = true,
	events = {sgs.DamageInflicted},
	can_trigger = function(self, event, room, player, data)
		local damage = data:toDamage()
		if damage.to and damage.to:isAlive() and (damage.to:getHp() == 1) then
			local skill_list, player_list = {}, {}
			for _,p in sgs.qlist(room:getOtherPlayers(damage.to)) do
				if p:hasSkill(self:objectName()) and p:canDiscard(p, "he") then
					table.insert(skill_list, self:objectName())
					table.insert(player_list, p:objectName())
				end
			end
			return table.concat(skill_list, "|"), table.concat(player_list, "|")
		end
		return ""
		--[[elseif (event == sgs.ChoiceMade) and player:hasSkill(self:objectName()) then  --根据规则翻面已改为效果而非消耗
			local data_list = data:toString():split(":")
			if (#data_list > 3) and (data_list[3] == "@Renxin-card") and (data_list[#data_list] ~= "_nil_") then
				player:turnOver()
			end
		end]]
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		if room:askForCard(ask_who, ".Equip", "@Renxin-card:" .. player:objectName(), data, self:objectName()) then
			room:broadcastSkillInvoke(self:objectName(), ask_who)
			return true 
		end
		return false 
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		ask_who:turnOver()
		local msg = sgs.LogMessage()
		msg.type, msg.from, msg.arg = "#Renxin", player, self:objectName()
		room:sendLog(msg)
		return true
	end,
}
CaoChong:addSkill(Renxin)

----------------------------------------------------------------------------------------------------

--[[ YJ 202 伏皇后
	武将：FuHuangHou
	武将名：伏皇后
	体力上限：3
	武将技能：
		惴恐：其他角色的回合开始时，若你已受伤，你可以与其拼点：若你赢，当其于此回合内使用牌时，其取消除其外的目标；若你没赢，该角色无视与你的距离，直到回合结束。
		求援：当你成为【杀】的目标时，你可以令一名除此【杀】使用者外的的其他角色交给你一张【闪】，否则该角色也成为此【杀】的目标。
	状态：复制原项目
]]--
FuHuangHou = sgs.General(extensionYJCM2013, "FuHuangHou", "qun", 3, false)

--[[
	技能名：惴恐
	技能：Zhuikong
	描述：其他角色的回合开始时，若你已受伤，你可以与其拼点：若你赢，当其于此回合内使用牌时，其取消除其外的目标；若你没赢，该角色无视与你的距离，直到回合结束。
	状态：复制原项目并调整
]]--
Zhuikong = sgs.CreateTriggerSkill{
	name = "Zhuikong",
	can_preshow = true,
	events = {sgs.EventPhaseStart},
	can_trigger = function(self, event, room, player, data)
		if not player or player:isDead() or player:getPhase() ~= sgs.Player_RoundStart or player:isKongcheng() then return "" end
		local queens = room:findPlayersBySkillName(self:objectName())
		queens:removeOne(player)
		local skill_list,player_list = {},{}
		for _, fuhuanghou in sgs.qlist(queens) do
			if fuhuanghou:isWounded() and not fuhuanghou:isKongcheng() then
				table.insert(skill_list, self:objectName())
				table.insert(player_list, fuhuanghou:objectName())
			end
		end
		return table.concat(skill_list,"|"), table.concat(player_list,"|")
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		if ask_who:isAlive() and ask_who:isWounded() and not ask_who:isKongcheng() and player:isAlive() and not player:isKongcheng() then
			local d = sgs.QVariant()
			d:setValue(player)
			if room:askForSkillInvoke(ask_who, self:objectName(), d) then
				room:broadcastSkillInvoke(self:objectName(), ask_who)
				local pd = ask_who:pindianSelect(player, self:objectName())
				local _data = sgs.QVariant()
				_data:setValue(pd)
				ask_who:setTag("Zhuikong_pd", _data)
				return true
			end
		end
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		local pd = ask_who:getTag("Zhuikong_pd"):toPindian()
		ask_who:removeTag("Zhuikong_pd")
		if not pd then return end
		if ask_who:pindian(pd) then
			if player:isAlive() then room:setPlayerFlag(player, "DisableOtherTargets") end
		else
			if player:isDead() or ask_who:isDead() then return end
			room:setFixedDistance(player, ask_who, 1)
			local queens = player:getTag("Zhuikong_data"):toList()
			local d = sgs.QVariant()
			d:setValue(ask_who)
			queens:append(d)
			player:setTag("Zhuikong_data", sgs.QVariant(queens))
		end
	end,
	on_turn_broken = function(self, function_name, event, room, player, data, ask_who)
		ask_who:removeTag("Zhuikong_pd")
	end,
}
ZhuikongClear = sgs.CreateTriggerSkill{
	name = "#Zhuikong-clear",
	global = true,
	events = {sgs.EventPhaseStart},
	priority = 8,
	on_record = function(self, event, room, player, data)
        if player:getPhase() ~= sgs.Player_NotActive then return false end
		local Qqueens = player:getTag("Zhuikong_data"):toList()
		for _, Qp in sgs.qlist(Qqueens) do
			room:setFixedDistance(player, Qp:toPlayer(), -1)
		end
		player:removeTag("Zhuikong_data")
        return false
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
--[[ZhuikongProhibit = sgs.CreateProhibitSkill{
	name = "#Zhuikong",
	is_prohibited = function(self, from, to, card)
		return from:hasTag("ZhuikongLimit") and (from:objectName() ~= to:objectName()) and (card:getTypeId() ~= sgs.Card_TypeSkill)
	end
}]]
FuHuangHou:addSkill(Zhuikong)
FuHuangHou:addSkill(ZhuikongClear)
sgs.insertRelatedSkills(extensionYJCM2013, "Zhuikong", "#Zhuikong-clear")

--[[
	技能名：求援
	技能：Qiuyuan
	描述：当你成为【杀】的目标时，你可以令一名除此【杀】使用者外的的其他角色交给你一张【闪】，否则该角色也成为此【杀】的目标。
	状态：复制原项目
]]--
Qiuyuan = sgs.CreateTriggerSkill{
	name = "Qiuyuan",
	events = {sgs.TargetConfirming},
	can_trigger = function(self, event, room, player, data)
		local use = data:toCardUse()
		if not player or player:isDead() or not player:hasSkill(self:objectName()) then return false end
		if not use.card or not use.card:isKindOf("Slash") or not use.to:contains(player) then return false end
		local players = room:getOtherPlayers(player)
		players:removeOne(use.from)
		if not players:isEmpty() then
			return self:objectName()
		end
	end,
	on_cost = function(self, event, room, player, data)
		local use = data:toCardUse()
		local players = room:getOtherPlayers(player)
		players:removeOne(use.from)
		local d, _data = sgs.QVariant(), sgs.QVariant()			--for AI
		d:setValue(use)
		room:setTag("Qiuyuan_data", d)
		local target = room:askForPlayerChosen(player, players, self:objectName(), "Qiuyuan-invoke", true, true)
		room:removeTag("Qiuyuan_data")
		if target then
			_data:setValue(target)
			player:setTag("Qiuyuan_tar", _data)
			if matchPlayerName(target, "fuwan") then
				room:broadcastSkillInvoke(self:objectName(), 2)
			else
				room:broadcastSkillInvoke(self:objectName(), 1)
			end
			return true
		end
	end,
	on_effect = function(self, event, room, player, data)
		local room = player:getRoom()
		local use = data:toCardUse()
		local target = player:getTag("Qiuyuan_tar"):toPlayer()
		player:removeTag("Qiuyuan_tar")
		local card
		local _data = sgs.QVariant()
		_data:setValue(player)
		if not target:isKongcheng() then
			card = room:askForCard(target, "Jink", "@Qiuyuan-give:" .. player:objectName(), _data, sgs.Card_MethodNone)
			local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_GIVE, target:objectName(), player:objectName(), self:objectName(), "")
			if card then
				room:obtainCard(player, card, reason)
				return false
			end
		end
		if use.from:canSlash(target, use.card, false) then
			local l = sgs.LogMessage()
			if use.card:isVirtualCard() then
				l.type = "#BecomeTarget"
				l.from = target
				l.arg = use.card:objectName()
			else
				l.type = "$BecomeTarget"
				l.from = target
				l.card_str = use.card:toString()
			end
			room:sendLog(l)
			room:doAnimate(1, player:objectName(), target:objectName())
			use.to:append(target)
			room:sortByActionOrder(use.to)
			data:setValue(use)
		end
		return false
	end,
}
FuHuangHou:addSkill(Qiuyuan)

----------------------------------------------------------------------------------------------------

--[[ YJ 203 关平
	武将：GuanPing
	武将名：关平
	体力上限：4
	武将技能：
		龙吟：当一名角色于出牌阶段内使用【杀】时，你可以弃置一张牌，令此【杀】不计入次数限制，然后若此【杀】为红色，你摸一张牌。
	状态：复制原项目
]]--
GuanPing = sgs.General(extensionYJCM2013, "GuanPing", "shu", 4, true)

--[[
	技能名：龙吟
	技能：Longyin
	描述：当一名角色于出牌阶段内使用【杀】时，你可以弃置一张牌，令此【杀】不计入次数限制，然后若此【杀】为红色，你摸一张牌。
	状态：复制原项目并调整
]]--
Longyin = sgs.CreateTriggerSkill{
	name = "Longyin",
	events = {sgs.CardUsed},
	can_preshow = true,
	can_trigger = function(self, event, room, player, data)
		local use = data:toCardUse()
		if use.from and use.from:getPhase() == sgs.Player_Play and use.card:isKindOf("Slash") then
			for _,guanping in sgs.qlist(room:findPlayersBySkillName(self:objectName())) do
				if guanping and guanping:canDiscard(guanping, "he") then
					return self:objectName(), guanping
				end
			end
		end	
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		if ask_who and ask_who:canDiscard(ask_who, "he") and room:askForCard(ask_who, "..", "@Longyin", data, self:objectName()) then
			room:broadcastSkillInvoke(self:objectName(), data:toCardUse().card:isRed() and 2 or 1, ask_who)
			return true
		end
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		local use = data:toCardUse()
		if use.m_addHistory then
			room:addPlayerHistory(player, use.card:getClassName(), -1)
			use.m_addHistory = false
			data:setValue(use)
		end
		if use.card:isRed() and ask_who:isAlive() then
			ask_who:drawCards(1, self:objectName())
		end
	end
}
GuanPing:addSkill(Longyin)

----------------------------------------------------------------------------------------------------

--[[ YJ 204 郭淮
	武将：GuoHuai
	武将名：郭淮
	体力上限：4
	武将技能：
		精策：出牌阶段结束时，若你于此回合内使用过的牌数不小于你的体力值，你可以摸两张牌。
	状态：复制手册
]]--
GuoHuai = sgs.General(extensionYJCM2013, "GuoHuai", "wei", 4, true)
GuoHuai:addCompanion("zhanghe")

--[[
	技能名：精策
	技能：Jingce
	描述：出牌阶段结束时，若你于此回合内使用过的牌数不小于你的体力值，你可以摸两张牌。
	状态：复制手册
]]--
JingceRecord = sgs.CreateTriggerSkill{
	name = "#Jingce-record",
	events = {sgs.PreCardUsed, sgs.CardResponded, sgs.EventPhaseStart},
	priority = 8,
	global = true,
	on_record = function(self, event, room, player, data)
		if not (player and player:isAlive()) then return end
		if (event == sgs.PreCardUsed) or (event == sgs.CardResponded) then
			local card
			if event == sgs.PreCardUsed then
				card = data:toCardUse().card
			elseif event == sgs.CardResponded then
				local response = data:toCardResponse()
				card = response.m_isUse and response.m_card
			end
			if card and card:getHandlingMethod() == sgs.Card_MethodUse and card:getTypeId() ~= sgs.Card_TypeSkill then
				if player:getPhase() <= sgs.Player_Play then player:addMark("Jingce") end
			end
		elseif event == sgs.EventPhaseStart and player:getPhase() == sgs.Player_RoundStart then
			player:setMark("Jingce", 0)
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
Jingce = sgs.CreateTriggerSkill{
	name = "Jingce",
	can_preshow = true,
	frequency = sgs.Skill_Frequent,
	events = {sgs.EventPhaseEnd},
	can_trigger = function(self, event, room, player, data)
		if player and player:isAlive() and player:hasSkill(self:objectName()) and event == sgs.EventPhaseEnd and player:getPhase() == sgs.Player_Play then
			if player:getMark(self:objectName()) >= player:getHp() then
				return self:objectName()
			end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		if player:askForSkillInvoke(self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), player)
			return true 
		end
		return false 
	end,
	on_effect = function(self, event, room, player, data)
		player:drawCards(2, self:objectName())
		return false 
	end,
}
GuoHuai:addSkill(Jingce)
GuoHuai:addSkill(JingceRecord)
sgs.insertRelatedSkills(extensionYJCM2013, "Jingce", "#Jingce-record")

----------------------------------------------------------------------------------------------------

--[[ YJ 205 简雍
	武将：JianYong
	武将名：简雍
	体力上限：3
	武将技能：
		巧说：出牌阶段开始时，你可以与一名其他角色拼点：若你赢，本回合你使用的下一张基本牌或普通锦囊牌可以额外（无距离限制）或少选择一个目标；若你没赢，你不能使用锦囊牌，直到回合结束。
		纵适：当你拼点赢后，你可以获得两张拼点的牌中点数小的一张；当你拼点没赢后，你可以获得你拼点的牌。
	状态：验证通过
]]--
JianYong = sgs.General(extensionYJCM2013, "JianYong", "shu", 3, true)

--[[
	技能名：巧说
	技能：Qiaoshui
	描述：出牌阶段开始时，你可以与一名其他角色拼点：若你赢，本回合你使用的下一张基本牌或普通锦囊牌可以额外（无距离限制）或少选择一个目标；若你没赢，你不能使用锦囊牌，直到回合结束。
	状态：验证通过
]]--
ExtraCollateralCard = sgs.CreateSkillCard{
	name = "ExtraCollateralCard",
	filter = function(self, targets, to_select)
		local coll = sgs.Card_Parse(sgs.Self:property("extra_collateral"):toString())
		if (not coll) then return false end
		local tos = sgs.Self:property("extra_collateral_current_targets"):toString():split("+")
		if (#targets == 0) then
			return (not table.contains(tos, to_select:objectName())) 
					and (not sgs.Self:isProhibited(to_select, coll)) and coll:targetFilter(targetsTable2QList(targets), to_select, sgs.Self)
		else
			return coll:targetFilter(targetsTable2QList(targets), to_select, sgs.Self)
		end
	end,
	about_to_use = function(self, room, cardUse)
		local killer = cardUse.to:first()
		local victim = cardUse.to:last()
		killer:setFlags("ExtraCollateralTarget")
		local _data = sgs.QVariant()
		_data:setValue(victim)
		killer:setTag("collateralVictim", _data)
	end
}
QiaoshuiVS = sgs.CreateZeroCardViewAsSkill{
	name = "Qiaoshui" ,
	view_as = function(self)
		return ExtraCollateralCard:clone()
	end,
	enabled_at_play = function(self, player)
		return false
	end,
	enabled_at_response = function(self, player, pattern)
		return string.find(pattern, "@@Qiaoshui")
	end,
}
Qiaoshui = sgs.CreatePhaseChangeSkill{
	name = "Qiaoshui",
	can_preshow = true,
	view_as_skill = QiaoshuiVS,
	can_trigger = function(self, event, room, player, data)
		if not (player and player:isAlive() and player:hasSkill(self:objectName())) then return "" end
		if (player:getPhase() == sgs.Player_Play) and (not player:isKongcheng()) then
			local can_invoke = false
			local other_players = room:getOtherPlayers(player)
			for _, player in sgs.qlist(other_players) do
				if not player:isKongcheng() then
					can_invoke = true
					break
				end
			end
			if (can_invoke) then
				return self:objectName()
			end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		local targets = sgs.SPlayerList()
		for _, player in sgs.qlist(room:getOtherPlayers(player)) do
			if not player:isKongcheng() then
				targets:append(player)
			end
		end
		local target = room:askForPlayerChosen(player, targets, self:objectName(), "@Qiaoshui", true, true)
		if target then
			room:broadcastSkillInvoke(self:objectName(), player)
			local pd = player:pindianSelect(target, self:objectName())
			local _data = sgs.QVariant()
			_data:setValue(pd)
			player:setTag("Qiaoshui_pd", _data)
			return true
		end
	end,
	on_phasechange = function(self, player)
		local room = player:getRoom()
		local pd = player:getTag("Qiaoshui_pd"):toPindian()
		player:removeTag("Qiaoshui_pd")
		if not pd then return end
		if player:pindian(pd) then
			if player:isAlive() then room:addPlayerMark(player, "QiaoshuiSuccess") end
		else
			if player:isAlive() then room:setPlayerCardLimitation(player, "use", "TrickCard", true) end
		end
	end,
	on_turn_broken = function(self, function_name, event, room, player, data)
		player:removeTag("Qiaoshui_pd")
	end
}
QiaoshuiUse = sgs.CreateTriggerSkill{
	name = "#Qiaoshui-use",
	events = {sgs.PreCardUsed},
	global = true,
	view_as_skill = QiaoshuiVS,
	can_trigger = function(self, event, room, player, data)
		if player:isDead() or player:getMark("QiaoshuiSuccess") <= 0 then return false end
		local use = data:toCardUse()
		if (use.card:isNDTrick() or use.card:isKindOf("BasicCard")) then
			--if (sgs.Sanguosha:getCurrentCardUseReason() ~= sgs.CardUseStruct_CARD_USE_REASON_PLAY) then
			if use.card:isKindOf("Jink") or use.card:isKindOf("Nullification") then  --源码REASON_PLAY应该是为了防止这俩目标是牌的，而不是将玉玺、方天也封杀
				return ""
			end
			local available_targets = sgs.VariantList()
			local dat = sgs.QVariant()
			if ((not use.card:isKindOf("AOE")) and (not use.card:isKindOf("GlobalEffect")) and (not use.card:isKindOf("AwaitExhausted"))) or use.card:isKindOf("AllianceFeast") then
				room:setPlayerFlag(player, "QiaoshuiExtraTarget")
				for _, p in sgs.qlist(room:getAlivePlayers()) do
					if (use.to:contains(p) or player:isProhibited(p, use.card)) then continue end
					if (use.card:targetFixed()) then
						if use.card:isAvailable(p) then
							dat = sgs.QVariant()
							dat:setValue(p)
							available_targets:append(dat)
						end
					elseif not use.card:isKindOf("AllianceFeast") then
						if (use.card:targetFilter(sgs.PlayerList(), p, player)) then
							dat = sgs.QVariant()
							dat:setValue(p)
							available_targets:append(dat)
						end
					elseif use.card:isKindOf("AllianceFeast") and use.card:targetFilter(sgs.PlayerList(), p, player) then  --联军盛宴只能选择目标数为1的势力
						local same_kingdom_targets = sgs.SPlayerList()
						same_kingdom_targets:append(p)
						for _,p2 in sgs.qlist(room:getLieges(p:getKingdom(), p)) do  --getLieges还能这样用……
							if not player:isProhibited(p2, use.card) then
								same_kingdom_targets:append(p2)
							end
						end
						if same_kingdom_targets:length() == 1 then
							dat = sgs.QVariant()
							dat:setValue(p)
							available_targets:append(dat)
						end
					end
				end
				room:setPlayerFlag(player, "-QiaoshuiExtraTarget")
			end
			player:setTag("QiaoshuiAvailableTargets", sgs.QVariant(available_targets))
			local choices = {"cancel"}
			if (use.to:length() > 1) then table.insert(choices, 1, "remove") end
			if (not available_targets:isEmpty()) then table.insert(choices, 1, "add") end
			if #choices == 1 then return "" end
			local trigger_list = {}
			for i = 1, player:getMark("QiaoshuiSuccess"), 1 do
				table.insert(trigger_list, self:objectName())
			end
			return table.concat(trigger_list, ",")
		end
	end,
	on_cost = function(self, event, room, player, data)
		local use = data:toCardUse()
		local available_targets_qvar = player:getTag("QiaoshuiAvailableTargets"):toList()
		local choices = {"cancel"}
		if (use.to:length() > 1) then table.insert(choices, 1, "remove") end
		if (not available_targets_qvar:isEmpty()) then table.insert(choices, 1, "add") end
		local choice = room:askForChoice(player, "Qiaoshui", table.concat(choices, "+"), data)
		player:removeTag("QiaoshuiAvailableTargets")
		if (choice == "cancel") then
			return false
		elseif choice == "add" then
			local extra = nil
			local available_targets = sgs.SPlayerList()
			for _,qvar in sgs.qlist(available_targets_qvar) do
				available_targets:append(qvar:toPlayer())
			end
			if not use.card:isKindOf("Collateral") then  --联军盛宴不需要单独判断，因为目标数必定为1，且无势力武将无法使用联军盛宴，不需要willBeFriendWith
				extra = room:askForPlayerChosen(player, available_targets, "QiaoshuiTarget", "@Qiaoshui-add:::" .. use.card:objectName())
			else
				local tos = {}
				for _, t in sgs.qlist(use.to) do
					table.insert(tos, t:objectName())
				end
				room:setPlayerProperty(player, "extra_collateral", sgs.QVariant(use.card:toString()))
				room:setPlayerProperty(player, "extra_collateral_current_targets", sgs.QVariant(table.concat(tos, "+")))
				room:askForUseCard(player, "@@Qiaoshui!", "@Qiaoshui-add:::collateral")
				room:setPlayerProperty(player, "extra_collateral", sgs.QVariant(""))
				room:setPlayerProperty(player, "extra_collateral_current_targets", sgs.QVariant("+"))
				for _, p in sgs.qlist(room:getOtherPlayers(player)) do
					if p:hasFlag("ExtraCollateralTarget") then
						p:setFlags("-ExtraCollateralTarget")
						extra = p
						break
					end
				end
				if (extra == nil) then
					extra = available_targets:at(math.random(available_targets:length()) - 1)
					local victims = sgs.SPlayerList()
					for _, p in sgs.qlist(room:getOtherPlayers(extra)) do
						if (extra:canSlash(p) and not (p:objectName() == player:objectName() and p:hasSkill("kongcheng") and p:isLastHandCard(use.card, true))) then
							victims:append(p)
						end
					end
					if victims:isEmpty() then return false end
					local _data = sgs.QVariant()
					_data:setValue(victims:at(math.random(victims:length()) - 1))
					extra:setTag("collateralVictim", _data)
				end
			end
			local dat = sgs.QVariant()
			dat:setValue(extra)
			player:setTag("QiaoshuiAdd", dat)
		else
			local removed = room:askForPlayerChosen(player, use.to, "QiaoshuiTarget", "@Qiaoshui-remove:::" .. use.card:objectName())
			local dat = sgs.QVariant()
			dat:setValue(removed)
			player:setTag("QiaoshuiRemove", dat)
		end
		return true
	end,
	on_effect = function(self, event, room, player, data)
		local use = data:toCardUse()
		if player:getTag("QiaoshuiAdd"):toPlayer() ~= nil then
			local extra = player:getTag("QiaoshuiAdd"):toPlayer()
			player:removeTag("QiaoshuiAdd")
			use.to:append(extra)
			room:sortByActionOrder(use.to)
			local msg = sgs.LogMessage()
			if use.card:isVirtualCard() then
				msg.type, msg.from, msg.arg2, msg.arg = "#QiaoshuiAdd", player, use.card:objectName(), "Qiaoshui"
			else
				msg.type, msg.from, msg.card_str, msg.arg = "$QiaoshuiAdd", player, use.card:toString(), "Qiaoshui"
			end
			msg.to:append(extra)
			room:sendLog(msg)
			room:doAnimate(1, player:objectName(), extra:objectName())
			if use.card:isKindOf("Collateral") then
				local victim = extra:getTag("collateralVictim"):toPlayer()
				if victim then
					msg = sgs.LogMessage()
					msg.type, msg.from = "#CollateralSlash", player
					msg.to:append(victim)
					room:sendLog(msg)
					room:doAnimate(1, extra:objectName(), victim:objectName())
				end
			end
		elseif player:getTag("QiaoshuiRemove"):toPlayer() ~= nil then
			local removed = player:getTag("QiaoshuiRemove"):toPlayer()
			player:removeTag("QiaoshuiRemove")
			use.to:removeOne(removed)
			local msg = sgs.LogMessage()
			if use.card:isVirtualCard() then
				msg.type, msg.from, msg.arg2, msg.arg = "#QiaoshuiRemove", player, use.card:objectName(), "Qiaoshui"
			else
				msg.type, msg.from, msg.card_str, msg.arg = "$QiaoshuiRemove", player, use.card:toString(), "Qiaoshui"
			end
			msg.to:append(removed)
			room:sendLog(msg)
		end
		data:setValue(use)
		return false
	end,
	on_turn_broken = function(self, function_name, event, room, player, data)
		player:removeTag("QiaoshuiAdd")
		player:removeTag("QiaoshuiRemove")
		player:removeTag("QiaoshuiAvailableTargets")
	end
}
QiaoshuiClear = sgs.CreateTriggerSkill{
	name = "#Qiaoshui-clear",
	events = {sgs.PreCardUsed},
	priority = 1,
	global = true,
	on_record = function(self, event, room, player, data)
		local use = data:toCardUse()
		if (use.card:isNDTrick() or use.card:isKindOf("BasicCard")) then
			room:setPlayerMark(player, "QiaoshuiSuccess", 0)
			player:removeTag("QiaoshuiAvailableTargets")
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
QiaoshuiClear2 = sgs.CreateTriggerSkill{
	name = "#Qiaoshui-clear2",
	events = {sgs.EventPhaseStart},
	priority = 8,
	global = true,
	on_record = function(self, event, room, player, data)
		if player:getPhase() ~= sgs.Player_NotActive then return false end
		room:setPlayerMark(player, "QiaoshuiSuccess", 0)
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end
}
QiaoshuiTargetMod = sgs.CreateTargetModSkill{
	name = "#Qiaoshui-target" ,
	pattern = "BasicCard,TrickCard+^DelayedTrick" ,
	distance_limit_func = function(self, from)
		if from:hasFlag("QiaoshuiExtraTarget") then
			return 1000
		end
		return 0
	end
}
JianYong:addSkill(Qiaoshui)
JianYong:addSkill(QiaoshuiUse)
JianYong:addSkill(QiaoshuiClear)
JianYong:addSkill(QiaoshuiClear2)
JianYong:addSkill(QiaoshuiTargetMod)
sgs.insertRelatedSkills(extensionYJCM2013, "Qiaoshui", "#Qiaoshui-use", "#Qiaoshui-clear", "#Qiaoshui-clear2", "#Qiaoshui-target")

--[[
	技能名：纵适
	技能：ZongshiJY
	描述：当你拼点赢后，你可以获得两张拼点的牌中点数小的一张；当你拼点没赢后，你可以获得你拼点的牌。
	状态：验证通过
]]--
ZongshiJY = sgs.CreateTriggerSkill{
	name = "ZongshiJY",
	can_preshow = true,
	events = {sgs.Pindian},
	frequency = sgs.Skill_Frequent,
	can_trigger = function(self, event, room, player, data)
		local pindian = data:toPindian()
		local skill_list, player_list = {}, {}
		for _, jianyong in sgs.qlist(room:findPlayersBySkillName(self:objectName())) do
			if (jianyong:objectName() == pindian.from:objectName()) or (jianyong:objectName() == pindian.to:objectName()) then
				table.insert(skill_list, self:objectName())
				table.insert(player_list, jianyong:objectName())
			end
		end
		return table.concat(skill_list, "|"), table.concat(player_list, "|")
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		if ask_who:askForSkillInvoke(self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), ask_who)
			return true 
		end
		return false 
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		local pindian = data:toPindian()
		local isfrom = (pindian.from:objectName() == ask_who:objectName())
		local to_obtain = nil
		if isfrom then
			if pindian.from_number > pindian.to_number then
				to_obtain = pindian.to_card
			else
				to_obtain = pindian.from_card
			end
		else
			if pindian.from_number < pindian.to_number then
				to_obtain = pindian.from_card
			else
				to_obtain = pindian.to_card
			end
		end
		if to_obtain and (room:getCardPlace(to_obtain:getEffectiveId()) == sgs.Player_PlaceTable) then
			ask_who:obtainCard(to_obtain)
		end
	end
}
JianYong:addSkill(ZongshiJY)

----------------------------------------------------------------------------------------------------

--[[ YJ 206 李儒
	武将：LiRu
	武将名：李儒
	体力上限：3
	武将技能：
		绝策：结束阶段开始时，你可以对一名没有手牌的角色造成1点伤害。
		灭计：出牌阶段限一次，你可以将一张黑色锦囊牌置于牌堆顶并选择一名有手牌的其他角色，该角色弃置一张锦囊牌，否则弃置两张非锦囊牌。
		焚城：限定技，出牌阶段，你可以令所有其他角色选择一项：1. 弃置至少X张牌（X为上一名进行选择的角色以此法弃置的牌数+1）；2. 受到你造成的2点火焰伤害。
	状态：复制原项目
]]--
LiRu = sgs.General(extensionYJCM2013, "LiRu", "qun", 3, true)
LiRu:addCompanion("dongzhuo")

--[[
	技能名：绝策
	技能：Juece
	描述：结束阶段开始时，你可以对一名没有手牌的角色造成1点伤害。
	状态：复制原项目
]]--
Juece = sgs.CreatePhaseChangeSkill{
	name = "Juece",
	frequency = sgs.Skill_NotFrequent,
	can_preshow = true,
	can_trigger = function(self, event, room, player, data)
		if not player or player:isDead() or not player:hasSkill(self:objectName()) or (player:getPhase() ~= sgs.Player_Finish) then return "" end
		for _, p in sgs.qlist(room:getAlivePlayers()) do
			if p:isKongcheng() then
				return self:objectName()
			end
		end
		return ""
	end,
	on_cost = function(self,event,room,player,data)
		local targets = sgs.SPlayerList()
		for _, p in sgs.qlist(room:getAlivePlayers()) do
			if p:isKongcheng() then
				targets:append(p)
			end
		end
		local target = room:askForPlayerChosen(player, targets, self:objectName(), "@Juece", true, true)
		if target then
			room:broadcastSkillInvoke(self:objectName(), player)
			local d = sgs.QVariant()
			d:setValue(target)
			player:setTag("Juece_tar", d)
			return true
		end
	end,
	on_phasechange = function(self, player)
		local room = player:getRoom()
		local target = player:getTag("Juece_tar"):toPlayer()
		player:removeTag("Juece_tar")
		local damage = sgs.DamageStruct()
		damage.from = player
		damage.reason = self:objectName()
		damage.to = target
		room:damage(damage)
	end,
}
LiRu:addSkill(Juece)

--[[
	技能名：灭计
	技能：Mieji
	描述：出牌阶段限一次，你可以将一张黑色锦囊牌置于牌堆顶并选择一名有手牌的其他角色，该角色弃置一张锦囊牌，否则弃置两张非锦囊牌。
	状态：复制原项目并调整
]]--
MiejiCard = sgs.CreateSkillCard{
	name = "MiejiCard",
	skill_name = "Mieji",
	will_throw = false,
	handling_method = sgs.Card_MethodNone,
	filter = function(self, targets, to_select, player)
		return #targets == 0 and not to_select:isKongcheng() and to_select:objectName() ~= player:objectName()
	end,
	extra_cost = function(self, room, card_use)
		local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_PUT, card_use.from:objectName(), "Mieji", "")
		room:moveCardTo(self, card_use.from, nil, sgs.Player_DrawPile, reason, true)		
	end,
	on_effect = function(self, effect)
		local room = effect.from:getRoom()
		local cards = effect.to:getCards("he")
		local done = false
		while not done do
			done = true
			for _, c in sgs.qlist(cards) do
				if effect.to:isJilei(c) then
					cards:removeOne(c)
					done = false
					break
				end
			end
		end
		if cards:length() == 0 then return end
		local instanceDiscard = false
		local instanceDiscardId = -1
		if cards:length() == 1 then
			instanceDiscard = true
		elseif cards:length() == 2 then
			local bothTrick = true
			local trickId = -1
			for _,c in sgs.qlist(cards) do
				if c:getTypeId() ~= sgs.Card_TypeTrick then
					bothTrick = false
				else
					trickId = c:getId()
				end
			end
			instanceDiscard = not bothTrick
			instanceDiscardId = trickId
		end
		if instanceDiscard then
			local dummy = sgs.DummyCard()
			if instanceDiscardId == -1 then
				dummy:addSubcards(cards)
			else
				dummy:addSubcard(instanceDiscardId)
			end
			local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_THROW, effect.to:objectName(), "Mieji", nil)
			room:throwCard(dummy, reason, effect.to)
			dummy:deleteLater()
		elseif not room:askForCard(effect.to, "@@MiejiDiscard!", "@Mieji-discard") then
			local dummy = sgs.Sanguosha:cloneCard("slash", sgs.Card_NoSuit, 0)
			local tricks = sgs.CardList()
			local non_tricks = sgs.CardList()
			for _,c in sgs.qlist(cards) do
				if c:getTypeId() == sgs.Card_TypeTrick then
					tricks:append(c)
				else
					non_tricks:append(c)
				end
			end
			if not tricks:isEmpty() then
				dummy:addSubcard(tricks:at(math.random(0, tricks:length() - 1)))
			else
				local random1 = math.random(0, non_tricks:length() - 1)
				dummy:addSubcard(non_tricks:at(random1))
				non_tricks:removeAt(random1)
				dummy:addSubcard(non_tricks:at(math.random(0, non_tricks:length() - 1)))
			end
			local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_THROW, effect.to:objectName(), "Mieji", nil)
			room:throwCard(dummy, effect.to)
			dummy:deleteLater()
		end
	end,
}
Mieji = sgs.CreateOneCardViewAsSkill{
	name = "Mieji",
	filter_pattern = "TrickCard|black",
	view_as = function(self, originalCard)
		local card = MiejiCard:clone()
		card:addSubcard(originalCard)
		card:setSkillName(self:objectName())
		card:setShowSkill(self:objectName())
		return card
	end,
	enabled_at_play = function(self, player)
		return not player:hasUsed("#MiejiCard")
	end
}
MiejiDiscard = sgs.CreateViewAsSkill{
	name = "MiejiDiscard",
	view_filter = function(self, selected, to_select)
		if sgs.Self:isJilei(to_select) then return false end
		if #selected == 0 then return true
		elseif #selected == 1 then
			return to_select:getTypeId() ~= sgs.Card_TypeTrick and selected[1]:getTypeId() ~= sgs.Card_TypeTrick
		else
			return false
		end
	end,
	view_as = function(self, cards)
		if #cards == 0 then return nil end
		local ok = false
		if #cards == 1 then
			ok = cards[1]:getTypeId() == sgs.Card_TypeTrick
		elseif #cards == 2 then
			ok = true
			for _, c in ipairs(cards) do
				if c:getTypeId() == sgs.Card_TypeTrick then
					ok = false
					break
				end
			end
		end
		if ok then
			local dummy = sgs.DummyCard()
			for _, c in ipairs(cards) do
				dummy:addSubcard(c)
			end
			return dummy
		end
	end,
 	enabled_at_play = function(self, player)
		return false
	end,
 	enabled_at_response = function(self, player, pattern)
		return pattern == "@@MiejiDiscard!"
	end,
}
LiRu:addSkill(Mieji)
local skills = sgs.SkillList()
if not sgs.Sanguosha:getSkill("MiejiDiscard") then skills:append(MiejiDiscard) end
sgs.Sanguosha:addSkills(skills)

--[[
	技能名：焚城
	技能：Fencheng
	描述：限定技，出牌阶段，你可以令所有其他角色选择一项：1. 弃置至少X张牌（X为上一名进行选择的角色以此法弃置的牌数+1）；2. 受到你造成的2点火焰伤害。
	状态：复制原项目并调整
]]--
FenchengCard = sgs.CreateSkillCard{
	name = "FenchengCard",
	skill_name = "Fencheng",
	target_fixed = true,
	mute = true,
	about_to_use = function(self, room, cardUse)
		room:removePlayerMark(cardUse.from, "@burn")
		room:broadcastSkillInvoke("Fencheng", cardUse.from)
		room:doSuperLightbox("LiRu", "Fencheng")
		self:cardOnUse(room, cardUse)
	end,
	on_use = function(self, room, source, targets)
		room:setTag("FenchengDiscard", sgs.QVariant(0))
		source:setFlags("FenchengUsing")
		for _, p in sgs.qlist(room:getOtherPlayers(source)) do
			if p:isAlive() then
				room:cardEffect(self, source, p)
				room:getThread():delay()
			end
		end
		source:setFlags("-FenchengUsing")
	end,
	on_effect = function(self, effect)
		local room = effect.to:getRoom()
		local length = room:getTag("FenchengDiscard"):toInt() + 1
		if not effect.to:canDiscard(effect.to, "he") or (effect.to:getCardCount(true) < length)
			or not room:askForDiscard(effect.to, "Fencheng", 1000, length, true, true, "@Fencheng:::" .. length) then
			room:setTag("FenchengDiscard", sgs.QVariant(0))
			
			local damage = sgs.DamageStruct()
			damage.from =  effect.from
			damage.reason = "Fencheng"
			damage.to = effect.to
			damage.damage = 2
			damage.nature = sgs.DamageStruct_Fire
			room:damage(damage)
		end
	end,
	on_turn_broken = function(self, function_name, room, data)
		if function_name == "on_use" then
			data:toCardUse().from:setFlags("-FenchengUsing")
		elseif function_name == "on_effect" then
			data:toCardEffect().from:setFlags("-FenchengUsing")
		end
	end
}
FenchengVS = sgs.CreateZeroCardViewAsSkill{
	name = "Fencheng",
	view_as = function(self)
		local card = FenchengCard:clone()
		card:setShowSkill(self:objectName())
		card:setSkillName(self:objectName())
		return card
	end,
	enabled_at_play = function(self, player)
		return player:getMark("@burn") > 0
	end,
}
Fencheng = sgs.CreateTriggerSkill{
	name = "Fencheng",
	can_preshow = false,
	events = {sgs.ChoiceMade},
	frequency = sgs.Skill_Limited,
	limit_mark = "@burn", 
	view_as_skill = FenchengVS,
	on_record = function(self, event, room, player, data)
		local data_str = data:toString():split(":")
		if (#data_str ~= 3) or (data_str[1] ~= "cardDiscard") or (data_str[2] ~= "Fencheng") then
			return
		end
		local num = data_str[3]:split("+")
		room:setTag("FenchengDiscard", sgs.QVariant(#num))
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
LiRu:addSkill(Fencheng)

----------------------------------------------------------------------------------------------------

--[[ YJ 207 刘封
	武将：LiuFeng
	武将名：刘封
	体力上限：4
	武将技能：
		陷嗣：准备阶段开始时，你可以选择一至两名有牌的角色，将这些角色的各一张牌置于武将牌上，称为“逆”；当一名角色需要对你使用【杀】时，其可以移去两张“逆”，视为对你使用【杀】（有距离限制且计入次数限制）。
	状态：验证通过
]]--
LiuFeng = sgs.General(extensionYJCM2013, "LiuFeng", "shu", 4, true)

--[[
	技能名：陷嗣
	技能：Xiansi
	描述：准备阶段开始时，你可以选择一至两名有牌的角色，将这些角色的各一张牌置于武将牌上，称为“逆”；当一名角色需要对你使用【杀】时，其可以移去两张“逆”，视为对你使用【杀】（有距离限制且计入次数限制）。
	状态：验证通过
	注：国战没有addSpecificAssignee，因此可能导致一些bug
]]--
Xiansi = sgs.CreatePhaseChangeSkill{
	name = "Xiansi", 
	can_preshow = false,
	can_trigger = function(self, event, room, player, data)
		if not player or player:isDead() or not player:hasSkill(self:objectName()) or (player:getPhase() ~= sgs.Player_Start) then return "" end
		for _, p in sgs.qlist(room:getAlivePlayers()) do
			if not p:isNude() then
				return self:objectName()
			end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		local to_choose = sgs.SPlayerList()
		for _, p in sgs.qlist(room:getAlivePlayers()) do
			if not p:isNude() then
				to_choose:append(p)
			end
		end
		local choices = room:askForPlayersChosen(player, to_choose, self:objectName(), 0 , 2, "@Xiansi-card", true)
		if choices:length() > 0 then
			room:sortByActionOrder(choices)
			local choices_qvar = sgs.VariantList()
			for _,p in sgs.qlist(choices) do
				dat = sgs.QVariant()
				dat:setValue(p)
				choices_qvar:append(dat)
			end
			player:setTag("Xiansi_invoke", sgs.QVariant(choices_qvar))
			room:broadcastSkillInvoke(self:objectName(), math.random(1, 2), player)
			return true
		end
		return false
	end,
	on_phasechange = function(self, player)
		local room = player:getRoom()
		local targets_qvar = player:getTag("Xiansi_invoke"):toList()
		player:removeTag("Xiansi_invoke")
		local target
		for _,target_qvar in sgs.qlist(targets_qvar) do
			target = target_qvar:toPlayer()
			if target and target:isAlive() and not target:isNude() and player:isAlive() then
				local id = room:askForCardChosen(player, target, "he", "Xiansi")
				player:addToPile("counter", id)
			end
		end
	end,
	on_turn_broken = function(self, function_name, event, room, player, data, ask_who)
		player:removeTag("Xiansi_invoke")
	end
}
XiansiAttach = sgs.CreateTriggerSkill{
	name = "#XiansiAttach", 
	events = {sgs.GeneralShown, sgs.DFDebut, sgs.EventAcquireSkill, sgs.EventLoseSkill},
	can_trigger = function(self, event, room, player, data)
		if ((event == sgs.GeneralShown) and (data:toBool() == player:inHeadSkills("Xiansi"))) or (event == sgs.DFDebut)
			or ((event == sgs.EventAcquireSkill) and (data:toString() == "Xiansi")) then
			if not (player and player:isAlive() and player:hasSkill(self:objectName())) then return "" end
			for _,p in sgs.qlist(room:getOtherPlayers(player)) do
				if not p:hasSkill("Xiansi_slash") then
					room:attachSkillToPlayer(p, "Xiansi_slash")
				end
			end
		elseif (event == sgs.EventLoseSkill) and (data:toString() == "Xiansi") then
			player:clearOnePrivatePile("counter")
			for _,p in sgs.qlist(room:getOtherPlayers(player)) do  --other Liufengs
				if p:hasShownSkill("Xiansi") then
					return ""
				end
			end
			for _,p in sgs.qlist(room:getOtherPlayers(player)) do
				if p:hasSkill("Xiansi_slash") then
					room:detachSkillFromPlayer(p, "Xiansi_slash", true)
				end
			end
		end
		return ""
	end,
}
XiansiSlashCard = sgs.CreateSkillCard{
	name = "XiansiSlashCard",
	skill_name = "Xiansi_slash",  --AI debug
	target_fixed = false,
	filter = function(self, targets, to_select) 
		local slash = sgs.Sanguosha:cloneCard("slash", sgs.Card_NoSuit, 0)
		if #targets == 0 then
			local filter = to_select:hasShownSkill("Xiansi") and (to_select:getPile("counter"):length() >= 2) and slash:targetFilter(sgs.PlayerList(), to_select, sgs.Self)
			slash:deleteLater()
			return filter
		else
			--slash:addSpecificAssignee(targets[1])
			local players = sgs.PlayerList()
			for i = 1, #targets do
				players:append(targets[i])
			end
			local filter = slash:targetFilter(players, to_select, sgs.Self)
			slash:deleteLater()
			return filter
		end
	end,
	feasible = function(self, targets)
		local liufeng
		for i = 1, #targets do
			if targets[i]:hasShownSkill("Xiansi") then
				liufeng = targets[i]
				break
			end
		end
		if not liufeng then return false end
		local slash = sgs.Sanguosha:cloneCard("slash", sgs.Card_NoSuit, 0)
		--slash:addSpecificAssignee(liufeng)
		local players = sgs.PlayerList()
		for i = 1, #targets do
			players:append(targets[i])
		end
		local feasible = slash:targetsFeasible(players, sgs.Self)
		slash:deleteLater()
		return feasible
	end,
	on_validate = function(self, carduse)
		local source = carduse.from
		local targets = carduse.to
		local room = source:getRoom()
		local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_REMOVE_FROM_PILE, "", "Xiansi", "")
		room:throwCard(self, reason, nil)
		local slash = sgs.Sanguosha:cloneCard("slash", sgs.Card_SuitToBeDecided, -1)
		slash:setSkillName("_Xiansi")
		local done = false
		while not done do
			done = true
			for _,target in sgs.qlist(targets) do
				if not source:canSlash(target, slash, false) then
					carduse.to:removeOne(target)
					done = false
					break
				end
			end
		end
		if carduse.to:length() > 0 then
			return slash
		else
			slash:deleteLater()
			return nil
		end
	end,
}
function canSlashLiufeng(player)
	local slash = sgs.Sanguosha:cloneCard("slash", sgs.Card_SuitToBeDecided, -1)
	for _,p in sgs.qlist(player:getAliveSiblings()) do
		if p:hasShownSkill("Xiansi") and (p:getPile("counter"):length() > 1) then
			if slash:targetFilter(sgs.PlayerList(), p, player) then
				slash:deleteLater()
				return true
			end
		end
	end
	slash:deleteLater()
	return false
end
XiansiSlash = sgs.CreateViewAsSkill{
	name = "Xiansi_slash",
	expand_pile = "%counter",
	view_filter = function(self, selected, to_select)
		if #selected >= 2 then return false end
		for _,p in sgs.qlist(sgs.Self:getAliveSiblings()) do
			if p:hasShownSkill("Xiansi") and (p:getPile("counter"):length() > 1) then
				return p:getPile("counter"):contains(to_select:getId())
			end
		end
		return false
	end,
	view_as = function(self, cards)
		if #cards == 2 then
			local card = XiansiSlashCard:clone()
			for _, c in ipairs(cards) do
				card:addSubcard(c)
			end
			return card
		end
		return nil
	end,
	enabled_at_play = function(self, player)
		return sgs.Slash_IsAvailable(player) and canSlashLiufeng(player)
	end, 
	enabled_at_response = function(self, player, pattern)
		return (pattern == "slash") and (sgs.Sanguosha:getCurrentCardUseReason() == sgs.CardUseStruct_CARD_USE_REASON_RESPONSE_USE) and canSlashLiufeng(player)
	end,
}
LiuFeng:addSkill(Xiansi)
LiuFeng:addSkill(XiansiAttach)
sgs.insertRelatedSkills(extensionYJCM2013, "Xiansi", "#XiansiAttach")
local skills = sgs.SkillList()
if not sgs.Sanguosha:getSkill("Xiansi_slash") then skills:append(XiansiSlash) end
sgs.Sanguosha:addSkills(skills)

----------------------------------------------------------------------------------------------------

--[[ YJ 208 满宠
	武将：ManChong
	武将名：满宠
	体力上限：3
	武将技能：
		峻刑：出牌阶段限一次，你可以弃置至少一张手牌并选择一名其他角色：令其选择一项：1. 弃置一张与你弃置的牌类型均不同的手牌；2. 叠置，然后摸等量的牌。
		御策：当你受到伤害后，你可以展示一张手牌，若如此做且此伤害有来源，伤害来源须弃置一张与此牌类型不同的手牌，否则你回复1点体力。
	状态：验证通过
]]--
ManChong = sgs.General(extensionYJCM2013, "ManChong", "wei", 3, true)
ManChong:addCompanion("caoren")
ManChong:addCompanion("CaoRen_13")
ManChong:addCompanion("CaoRen_15")

--[[
	技能名：峻刑
	技能：Junxing
	描述：出牌阶段限一次，你可以弃置至少一张手牌并选择一名其他角色：令其选择一项：1. 弃置一张与你弃置的牌类型均不同的手牌；2. 叠置，然后摸等量的牌。
	状态：验证通过
]]--
JunxingCard = sgs.CreateSkillCard{
	name = "JunxingCard",
	skill_name = "Junxing",
	will_throw = true,
	filter = function(self, targets, to_select)
		return (#targets == 0) and (to_select:objectName() ~= sgs.Self:objectName())
	end,
	on_use = function(self, room, source, targets)
		local target = targets[1]
		if not target:isAlive() then return end
		local type_name = {"BasicCard", "TrickCard", "EquipCard"}
		local types = {"BasicCard", "TrickCard", "EquipCard"}
		for _, id in sgs.qlist(self:getSubcards()) do
			local c = sgs.Sanguosha:getCard(id)
			table.removeOne(types, type_name[c:getTypeId()])
			if #types == 0 then break end
		end
		if (not target:canDiscard(target, "h")) or #types == 0 then
			target:turnOver()
			target:drawCards(self:getSubcards():length(), "Junxing")
		elseif not room:askForCard(target, table.concat(types, ",") .. "|.|.|hand", "@Junxing-discard") then
			target:turnOver()
			target:drawCards(self:getSubcards():length(), "Junxing")
		end
	end
}
Junxing = sgs.CreateViewAsSkill{
	name = "Junxing",
	n = 999,
	view_filter = function(self, selected, to_select)
		return (not to_select:isEquipped()) and (not sgs.Self:isJilei(to_select))
	end,
	view_as = function(self, cards)
		if #cards == 0 then return nil end
		local card = JunxingCard:clone()
		for _, c in ipairs(cards) do
			card:addSubcard(c)
		end
		card:setSkillName(self:objectName())
		card:setShowSkill(self:objectName())
		return card
	end,
	enabled_at_play = function(self, player)
		return player:canDiscard(player, "h") and (not player:hasUsed("#JunxingCard"))
	end
}
ManChong:addSkill(Junxing)

--[[
	技能名：御策
	技能：Yuce
	描述：当你受到伤害后，你可以展示一张手牌，若如此做且此伤害有来源，伤害来源须弃置一张与此牌类型不同的手牌，否则你回复1点体力。
	状态：验证通过
]]--
Yuce = sgs.CreateMasochismSkill{
	name = "Yuce",
	can_trigger = function(self, event, room, player, data)	
		if not player or player:isDead() or not player:hasSkill(self:objectName()) then return "" end
		return player:isKongcheng() and "" or self:objectName()
	end,
	on_cost = function(self, event, room, player, data)
		local card = room:askForCard(player, ".", "@Yuce-show", data, sgs.Card_MethodNone)
		if card then
			room:broadcastSkillInvoke(self:objectName(), player)
			room:notifySkillInvoked(player, self:objectName())
			local msg = sgs.LogMessage()
			msg.from, msg.type, msg.arg = player, "#InvokeSkill", self:objectName()
			room:sendLog(msg)
			room:showCard(player, card:getEffectiveId())
			room:setPlayerMark(player, "YuceTypeId", card:getTypeId())
			return true
		end
		return false
	end,
	on_damaged = function(self, player, damage)
		local room = player:getRoom()
		if (not damage.from) or (damage.from:isDead()) then return false end
		local typeid = player:getMark("YuceTypeId")
		local type_name = {"BasicCard", "TrickCard", "EquipCard"}
		local types = {"BasicCard", "TrickCard", "EquipCard"}
		table.removeOne(types, type_name[typeid])
		if not damage.from:canDiscard(damage.from, "h") and player:isAlive() then
			local recover = sgs.RecoverStruct()
			recover.who = player
			room:recover(player, recover)
		elseif not room:askForCard(damage.from, table.concat(types, ",") .. "|.|.|hand", "@Yuce-discard:" .. player:objectName() .. "::" .. types[1] .. ":" .. types[2]) and player:isAlive() then
			local recover = sgs.RecoverStruct()
			recover.who = player
			room:recover(player, recover)
		end
		return false
	end,
	on_turn_broken = function(self, function_name, event, room, player, data, ask_who)
		room:setPlayerMark(player, "YuceTypeId", 0)
	end
}
ManChong:addSkill(Yuce)

----------------------------------------------------------------------------------------------------

--[[ YJ 209 潘璋马忠
	武将：PanZhangMaZhong
	武将名：潘璋马忠
	体力上限：4
	武将技能：
		夺刀：当你受到【杀】造成的伤害后，你可以弃置一张牌，获得伤害来源装备区里的武器牌。
		暗箭：锁定技，当你使用【杀】对目标角色造成伤害时，若你不在其攻击范围内，你令此伤害+1。
	状态：复制原项目
]]--
PanZhangMaZhong = sgs.General(extensionYJCM2013, "PanZhangMaZhong", "wu", 4, true)

--[[
	技能名：夺刀
	技能：Duodao
	描述：当你受到【杀】造成的伤害后，你可以弃置一张牌，获得伤害来源装备区里的武器牌。
	状态：复制原项目
]]--
Duodao = sgs.CreateTriggerSkill{
	name = "Duodao",
	can_preshow = true,
	events = {sgs.Damaged},
	can_trigger = function(self, event, room, player, data)	
		local damage = data:toDamage()
		if player and player:isAlive() and player:hasSkill(self:objectName()) and player:canDiscard(player, "he") then
			if damage.card and damage.card:isKindOf("Slash") then
				return self:objectName() .. "->" .. damage.from:objectName()
			end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		if room:askForCard(ask_who, "..", "@Duodao-get", data, self:objectName()) then
			room:broadcastSkillInvoke(self:objectName(), ask_who)
			return true
		end
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		if ask_who:isAlive() and player:isAlive() and player:getWeapon() then
			room:obtainCard(ask_who, player:getWeapon(), sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_EXTRACTION, ask_who:objectName(), player:objectName(), self:objectName(), ""))
		end
		return false
	end
}
PanZhangMaZhong:addSkill(Duodao)

--[[
	技能名：暗箭
	技能：Anjian
	描述：锁定技，当你使用【杀】对目标角色造成伤害时，若你不在其攻击范围内，你令此伤害+1。
	状态：复制原项目
]]--
Anjian = sgs.CreateTriggerSkill{
	name = "Anjian",
	events = {sgs.DamageCaused},
	frequency = sgs.Skill_Compulsory,
	can_trigger = function(self, event, room, player, data)
		if player and player:isAlive() and player:hasSkill(self) then
			local damage = data:toDamage()
			if damage.to and damage.to:isAlive() and not (damage.to:inMyAttackRange(damage.from) or damage.to:objectName() == damage.from:objectName()) then 
				if damage.card and damage.card:isKindOf("Slash") and not (damage.chain or damage.transfer or not damage.by_user) then
					return self:objectName() .. "->" .. damage.to:objectName()
				end
			end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		local d = sgs.QVariant()
		d:setValue(player)
		ask_who:setTag("AnjianDamage", data)  --for AI
		local invoked = ask_who:hasShownSkill(self:objectName()) or room:askForSkillInvoke(ask_who, self:objectName(), d)
		ask_who:removeTag("AnjianDamage")
		if invoked then
			room:broadcastSkillInvoke(self:objectName(), ask_who)
			return true
		end
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		room:notifySkillInvoked(ask_who, self:objectName())
		local damage = data:toDamage()
		local log = sgs.LogMessage()
		log.type = "#AnjianBuff"
		log.from = ask_who
		log.to:append(player)
		log.arg = damage.damage
		log.arg2 = damage.damage + 1
		room:sendLog(log)
		damage.damage = damage.damage + 1
		data:setValue(damage)
	end,
}
PanZhangMaZhong:addSkill(Anjian)

----------------------------------------------------------------------------------------------------

--[[ YJ 210 虞翻
	武将：YuFan
	武将名：虞翻
	体力上限：3
	武将技能：
		纵玄：当你的牌因弃置而置入弃牌堆后，你可以将其中至少一张牌置于牌堆顶。
		直言：结束阶段开始时，你可以令一名角色摸一张牌并展示之，若此牌为装备牌，该角色使用之，然后其回复1点体力。
	状态：复制手册
]]--
YuFan = sgs.General(extensionYJCM2013, "YuFan", "wu", 3, true)

--[[
	技能名：纵玄
	技能：Zongxuan
	描述：当你的牌因弃置而置入弃牌堆后，你可以将其中至少一张牌置于牌堆顶。
	状态：复制手册并大改（因为结算+统一写法）
]]--
Zongxuan = sgs.CreateTriggerSkill{
	name = "Zongxuan",
	can_preshow = true,
	events = {sgs.CardsMoveOneTime},
	frequency = sgs.Skill_NotFrequent,
 	can_trigger = function(self, event, room, player, data)
		if not (player and player:isAlive()) then return end
		local move = data:toMoveOneTime()
		if move.from and move.from:objectName() == player:objectName()
			and (bit32.band(move.reason.m_reason, sgs.CardMoveReason_S_MASK_BASIC_REASON)) == sgs.CardMoveReason_S_REASON_DISCARD then
			
			if move.from_places:contains(sgs.Player_PlaceTable) and move.to_place == sgs.Player_DiscardPile then  --条件B
				local ZongxuanStack_str = player:getTag("ZongxuanStack"):toString()
				if ZongxuanStack_str == "" then return end
				local ZongxuanStack = ZongxuanStack_str:split("|")
				
				if player:hasSkill(self) and player:getTag("ZongxuanPopIndex"):toInt() ~= #ZongxuanStack then
					local ZongxuanOneTime_str = ZongxuanStack[#ZongxuanStack]
					local ZongxuanOneTime = ZongxuanOneTime_str:split("+")
					table.removeAll(ZongxuanOneTime, "-1")
					local ZongxuanRemains = {}
					for i, id in sgs.qlist(move.card_ids) do
						if table.contains(ZongxuanOneTime, tostring(id)) and room:getCardPlace(id) == sgs.Player_DiscardPile then
							table.insert(ZongxuanRemains, id)
						end
					end
					if next(ZongxuanRemains) then
						room:setPlayerProperty(player, "ZongxuanToGet", sgs.QVariant(table.concat(ZongxuanRemains, "+")))
						return self:objectName()
					end
				end
			end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		local ZongxuanStack_str = player:getTag("ZongxuanStack"):toString()
		local ZongxuanStack = ZongxuanStack_str:split("|")
		player:setTag("ZongxuanPopIndex", sgs.QVariant(#ZongxuanStack))
		
		if player:askForSkillInvoke(self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), player)
			return true
		end
		return false 
	end,
	on_effect = function(self, event, room, player, data)
		local ZongxuanToGet = player:property("ZongxuanToGet"):toString():split("+")
		room:setPlayerProperty(player, "ZongxuanToGet", sgs.QVariant())
		local card_ids, to_top = sgs.IntList(), sgs.IntList()
		for _, idstring in ipairs(ZongxuanToGet) do 
			card_ids:append(tonumber(idstring))
		end

		local AsMove = room:askForMoveCards(player, card_ids, sgs.IntList(), true, self:objectName(), "", self:objectName(), 1, card_ids:length(), false, false)
		if AsMove.bottom:isEmpty() then 
			return false 
		end
		
		for _, id in sgs.qlist(AsMove.bottom) do
			to_top:prepend(id)
		end
		local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_PUT, player:objectName(), self:objectName(), "")
		local move = sgs.CardsMoveStruct(to_top, player, nil, sgs.Player_DiscardPile, sgs.Player_DrawPile, reason)
		local moves = sgs.CardsMoveList()
		moves:append(move)
		room:setTag("ZongxuanMoving", sgs.QVariant(true))  --for AI (filterEvent)
		room:moveCardsAtomic(moves, true)
		room:removeTag("ZongxuanMoving")
		
		local tab = {}
		for _, id in sgs.qlist(AsMove.bottom) do
			table.insert(tab, id)
		end
		local msg = sgs.LogMessage()
		msg.type = "$GuanxingTop"
		msg.card_str = table.concat(tab, "+")
		room:sendLog(msg)
		return false
	end,
}
ZongxuanRecord = sgs.CreateTriggerSkill{
	name = "#Zongxuan-record",
	events = {sgs.CardsMoveOneTime},
	priority = 1,
	global = true,
 	on_record = function(self, event, room, player, data)
		if not (player and player:isAlive()) then return end
		local move = data:toMoveOneTime()
		if move.from and move.from:objectName() == player:objectName()
			and (bit32.band(move.reason.m_reason, sgs.CardMoveReason_S_MASK_BASIC_REASON)) == sgs.CardMoveReason_S_REASON_DISCARD then
			
			if (move.from_places:contains(sgs.Player_PlaceHand) or move.from_places:contains(sgs.Player_PlaceEquip))
				and move.to_place == sgs.Player_PlaceTable then  --条件A
				local card_ids = {-1}
				for i, id in sgs.qlist(move.card_ids) do
					if (move.from_places:at(i) == sgs.Player_PlaceHand or move.from_places:at(i) == sgs.Player_PlaceEquip) and room:getCardPlace(id) == sgs.Player_PlaceTable then
						table.insert(card_ids, id)
					end
				end
				
				local ZongxuanStack_str = player:getTag("ZongxuanStack"):toString()
				local ZongxuanStack = ZongxuanStack_str:split("|")
				table.removeAll(ZongxuanStack, "")
				table.insert(ZongxuanStack, table.concat(card_ids, "+"))
				player:setTag("ZongxuanStack", sgs.QVariant(table.concat(ZongxuanStack, "|")))
			elseif move.from_places:contains(sgs.Player_PlaceTable) and move.to_place == sgs.Player_DiscardPile then  --条件B
				local ZongxuanStack_str = player:getTag("ZongxuanStack"):toString()
				if ZongxuanStack_str == "" then return end
				local ZongxuanStack = ZongxuanStack_str:split("|")
				
				table.remove(ZongxuanStack, #ZongxuanStack)
				if next(ZongxuanStack) then player:setTag("ZongxuanStack", sgs.QVariant(table.concat(ZongxuanStack, "|")))
				else player:removeTag("ZongxuanStack") end
				player:removeTag("ZongxuanPopIndex")
			end
		end
	end,
 	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
YuFan:addSkill(Zongxuan)
YuFan:addSkill(ZongxuanRecord)
sgs.insertRelatedSkills(extensionYJCM2013, "Zongxuan", "#Zongxuan-record")

--[[
	技能名：直言
	技能：Zhiyan
	描述：结束阶段开始时，你可以令一名角色摸一张牌并展示之，若此牌为装备牌，该角色使用之，然后其回复1点体力。
	状态：复制手册
]]--
Zhiyan = sgs.CreateTriggerSkill{
	name = "Zhiyan",
	can_preshow = true,
	frequency = sgs.Skill_Frequent,
	events = sgs.EventPhaseStart,
	can_trigger = function(self, event, room, player, data)
		if not (player and player:isAlive() and player:hasSkill(self:objectName()) and player:getPhase() == sgs.Player_Finish) then return "" end
		return self:objectName()
	end,
	on_cost = function(self, event, room, player, data)
		local to = room:askForPlayerChosen(player, room:getAlivePlayers(), self:objectName(), self:objectName().."-invoke", true, true)
		if to then
			room:broadcastSkillInvoke(self:objectName(), player)
			local to_data = sgs.QVariant()
			to_data:setValue(to)
			player:setTag(self:objectName(), to_data)
			return true 
		end
		return false 
	end,
	on_effect = function(self, event, room, player, data)
		local to = player:getTag(self:objectName()):toPlayer()
		player:removeTag(self:objectName())
		local ids = room:getNCards(1, false)
		local card = sgs.Sanguosha:getCard(ids:first())
		room:obtainCard(to, card, false)
		if to:isAlive() then
			room:showCard(to, ids:first())
			if not card:isKindOf("EquipCard") then return false end
			if to:isAlive() and (room:getCardOwner(ids:first()):objectName() == to:objectName()) and not to:isLocked(card) then
				room:useCard(sgs.CardUseStruct(card, to, to))
				local recover = sgs.RecoverStruct()
				recover.who = player
				room:recover(to, recover)
			end
		end
		return false 
	end,
	on_turn_broken = function(self, function_name, event, room, player, data, ask_who)
		player:removeTag(self:objectName())
	end
}
YuFan:addSkill(Zhiyan)

----------------------------------------------------------------------------------------------------

--[[ YJ 211 朱然
	武将：ZhuRan
	武将名：朱然
	体力上限：4
	武将技能：
		胆守：出牌阶段，你可以弃置X张牌并选择攻击范围内的一名角色，若X：为1，你弃置其一张牌；为2，其将一张牌交给你；为3，你对其造成1伤害；不小于4，你与其各摸两张牌。（X为你于此阶段内已发动“胆守”的次数+1）
	状态：验证通过
]]--
ZhuRan = sgs.General(extensionYJCM2013, "ZhuRan", "wu", 4, true)
ZhuRan:addCompanion("sunquan")

--[[
	技能名：胆守
	技能：Danshou
	描述：出牌阶段，你可以弃置X张牌并选择攻击范围内的一名角色，若X：为1，你弃置其一张牌；为2，其将一张牌交给你；为3，你对其造成1伤害；不小于4，你与其各摸两张牌。（X为你于此阶段内已发动“胆守”的次数+1）
	状态：验证通过
]]--
inMyAttackRangeFromV2 = function(from, to, distance_fix)  --国战无distance_fix
	if from:distanceTo(to, distance_fix) == -1 then return false end
	if from:objectName() == to:objectName() then return false end
	local in_attack_range_players = from:property("in_my_attack_range"):toString():split("+")
	if table.contains(in_attack_range_players, to:objectName()) then  --for DIY Skills
		return true
	end
	return from:distanceTo(to, distance_fix) <= from:getAttackRange()
end
DanshouCard = sgs.CreateSkillCard{
	name = "DanshouCard",
	skill_name = "Danshou",
	will_throw = true,
	filter = function(self, targets, to_select, player)
		if (#targets ~= 0) then return false end
		if player:getWeapon() and self:getSubcards():contains(player:getWeapon():getId()) then
			local weapon = player:getWeapon():getRealCard():toWeapon()
			local distance_fix = weapon:getRange() - player:getAttackRange(false)
			if player:getOffensiveHorse() and self:getSubcards():contains(player:getOffensiveHorse():getId()) then
				distance_fix = distance_fix + 1
			end
			return inMyAttackRangeFromV2(player, to_select, distance_fix)
		elseif player:getOffensiveHorse() and self:getSubcards():contains(player:getOffensiveHorse():getId()) then
			return inMyAttackRangeFromV2(player, to_select, 1)
		else
			return player:inMyAttackRange(to_select) and (to_select ~= player)
		end
	end,
	on_effect = function(self, effect)
		local room = effect.from:getRoom()
		local len = self:subcardsLength()
		if len == 1 then
			if effect.from:isAlive() and effect.to:isAlive() and effect.from:canDiscard(effect.to, "he") then
				local id = room:askForCardChosen(effect.from, effect.to, "he", "Danshou", false, sgs.Card_MethodDiscard)
				local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_DISMANTLE, effect.from:objectName(), effect.to:objectName(), "Danshou", nil)
				room:throwCard(sgs.Sanguosha:getCard(id), reason, effect.to, effect.from)
			end
		elseif len == 2 then
			if effect.from:isAlive() and effect.to:isAlive() and not effect.to:isNude() then
				local card = room:askForExchange(effect.to, "Danshou", 1, 1, "@Danshou-give::" .. effect.from:objectName())
				if not card then
					card = sgs.Sanguosha:getCard(effect.to:getCards("he"):at(math.random(0, effect.to:getCards("he"):length() - 1)))
				end
				if card then
					local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_GIVE, effect.to:objectName(), effect.from:objectName(), "Danshou", "")
					room:obtainCard(effect.from, card, reason, false)
					card:deleteLater()
				end
			end
		elseif len == 3 then
			if effect.to:isAlive() then room:damage(sgs.DamageStruct("Danshou", effect.from, effect.to)) end
		elseif len >= 4 then
			if effect.from:isAlive() then room:drawCards(effect.from, 2, "Danshou") end
			if effect.to:isAlive() then room:drawCards(effect.to, 2, "Danshou") end
		end
	end
}
DanshouVS = sgs.CreateViewAsSkill{
	name = "Danshou",
	n = 999,
	view_filter = function(self, selected, to_select)
		return not sgs.Self:isJilei(to_select) and (#selected <= sgs.Self:getMark(self:objectName()))
	end,
	view_as = function(self, cards)
		if #cards ~= sgs.Self:getMark(self:objectName()) + 1 then return nil end
		local card = DanshouCard:clone()
		for _, c in ipairs(cards) do
			card:addSubcard(c)
		end
		card:setShowSkill(self:objectName())
		return card
	end,
	enabled_at_play = function(self, player)
		return player:canDiscard(player, "he")
	end,
}
Danshou = sgs.CreateTriggerSkill{
	name = "Danshou",
	can_preshow = false,
	events = {sgs.EventPhaseStart, sgs.PreCardUsed},
	view_as_skill = DanshouVS,
	priority = 6,
	on_record = function(self, event, room, player, data)  --这段代码是需要调用视为技才能执行的，因此不用global
		if (event == sgs.EventPhaseStart) and (player:getPhase() == sgs.Player_Play) then
			room:setPlayerMark(player, self:objectName(), 0)
		elseif event == sgs.PreCardUsed then
			local use = data:toCardUse()
			if use.card:objectName() == "DanshouCard" then
				room:addPlayerMark(use.from, self:objectName())
			end
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
ZhuRan:addSkill(Danshou)

--------------------------------------------一将成名2014--------------------------------------------

extensionYJCM2014 = sgs.Package("YJCM2014", sgs.Package_GeneralPack)

--[[ YJ 301 蔡夫人
	武将：CaiFuRen
	武将名：蔡夫人
	体力上限：3
	武将技能：
		窃听：其他角色的回合结束后，若其未于此回合内使用过牌指定除其外的角色为目标，你可以选择一项：1. 将其装备区里的一张牌置入你的装备区；2. 摸一张牌。
		献州：限定技，出牌阶段，你可以将装备区里的所有牌交给一名其他角色，令其选择一项：1. 令你回复X点体力；2. 对其攻击范围内的一至X名角色各造成1点伤害。（X为你以此法交给该角色的牌数）
	状态：复制原项目并调整
]]--
CaiFuRen = sgs.General(extensionYJCM2014, "CaiFuRen", "qun", 3, false)
CaiFuRen:addCompanion("LiuBiao")

--[[
	技能名：窃听
	技能：Qieting
	描述：其他角色的回合结束后，若其未于此回合内使用过牌指定除其外的角色为目标，你可以选择一项：1. 将其装备区里的一张牌置入你的装备区；2. 摸一张牌。
	状态：复制原项目并调整
]]--
QietingRecord = sgs.CreateTriggerSkill{
	name = "#Qieting-record",
	events = {sgs.PreCardUsed, sgs.TurnStart},
	global = true,
	priority = 1,
	on_record = function(self, event, room, player, data)
		if event == sgs.PreCardUsed and player:getPhase() ~= sgs.Player_NotActive and player:getMark("Qieting") == 0 then
			local use = data:toCardUse()
			if use.card:getTypeId() == sgs.Card_TypeSkill then return false end
			for _,t in sgs.qlist(use.to) do
				if t:objectName() ~= player:objectName() then
					player:addMark("Qieting")
					return
				end
			end
		elseif event == sgs.TurnStart then
			player:setMark("Qieting", 0)
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
Qieting = sgs.CreateTriggerSkill{
	name = "Qieting",
	can_preshow = true,
	events = {sgs.EventPhaseStart},
	frequency = sgs.Skill_Frequent,
	can_trigger = function(self, event, room, player, data)
		if player:getPhase() == sgs.Player_NotActive and player:getMark(self:objectName()) == 0 then
			local caifurens = room:findPlayersBySkillName(self:objectName())
			local skill_list = {}
			local name_list = {}
			for _, p in sgs.qlist(caifurens) do
				if room:getCurrent() ~= p then
					table.insert(skill_list, self:objectName())
					table.insert(name_list, p:objectName())
				end
			end
			return table.concat(skill_list,"|"), table.concat(name_list,"|")
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		local dat = sgs.QVariant()
		dat:setValue(player)
		return ask_who:askForSkillInvoke(self:objectName(), dat)
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		local choices = {}
		if player:isAlive() then
			for i = 0, 5, 1 do
				local ida = ask_who:getEquip(i)
				local idb = player:getEquip(i)
				if (not ida) and idb then
					table.insert(choices, tostring(i))
				end
			end
		end
		table.insert(choices, "draw")
		
		local d = sgs.QVariant()
		d:setValue(player)
		local choice = room:askForChoice(ask_who, self:objectName(), table.concat(choices, "+"), d)
		if choice ~= "draw" then	
			room:broadcastSkillInvoke(self:objectName(), 1, ask_who)
			local card = player:getEquip(tonumber(choice))
			room:moveCardTo(card, ask_who, sgs.Player_PlaceEquip)
		else
			room:broadcastSkillInvoke(self:objectName(), 2, ask_who)
			ask_who:drawCards(1)
		end
		return false
	end,
}
CaiFuRen:addSkill(Qieting)
CaiFuRen:addSkill(QietingRecord)
sgs.insertRelatedSkills(extensionYJCM2014, "Qieting", "#Qieting-record")

--[[
	技能名：献州
	技能：Xianzhou
	描述：限定技，出牌阶段，你可以将装备区里的所有牌交给一名其他角色，令其选择一项：1. 令你回复X点体力；2. 对其攻击范围内的一至X名角色各造成1点伤害。（X为你以此法交给该角色的牌数）
	状态：复制原项目并大改
]]--
XianzhouCard = sgs.CreateSkillCard{
	name = "XianzhouCard",
	skill_name = "Xianzhou",
	target_fixed = false, 
	mute = true,
	filter = function(self, targets, to_select, player)
		return #targets == 0 and to_select:objectName() ~= player:objectName()
	end,
	extra_cost = function(self, room, card_use)
		local source = card_use.from
		local target = card_use.to:first()
		local dummy = sgs.DummyCard()
		dummy:addSubcards(source:getEquips())
		local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_GIVE, source:objectName(), target:objectName(), "Xianzhou", "")
		room:obtainCard(target, dummy, reason)
		room:setPlayerMark(source, "Xianzhou", dummy:subcardsLength())
		dummy:deleteLater()
	end,
	about_to_use = function(self, room, cardUse)
		room:removePlayerMark(cardUse.from, "@handover")
		room:broadcastSkillInvoke("Xianzhou", cardUse.from)
		room:doSuperLightbox("CaiFuRen", "Xianzhou")
		self:cardOnUse(room, cardUse)
	end,
	on_effect = function(self, effect)
		local room = effect.from:getRoom()
		local source = effect.from
		local target = effect.to
		if target:isDead() then return end
		local len = source:getMark("Xianzhou")
		room:setPlayerMark(source, "Xianzhou", 0)  --AI可以通过askForPlayersChosen的参数获得卡牌数
		local victims = sgs.SPlayerList()
		for _, p in sgs.qlist(room:getOtherPlayers(target)) do
			if target:inMyAttackRange(p) then
				victims:append(p)
			end
		end
		local damaged = false
		if not victims:isEmpty() then
			local dat = sgs.QVariant()
			dat:setValue(source)
			target:setTag("XianzhouSource", dat)  --记录蔡夫人（AI）
			local prompt = (source:isWounded() and "@Xianzhou-damage" or "@Xianzhou-damage2") .. ":" .. source:objectName() .. "::" .. len
			local choices = room:askForPlayersChosen(target, victims, "Xianzhou", source:isWounded() and 0 or 1, len, prompt)
			target:removeTag("XianzhouSource")
			if choices:length() > 0 then
				damaged = true
				room:sortByActionOrder(choices)
				local damage = sgs.DamageStruct()
				damage.from = target
				damage.reason = "Xianzhou"
				for _,p in sgs.qlist(choices) do
					damage.to = p
					room:damage(damage)
				end
				return
			end
		end
		if not damaged and source:isWounded() then
			local recover = sgs.RecoverStruct()
			recover.who = target
			recover.recover = math.min(len, source:getLostHp())
			room:recover(source, recover)
		end
	end,
}
XianzhouVS = sgs.CreateZeroCardViewAsSkill{
	name = "Xianzhou",
	view_as = function(self)
		local card = XianzhouCard:clone()
		card:setShowSkill(self:objectName())
		return card
	end,
	enabled_at_play = function(self, player)
		return player:hasEquip() and player:getMark("@handover") > 0
	end,
	--[[enabled_at_response = function(self, player, pattern)
		return pattern == "@@xianzhou"
	end,]]
}
Xianzhou = sgs.CreateTriggerSkill{
	name = "Xianzhou",
	frequency = sgs.Skill_Limited,
	limit_mark = "@handover",
	view_as_skill = XianzhouVS,
}
CaiFuRen:addSkill(Xianzhou)

----------------------------------------------------------------------------------------------------

--[[ YJ 304 顾雍
	武将：GuYong
	武将名：顾雍
	体力上限：3
	武将技能：
		慎行: 出牌阶段限X次（X为你于此阶段开始时的手牌数），你可以弃置两张牌，摸一张牌。 
		秉壹: 结束阶段开始时，你可以展示所有手牌，若颜色均相同，你可以令至多X名角色各摸一张牌（X为你的手牌数） 。
				（注：可以选择0名角色）
	状态：
]]--

--------------------------------------------一将成名2015--------------------------------------------

extensionYJCM2015 = sgs.Package("YJCM2015", sgs.Package_GeneralPack)

--[[ YJ 401 曹叡
	武将：CaoRui
	武将名：曹叡
	体力上限：3
	武将技能：
		恢拓：当你受到伤害后，你可以选择一名角色，亮出牌堆顶的一张牌，若此牌为：红色，该角色回复1点体力；黑色，该角色摸X张牌（X为此次伤害的伤害数）。最后你将此牌置入弃牌堆。
		明鉴：你可以跳过出牌阶段并将所有手牌交给一名其他角色，若如此做，你结束此回合，然后该角色进行一个额外的出牌阶段。
	状态：
]]--
CaoRui = sgs.General(extensionYJCM2015, "CaoRui", "wei", 3, true)

--[[
	技能名：恢拓
	技能：Huituo_CaoRui
	描述：当你受到伤害后，你可以选择一名角色，亮出牌堆顶的一张牌，若此牌为：红色，该角色回复1点体力；黑色，该角色摸X张牌（X为此次伤害的伤害数）。最后你将此牌置入弃牌堆。
	状态：验证通过
]]--
function sgs.CreateHuituoSkill(name)
	local huituo_skill = {
		name = "Huituo_" .. name,
		can_trigger = function(self, event, room, player, data)
			if not player or player:isDead() or not player:hasSkill(self) then return false end
			return self:objectName()
		end,
		on_cost = function(self, event, room, player, data)
			local to = room:askForPlayerChosen(player, room:getAlivePlayers(), self:objectName(), "Huituo-select", true, true)
			if to then
				room:broadcastSkillInvoke(self:objectName(), player)
				local to_data = sgs.QVariant()
				to_data:setValue(to)
				player:setTag(self:objectName(), to_data)
				return true 
			end
			return false 
		end,
		on_damaged = function(self, player, damage)
			local room = player:getRoom()
			local target = player:getTag(self:objectName()):toPlayer()
			player:removeTag(self:objectName())
			local id = room:drawCard()
			local move = sgs.CardsMoveStruct()
			move.card_ids:append(id)
			move.to = player
			move.to_place = sgs.Player_PlaceTable
			move.reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_TURNOVER, player:objectName(), self:objectName(), nil)
			room:moveCardsAtomic(move, true)
			room:getThread():delay()

			local card = sgs.Sanguosha:getCard(id)
			if card:isRed() and target:isWounded() then
				local recover = sgs.RecoverStruct()
				recover.who = player
				room:recover(target, recover)
			elseif card:isBlack() and damage.damage > 0 then
				target:drawCards(damage.damage)
			end
			room:throwCard(card, sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_NATURAL_ENTER, player:objectName(), self:objectName(), ""), nil)
		end,
		on_turn_broken = function(self, function_name, event, room, player, data, ask_who)
			player:removeTag(self:objectName())
		end
	}
	return sgs.CreateMasochismSkill(huituo_skill)
end
Huituo_CaoRui = sgs.CreateHuituoSkill("CaoRui")
CaoRui:addSkill(Huituo_CaoRui)

--[[
	技能名：明鉴
	技能：Mingjian
	描述：你可以跳过出牌阶段并将所有手牌交给一名其他角色，若如此做，你结束此回合，然后该角色进行一个额外的出牌阶段。
	状态：
]]--
Mingjian = sgs.CreateTriggerSkill{
	name = "Mingjian",
	can_preshow = true,
	events = {sgs.EventPhaseChanging},
	can_trigger = function(self, event, room, player, data)
		if not player or player:isDead() or not player:hasSkill(self) then return "" end
		if data:toPhaseChange().to == sgs.Player_Play and not player:isSkipped(sgs.Player_Play) and not player:isKongcheng() then
			return self:objectName()
		end
	end,
	on_cost = function(self, event, room, player, data)
		local target = room:askForPlayerChosen(player, room:getAlivePlayers(), self:objectName(), self:objectName().."-give", true, true)
		if target then
			room:broadcastSkillInvoke(self:objectName(), player)
			player:skip(sgs.Player_Play)
			local dummy = sgs.DummyCard(player:handCards())
			local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_GIVE, player:objectName(), target:objectName(), self:objectName(), "")
			room:obtainCard(target, dummy, reason, false)
			dummy:deleteLater()
			local dat = sgs.QVariant()
			dat:setValue(target)
			player:setTag(self:objectName(), dat)
			return true
		end
		return false 
	end,
	on_effect = function(self, event, room, player, data)
		room:throwEvent(sgs.TurnBroken)
	end,
}
MingjianGive = sgs.CreateTriggerSkill{
	name = "#Mingjian-give",
	frequency = sgs.Skill_Wake,
	events = {sgs.EventPhaseStart},
	priority = -1,
	global = true,
	can_trigger = function(self, event, room, player, data)
		if player:getPhase() == sgs.Player_NotActive then
			local target = player:getTag("Mingjian"):toPlayer()
			if target and target:isAlive() then
				return self:objectName(), target  --priority=-1应该没有第二例，所以暂时可以无视掉同时机的取消按钮（2.1.0真蛋疼）
			end
		end
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		player:removeTag("Mingjian")
		return true
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		--[[local phase = sgs.PhaseList()
		phase:append(sgs.Player_Play)  --待修结算（放权……）
		ask_who:play(phase)
		return false]]
		
		
		--RoomThread::actionNormal
		local current = room:getCurrent()
		
		--ServerPlayer::play
		local phase = ask_who:getPhase()
		local thread = room:getThread()
		ask_who:setPhase(sgs.Player_Play)
		room:broadcastProperty(ask_who, "phase")
		if not thread:trigger(sgs.EventPhaseStart, room, ask_who) then
			thread:trigger(sgs.EventPhaseProceeding, room, ask_who)
		end
		thread:trigger(sgs.EventPhaseEnd, room, ask_who)
		ask_who:setPhase(phase)
		room:broadcastProperty(ask_who, "phase")
		
		--RoomThread::actionNormal
		if room:isFinished() then return false end
		room:setCurrent(current)  --转移到下家会在gamerule自动处理
	end,
}
CaoRui:addSkill(Mingjian)
CaoRui:addSkill(MingjianGive)

----------------------------------------------------------------------------------------------------

--[[ YJ 409 张嶷
	武将：ZhangNi
	武将名：张嶷
	体力上限：4
	武将技能：
		怃戎：出牌阶段限一次，你可以令一名其他角色与你同时展示一张手牌，然后若你展示的牌是【杀】且该角色展示的牌不是【闪】，你弃置此【杀】，对其造成1点伤害；若你展示的牌不是【杀】且该角色展示的牌是【闪】，你弃置你展示的牌，获得其一张牌。
		矢志：锁定技，若你的体力值为1，你的【闪】视为【杀】。
	状态：验证通过
]]--
ZhangNi = sgs.General(extensionYJCM2015, "ZhangNi", "shu", 4, true)

--[[
	技能名：怃戎
	技能：Wurong
	描述：出牌阶段限一次，你可以令一名其他角色与你同时展示一张手牌，然后若你展示的牌是【杀】且该角色展示的牌不是【闪】，你弃置此【杀】，对其造成1点伤害；若你展示的牌不是【杀】且该角色展示的牌是【闪】，你弃置你展示的牌，获得其一张牌。
	状态：验证通过
]]--
WurongCard = sgs.CreateSkillCard{
	name = "WurongCard",
	skill_name = "Wurong",
	will_throw = false,
	handling_method = sgs.Card_MethodNone,
	filter = function(self, targets, to_select, player)
		return #targets == 0 and not to_select:isKongcheng() and to_select:objectName() ~= player:objectName()
	end,
	on_effect = function(self, effect)
		local room = effect.from:getRoom()
		local c = room:askForExchange(effect.to, "Wurong", 1, 1, "@Wurong-show", "", ".|.|.|hand")
		if not c then  --临时处理AI问题
			c = effect.to:getHandcards():at(math.random(0, effect.to:getHandcards():length() - 1))
		end
		room:showCard(effect.from, self:getSubcards():first())
		room:showCard(effect.to, c:getEffectiveId())
		local card1 = sgs.Sanguosha:getCard(self:getSubcards():first())
		local card2 = sgs.Sanguosha:getCard(c:getEffectiveId())
		
		if not effect.from:canDiscard(effect.from, card1:getEffectiveId()) then return end
		if card1:isKindOf("Slash") and not card2:isKindOf("Jink") then
			local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_THROW, effect.from:objectName(), "Wurong", nil)
			room:throwCard(self, reason, effect.from)
			if effect.to:isAlive() then room:damage(sgs.DamageStruct("Wurong", effect.from, effect.to)) end
		elseif not card1:isKindOf("Slash") and card2:isKindOf("Jink") then
			local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_THROW, effect.from:objectName(), "Wurong", nil)
			room:throwCard(self, reason, effect.from)
			if effect.from:isAlive() and effect.to:isAlive() and not effect.to:isNude() then
				local card_id = room:askForCardChosen(effect.from, effect.to, "he", "Wurong")
				local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_EXTRACTION, effect.from:objectName())
				room:obtainCard(effect.from, sgs.Sanguosha:getCard(card_id), reason, false)
			end
		end
	end,
}
Wurong = sgs.CreateOneCardViewAsSkill{
	name = "Wurong",
	filter_pattern = ".|.|.|hand",
	view_as = function(self, originalCard)
		local card = WurongCard:clone()
		card:addSubcard(originalCard)
		card:setSkillName(self:objectName())
		card:setShowSkill(self:objectName())
		return card
	end,
	enabled_at_play = function(self, player)
		return not player:hasUsed("#WurongCard") and not player:isKongcheng()
	end
}
ZhangNi:addSkill(Wurong)

--[[
	技能名：矢志
	技能：Shizhi
	描述：锁定技，若你的体力值为1，你的【闪】视为【杀】。
	状态：验证通过
]]--
ShizhiFilter = sgs.CreateFilterSkill{
	name = "#Shizhi-filter",
	view_filter = function(self, card)
		local room = sgs.Sanguosha:currentRoom()
		if room then
			local id = card:getEffectiveId()
			local owner = room:getCardOwner(id)
			if owner and owner:hasShownSkill("Shizhi") and owner:getHp() == 1 then
				return card:isKindOf("Jink") and (room:getCardPlace(id) == sgs.Player_PlaceEquip or room:getCardPlace(id) == sgs.Player_PlaceHand or room:getCardPlace(id) == sgs.Player_PlaceJudge)
			end
		end
	end,
	view_as = function(self, card)
		local slash = sgs.Sanguosha:cloneCard("slash", card:getSuit(), card:getNumber())
		slash:setSkillName("Shizhi")
		local wrap = sgs.Sanguosha:getWrappedCard(card:getId())
		wrap:takeOver(slash)
		return wrap
	end
}
ShizhiVS = sgs.CreateOneCardViewAsSkill{
	name = "Shizhi",
	filter_pattern = "Jink",
	view_as = function(self, originalCard)
		local slash = sgs.Sanguosha:cloneCard("slash", originalCard:getSuit(), originalCard:getNumber())
		slash:addSubcard(originalCard:getId())
		slash:setSkillName(self:objectName())
		slash:setShowSkill(self:objectName())
		return slash
	end,
	enabled_at_play = function(self, player)
		return not player:hasShownSkill(self:objectName()) and sgs.Slash_IsAvailable(player) and player:getHp() == 1
	end,
	enabled_at_response = function(self, player, pattern)
		return not player:hasShownSkill(self:objectName()) and (pattern == "slash") and player:getHp() == 1
	end,
}
Shizhi = sgs.CreateTriggerSkill{
	name = "Shizhi",
	can_preshow = false,  --设为true则无法使用VSSkill
	events = {sgs.FinishRetrial, sgs.GeneralShown, sgs.GeneralHidden, sgs.DFDebut, sgs.EventAcquireSkill, sgs.EventLoseSkill, sgs.HpChanged, sgs.MaxHpChanged},
	--系统自动filterCards的时机：卡牌移动后（包括判定），获得/失去可见技能后，明置/暗置/移除武将牌后，变身后（changePlayerGeneral，不过仅用于变暗将）
	frequency = sgs.Skill_Compulsory,
	view_as_skill = ShizhiVS,
	on_record = function(self, event, room, player, data)  --初始化Mark（注意这里不需要一个Record技能来对付左慈，因为只有获得了这个技能以后Mark才有意义）
		if not (player and player:isAlive() and player:hasSkill(self:objectName())) and event ~= sgs.EventLoseSkill then return "" end
		if (event == sgs.GeneralShown and data:toBool() == player:inHeadSkills(self:objectName()))
			or event == sgs.DFDebut
			or (event == sgs.GeneralHidden and data:toBool() == player:inHeadSkills(self:objectName()))  --其实暗置武将牌会自动触发EventLoseSkill，为了保险
			or event == sgs.HpChanged or event == sgs.MaxHpChanged
			or (event == sgs.EventAcquireSkill and data:toString() == self:objectName())  --注意ShizhiFilter为隐藏技能，因此不会自动在这两个时机filterCards
			or (event == sgs.EventLoseSkill and data:toString() == self:objectName()) then
			
			if (event == sgs.HpChanged or event == sgs.MaxHpChanged) and not player:hasShownSkill(self:objectName()) then return end  --如果还没亮将则需要走一遍cost、effect来亮将（这种情况下skillStateBefore必定是0）
			
			local skillStateBefore = player:getMark(self:objectName()) or 0
			local skillStateAfter = (player:getHp() == 1) and 1 or 0
			if event == sgs.EventLoseSkill or event == sgs.GeneralHidden then skillStateAfter = 0 end
			room:setPlayerMark(player, self:objectName(), skillStateAfter)
			
			if event == sgs.GeneralShown or event == sgs.DFDebut or event == sgs.GeneralHidden then return end  --系统自动filterCards的情况
			if skillStateBefore ~= skillStateAfter then
				room:broadcastSkillInvoke(self:objectName(), player)
				room:filterCards(player, player:getCards("he"), true)
			end
		end
	end,
	can_trigger = function(self, event, room, player, data)
		if not player or player:isDead() or not player:hasSkill(self:objectName()) then return false end
		if player:hasShownSkill(self:objectName()) then return "" end
		if event == sgs.FinishRetrial then
			local judge = data:toJudge()
			if judge.who:objectName() == player:objectName() and judge.card:isKindOf("Jink") and player:getHp() == 1 then
				return self:objectName()
			end
		elseif event == sgs.HpChanged or event == sgs.MaxHpChanged then  --需要询问是否亮将
			local skillStateBefore = player:getMark(self:objectName()) or 0
			local skillStateAfter = (player:getHp() == 1) and 1 or 0
			return (skillStateBefore ~= skillStateAfter) and self:objectName() or ""
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		if player:askForSkillInvoke(self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), player)
			return true
		end
	end,
	on_effect = function(self, event, room, player, data)
		if event == sgs.FinishRetrial then
			local judge = data:toJudge()
			local cards = sgs.CardList()
			cards:append(judge.card)
			room:filterCards(player, cards, true)
			judge:updateResult()
			return false
		elseif event == sgs.HpChanged or event == sgs.MaxHpChanged then
			room:filterCards(player, player:getCards("he"), true)
			room:setPlayerMark(player, self:objectName(), (player:getHp() == 1) and 1 or 0)
		end
	end,
}
ZhangNi:addSkill(Shizhi)
ZhangNi:addSkill(ShizhiFilter)
sgs.insertRelatedSkills(extensionYJCM2015, "Shizhi", "#Shizhi-filter")

--------------------------------------------原创之魂2016--------------------------------------------

extensionYCZH2016 = sgs.Package("YCZH2016", sgs.Package_GeneralPack)

--[[ YC 005 刘虞
	武将：LiuYu
	武将名：刘虞
	体力上限：3
	武将技能：
		止戈：出牌阶段限一次，若你的手牌数大于体力值，你可以选择一名攻击范围内含有你的其他角色，令其选择是否使用【杀】，若其选择否且其装备区里有牌，其将装备区里的一张牌交给你。
		宗室：主将技，锁定技，你的手牌上限+X（X为现存势力数）。
		宗祚：副将技，锁定技，当你首次明置此武将牌后，你加X点体力上限，然后回复X点体力（X为与你的势力不同的势力数）；当其他角色死亡后，若没有与其势力相同的角色（包括除其外已死亡的角色），你减1点体力上限。 
	状态：
]]--

----------------------------------------------------------------------------------------------------

--[[ YC 008 张让
	武将：ZhangRang
	武将名：张让
	体力上限：3
	武将技能：
		滔乱：当你需要使用基本牌或普通锦囊牌时，你可以视为使用此牌（不能是你以此法使用过的牌），若如此做，你令一名其他角色选择一项：1. 将与此牌类别不同的一张牌交给你；2. 令你失去1点体力。
	状态：验证通过
]]--
ZhangRang = sgs.General(extensionYCZH2016, "ZhangRang", "qun", 3, true)

--[[
	技能名：滔乱
	技能：Taoluan
	描述：当你需要使用基本牌或普通锦囊牌时，你可以视为使用此牌（不能是你以此法使用过的牌），若如此做，你令一名其他角色选择一项：1. 将与此牌类别不同的一张牌交给你；2. 令你失去1点体力。
	状态：验证通过
	注：不要和风包于吉或OL张让双将！！（因为guhuo_box_allowed_elemet的问题，目前技能中是给张让专用的）
]]--
addTaoluanHistory = function(player, card)
	local pattern = card:objectName()
	local patterns = {pattern}
	if pattern == "fire_slash" or pattern == "thunder_slash" or pattern == "slash" then
		if not table.contains(patterns, "slash") then table.insert(patterns, "slash") end
		if not table.contains(patterns, "fire_slash") then table.insert(patterns, "fire_slash") end
		if not table.contains(patterns, "thunder_slash") then table.insert(patterns, "thunder_slash") end
	end
	if pattern == "nullification" or pattern == "heg_nullification" then
		if not table.contains(patterns, "nullification") then table.insert(patterns, "nullification") end
		if not table.contains(patterns, "heg_nullification") then table.insert(patterns, "heg_nullification") end
	end
	local room = player:getRoom()
	local allowed_table = player:property("guhuo_box_allowed_elemet"):toString():split("+")
	for _,pat in pairs(patterns) do
		table.removeAll(allowed_table, pat)
	end
	room:setPlayerProperty(player, "guhuo_box_allowed_elemet", sgs.QVariant(table.concat(allowed_table, "+")))
	
	local taoluan_cards = player:getTag("TaoluanCardsUsing"):toString():split("|")
	table.insert(taoluan_cards, card:toString())
	table.removeAll(taoluan_cards, "")
	player:setTag("TaoluanCardsUsing", sgs.QVariant(table.concat(taoluan_cards, "|")))
	player:setFlags("TaoluanValidated")
end
TaoluanCard = sgs.CreateSkillCard{
	name = "TaoluanCard",
	skill_name = "Taoluan",
	will_throw = false,
	filter = function(self, targets, to_select, player)
		local players = sgs.PlayerList()
		if next(targets) ~= nil then
			for i = 1 , #targets do
				players:append(targets[i])
			end
		end
		if sgs.Sanguosha:getCurrentCardUseReason() == sgs.CardUseStruct_CARD_USE_REASON_RESPONSE_USE then
            local card = nil
            if self:getUserString() and self:getUserString() ~= "" then
                card = sgs.Sanguosha:cloneCard(self:getUserString():split("+")[1])
                return card and card:targetFilter(players, to_select, player) and not player:isProhibited(to_select, card, players)
            end
        end
        local _card = sgs.Sanguosha:cloneCard(sgs.Self:getTag("Taoluan"):toString())
        if _card == nil or _card:targetFixed() then
            return false
        end
        local card = sgs.Sanguosha:cloneCard(_card)
		card:addSubcards(self:getSubcards())
        card:setCanRecast(false)
        card:deleteLater()
        return card and card:targetFilter(players, to_select, player) and not player:isProhibited(to_select, card, players) and card:isAvailable(player) and not player:isLocked(card)
	end,
	feasible = function(self, targets, player)
		local players = sgs.PlayerList()
		if next(targets) ~= nil then
			for i = 1 , #targets do
				players:append(targets[i])
			end
		end
		if sgs.Sanguosha:getCurrentCardUseReason() == sgs.CardUseStruct_CARD_USE_REASON_RESPONSE_USE then
            local card = nil
            if self:getUserString() and self:getUserString() ~= "" then
                card = sgs.Sanguosha:cloneCard(self:getUserString():split("+")[1])
                return card and card:targetsFeasible(players, player)
            end
        end
		local _card = sgs.Sanguosha:cloneCard(player:getTag("Taoluan"):toString())
        if _card == nil then
            return false
        end
		local card = sgs.Sanguosha:cloneCard(_card)
		card:addSubcards(self:getSubcards())
		local can_recast = card:canRecast()
		card:setCanRecast(false)
		card:deleteLater()
		
		if can_recast and not card:isKindOf("FightTogether") then   --知己知彼源码有bug（968行忘加rec &&）  todo：在新版本中已修复，无需单独判断
			if players:length() == 0 then return false end
		end
		return card and card:targetsFeasible(players, player) and card:isAvailable(player) and not player:isLocked(card)
    end,
	on_validate = function(self, card_use)
        local zhangrang = card_use.from
        local room = zhangrang:getRoom()
		
		local to_guhuo = self:getUserString()
        if to_guhuo == "slash" and sgs.Sanguosha:getCurrentCardUseReason() == sgs.CardUseStruct_CARD_USE_REASON_RESPONSE_USE then
			local dat = sgs.QVariant()
			dat:setValue(card_use)
			zhangrang:setTag("TaoluanSlashData", dat)  --for AI
            local guhuo_list = {}
            table.insert(guhuo_list, "slash")
            table.insert(guhuo_list, "normal_slash")
            table.insert(guhuo_list, "thunder_slash")
            table.insert(guhuo_list, "fire_slash")
            to_guhuo = room:askForChoice(zhangrang, "Taoluan_slash", table.concat(guhuo_list, "+"))
			zhangrang:removeTag("TaoluanSlashData")
            zhangrang:setTag("TaoluanSlash", sgs.QVariant(to_guhuo))  --Useless data?  (Maybe for AI)
        end
        --local card = sgs.Sanguosha:getCard(self:getSubcards():first())  --留着给OL滔乱用
        local user_str = ""
        if to_guhuo == "slash" then
            --if card:isKindOf("Slash") then
            --    user_str = card:objectName()
            --else
                user_str = "slash"
            --end
        elseif to_guhuo == "normal_slash" then
            user_str = "slash"
        else
            user_str = to_guhuo
        end
        --zhangrang:setTag("TaoluanSlash", sgs.QVariant(user_str))
		
		local use_card = sgs.Sanguosha:cloneCard(user_str)
        use_card:setSkillName("Taoluan")
        use_card:addSubcards(self:getSubcards())
        use_card:setCanRecast(false)
        use_card:setShowSkill("Taoluan")
		
		local available = true
		local tos = card_use.to
        for _, to in sgs.qlist(tos) do
            local skill = zhangrang:isProhibited(to, use_card)
            if skill then
				if skill:isVisible() then
					local msg = sgs.LogMessage()
					msg.type = "#SkillAvoid"
					msg.from = to
					msg.arg = skill:objectName()
					msg.arg2 = use_card:objectName()
					room:sendLog(msg)
					room:broadcastSkillInvoke(skill:objectName())
				end
                card_use.to:removeOne(to)
            end
			--[[if zhangrang:isProhibited(to, use_card) then
				available = false
				break
			end]]
        end
		available = available and use_card:isAvailable(zhangrang) and not zhangrang:isLocked(use_card)
		use_card:deleteLater()
		if not available then return nil end
		addTaoluanHistory(zhangrang, use_card)
        return use_card
    end,
    on_validate_in_response = function(self, zhangrang)
        local room = zhangrang:getRoom()
        local to_guhuo = ""
        if self:getUserString() == "peach+analeptic" then
			local save_cards = {}
			local allowed = zhangrang:property("guhuo_box_allowed_elemet"):toString():split("+")
			if table.contains(allowed, "peach") then table.insert(save_cards, "peach") end
			if table.contains(allowed, "analeptic") then table.insert(save_cards, "analeptic") end
            to_guhuo = room:askForChoice(zhangrang, "Taoluan_saveself", table.concat(save_cards, "+"))
            --zhangrang:setTag("BowuSaveSelf", sgs.QVariant(to_guhuo))
        elseif self:getUserString() == "slash" then
			local guhuo_list = {}
            table.insert(guhuo_list, "slash")
            table.insert(guhuo_list, "normal_slash")
            table.insert(guhuo_list, "thunder_slash")
            table.insert(guhuo_list, "fire_slash")
            to_guhuo = room:askForChoice(zhangrang, "Taoluan_slash", table.concat(guhuo_list, "+"))
            zhangrang:setTag("TaoluanSlash", sgs.QVariant(to_guhuo))  --Useless data?  (Maybe for AI)
        elseif self:getUserString() == "nullification" then
			to_guhuo = room:askForChoice(zhangrang, "Taoluan_nullification", "nullification+heg_nullification")
        else
            to_guhuo = self:getUserString()
        end
        --local card = sgs.Sanguosha:getCard(self:getSubcards():first())
        local user_str = ""
        if to_guhuo == "slash" then
            --if card:isKindOf("Slash") then
            --    user_str = card:objectName()
            --else
                user_str = "slash"
            --end
        elseif to_guhuo == "normal_slash" then
            user_str = "slash"
        else
            user_str = to_guhuo
        end
        local use_card = sgs.Sanguosha:cloneCard(user_str)
        use_card:setSkillName("Taoluan")
        use_card:addSubcards(self:getSubcards())
        use_card:setCanRecast(false)
        use_card:setShowSkill("Taoluan")
		use_card:deleteLater()
		if zhangrang:isLocked(use_card) then return nil end
		addTaoluanHistory(zhangrang, use_card)
        return use_card
    end
}
TaoluanVS = sgs.CreateZeroCardViewAsSkill{   
	name = "Taoluan",
	view_as = function(self)
		if sgs.Sanguosha:getCurrentCardUseReason() == sgs.CardUseStruct_CARD_USE_REASON_RESPONSE_USE then
            local card = TaoluanCard:clone()
            card:setUserString(sgs.Sanguosha:getCurrentCardUsePattern())
            local realcard = sgs.Sanguosha:cloneCard(sgs.Sanguosha:getCurrentCardUsePattern():split(":")[1], sgs.Card_SuitToBeDecided, -1)
			card:setTargetFixed(realcard:targetFixed())
            return card
        end
		if sgs.Sanguosha:getCurrentCardUseReason() ~= sgs.CardUseStruct_CARD_USE_REASON_PLAY then return nil end
		local c = sgs.Self:getTag(self:objectName()):toString()
		if c ~= "" then
			local card = TaoluanCard:clone()
			card:setUserString(c)
			local realcard = sgs.Sanguosha:cloneCard(c, sgs.Card_SuitToBeDecided, -1)
			card:setTargetFixed(realcard:targetFixed())
			return card
		end
		return nil
	end,
	enabled_at_play = function(self, player)
		local allowed = player:property("guhuo_box_allowed_elemet"):toString():split("+")
		local choices = {}
		for _, name in ipairs(allowed) do
			if name == "" then continue end
			local card = sgs.Sanguosha:cloneCard(name, sgs.Card_NoSuit, 0)
			if card:isAvailable(player) then
				return true
			end
		end
		return false
	end,
	enabled_at_response = function(self, player, pattern)
		if (sgs.Sanguosha:getCurrentCardUseReason() ~= sgs.CardUseStruct_CARD_USE_REASON_RESPONSE_USE) then return false end
        if string.sub(pattern, 1, 1) == "." or string.sub(pattern, 1, 1) == "@" then
            return false
        end
        if (pattern == "peach") and (player:getMark("Global_PreventPeach") > 0) then return false end
        if string.find(pattern, "[%u%d]") then return false end--这是个极其肮脏的黑客！！ 因此我们需要去阻止基本牌模式
		local patterns = pattern:split("+")
		local allowed = player:property("guhuo_box_allowed_elemet"):toString():split("+")
		for _,pat in pairs(patterns) do
			if table.contains(allowed, pat) then
				return true
			end
		end
		return false
    end,
	enabled_at_nullification = function(self, player)
		local allowed = player:property("guhuo_box_allowed_elemet"):toString():split("+")
		return table.contains(allowed, "nullification")
    end
}
Taoluan = sgs.CreateTriggerSkill{
	name = "Taoluan",
	can_preshow = false,
	events = {sgs.GameStart, sgs.DFDebut, sgs.EventAcquireSkill, sgs.EventLoseSkill, sgs.PreCardUsed, sgs.CardResponded, sgs.ChoiceMade},
	guhuo_type = "bt",
	priority = 12,  --为了迁就PreCardUsed和CardResponded（由于狂才的priority是11，而滔乱的记录牌必须在狂才删除牌之前），其他时机影响不大
	view_as_skill = TaoluanVS,
	on_record = function(self, event, room, player, data)  --这段代码需要确认有这个技能才能执行，因此不需要global
		if (event == sgs.EventAcquireSkill and data:toString() == self:objectName()) or (event == sgs.GeneralShown and data:toBool() == player:inHeadSkills(self)) then  --GeneralShown为变副将（不会触发GameStart，还好会触发GeneralShown）
			if not (player and player:isAlive() and player:hasSkill(self:objectName())) then return "" end
			if player:getMark("TaoluanInitialized") > 0 then return "" end
			local allowed_table = fetchCards("BasicCard,NDTrick", nil, player)
			if next(allowed_table) then
				room:setPlayerProperty(player, "guhuo_box_allowed_elemet", sgs.QVariant(table.concat(allowed_table, "+")))
			end
			room:setPlayerMark(player, "TaoluanInitialized", 1)
		elseif (event == sgs.EventLoseSkill and data:toString() == self:objectName()) and not player:ownSkill(self:objectName()) then
			room:setPlayerProperty(player, "guhuo_box_allowed_elemet", sgs.QVariant())  --特别注意：暗置会触发EventLoseSkill，↑所以需要用ownSkill区分
			room:setPlayerMark(player, "TaoluanInitialized", 0)
			
		elseif event == sgs.ChoiceMade then  --单独处理朱雀羽扇转换的杀（从validate到实际使用牌的过程中，只有朱雀羽扇、狂才能将使用的牌改变）
			if player:hasFlag("TaoluanValidated") then				--注：OL滔乱不会有这个问题，因为是转化而不是视为
				local data_str = data:toString():split(":")
				if (#data_str == 3) and (data_str[1] == "skillInvoke") and (data_str[2] == "Fan") and (data_str[3] == "yes") then
					room:setPlayerFlag(player, "TaoluanFanInvoked")
				end
			end
		elseif event == sgs.PreCardUsed or event == sgs.CardResponded then
			player:setFlags("-TaoluanValidated")  --保证on_validate，on_validate_in_response的Flag必定会在这里清除
			if not player:hasFlag("TaoluanFanInvoked") then return end
			player:setFlags("-TaoluanFanInvoked")
			local card
			if event == sgs.PreCardUsed then
				card = data:toCardUse().card
			else
				local response = data:toCardResponse()
				if response.m_isUse then
					card = response.m_card
				end
			end
			if card and card:getHandlingMethod() == sgs.Card_MethodUse then
				if card:isKindOf("FireSlash") and card:getSkillName() == "Fan" then
					local taoluan_cards = player:getTag("TaoluanCardsUsing"):toString():split("|")
					local use_card = sgs.Sanguosha:cloneCard("slash")
					use_card:setSkillName("Taoluan")
					use_card:setShowSkill("Taoluan")
					if table.contains(taoluan_cards, use_card:toString()) then
						table.removeOne(taoluan_cards, use_card:toString())
						table.insert(taoluan_cards, card:toString())
						table.removeAll(taoluan_cards, "")
						player:setTag("TaoluanCardsUsing", sgs.QVariant(table.concat(taoluan_cards, "|")))
						room:broadcastSkillInvoke(self:objectName(), player)
						if player:ownSkill(self:objectName()) and not player:hasShownSkill(self:objectName()) then
							player:showGeneral(player:inHeadSkills(self:objectName()))
						end
					end
				end
			end
		end
	end,
	can_trigger = function(self, event, room, player, data)  --GameStart必须放到can_trigger，变更副将和飞龙夺凤时会调用这个函数【但是实际上没用，hasSkill】
		if ((event == sgs.GameStart) or (event == sgs.DFDebut)) then
			if not (player and player:isAlive() and player:hasSkill(self:objectName())) then return "" end
			if player:getMark("TaoluanInitialized") > 0 then return "" end
			local allowed_table = fetchCards("BasicCard,NDTrick", nil, player)
			if next(allowed_table) then
				room:setPlayerProperty(player, "guhuo_box_allowed_elemet", sgs.QVariant(table.concat(allowed_table, "+")))
			end
			room:setPlayerMark(player, "TaoluanInitialized", 1)
		end
		return ""
	end,
}
TaoluanAsk = sgs.CreateTriggerSkill{
	name = "#Taoluan-ask",
	events = {sgs.CardFinished},
	frequency = sgs.Skill_Compulsory,
	can_trigger = function(self, event, room, player, data)
		if event == sgs.CardFinished then
			local use = data:toCardUse()
			if not use.card or (use.card:getTypeId() == sgs.Card_TypeSkill) then return "" end
			for _,zhangrang in sgs.qlist(room:getAllPlayers()) do  --考虑到可能改变了使用者
				local taoluan_cards = zhangrang:getTag("TaoluanCardsUsing"):toString():split("|")
				if table.contains(taoluan_cards, use.card:toString()) then
					return self:objectName(), zhangrang
				end
			end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		local use = data:toCardUse()
		local types = {"BasicCard", "TrickCard", "EquipCard"}
		table.removeOne(types, types[use.card:getTypeId()])
		local _type = table.concat(types, ",")
		ask_who:setTag("TaoluanType", sgs.QVariant(_type))
		local target = room:askForPlayerChosen(ask_who, room:getOtherPlayers(ask_who), "Taoluan", "@Taoluan-ask:" .. use.card:objectName())
		if target then
			local msg = sgs.LogMessage()
			msg.type, msg.from, msg.arg = "#TaoluanAsk", ask_who, "Taoluan"
			msg.to:append(target)
			room:sendLog(msg)
			local dat = sgs.QVariant()
			dat:setValue(target)
			ask_who:setTag("TaoluanTarget", dat)
			return true
		end
		ask_who:removeTag("TaoluanType")
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		local use = data:toCardUse()
		local target = ask_who:getTag("TaoluanTarget"):toPlayer()
		ask_who:removeTag("TaoluanTarget")
		local _type = ask_who:getTag("TaoluanType"):toString()
		ask_who:removeTag("TaoluanType")
		if not target then return end
		local card
		if not target:isNude() then
			card = room:askForCard(target, _type, "@Taoluan-give:" .. ask_who:objectName() .. "::" .. _type:split(",")[1] .. ":" .. _type:split(",")[2], data, sgs.Card_MethodNone, ask_who)
		end
		if card then
			local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_GIVE, target:objectName(), ask_who:objectName(), "Taoluan", "")
			room:obtainCard(ask_who, card, reason, true)
		else
			room:loseHp(ask_who)
			--room:addPlayerMark(ask_who, "TaoluanProhibited")
		end
	end,
	on_turn_broken = function(self, function_name, event, room, player, data, ask_who)
		ask_who:removeTag("TaoluanType")
		ask_who:removeTag("TaoluanTarget")
	end
}
TaoluanClear = sgs.CreateTriggerSkill{
	name = "#Taoluan-clear",
	events = {sgs.CardFinished},
	priority = 1,
	global = true,
	on_record = function(self, event, room, player, data)
		local use = data:toCardUse()
		if not use.card or (use.card:getTypeId() == sgs.Card_TypeSkill) then return end
		for _,zhangrang in sgs.qlist(room:getAllPlayers()) do
			local taoluan_cards = zhangrang:getTag("TaoluanCardsUsing"):toString():split("|")
			if table.contains(taoluan_cards, use.card:toString()) then
				table.removeAll(taoluan_cards, use.card:toString())
				if next(taoluan_cards) ~= nil then
					zhangrang:setTag("TaoluanCardsUsing", sgs.QVariant(table.concat(taoluan_cards, "|")))
				else
					zhangrang:removeTag("TaoluanCardsUsing")
				end
			end
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
ZhangRang:addSkill(Taoluan)
ZhangRang:addSkill(TaoluanAsk)
ZhangRang:addSkill(TaoluanClear)
sgs.insertRelatedSkills(extensionYCZH2016, "Taoluan", "#Taoluan-ask", "#Taoluan-clear")

-------------------------------------------------SP-------------------------------------------------

extensionSP = sgs.Package("SPGenerals", sgs.Package_GeneralPack)

--[[ SP 017 灵雎
	武将：LingJu
	武将名：灵雎
	体力上限：3
	武将技能：
		竭缘：当你对其他角色造成伤害时，若其体力值不小于你，你可以弃置一张黑色手牌，令此伤害+1；当你受到其他角色造成的伤害时，若其体力值不小于你，你可以弃置一张红色手牌，令此伤害-1。
		焚心：限定技，当你杀死一名与你势力不同的角色检验胜利条件之前，你可以与该角色交换势力。
	状态：
]]--

----------------------------------------------------------------------------------------------------

--[[ SP 027 诸葛瑾
	武将：ZhuGeJin
	武将名：诸葛瑾
	体力上限：3
	武将技能：
		弘援：摸牌阶段，你可以少摸一张牌，令与你势力相同的所有其他角色各摸一张牌。 
		缓释：当与你势力相同的角色的判定牌生效前，你可以打出一张牌代替之。 
		明哲：当你于回合外使用或打出红色牌时，或于回合外因弃置而失去一张红色牌后，你可以摸一张牌。 
	状态：
]]--

----------------------------------------------------------------------------------------------------

--[[ SP 028 星彩
	武将：XingCai
	武将名：星彩
	体力上限：3
	武将技能：
		甚贤：你的回合外，当其他角色因弃置而失去基本牌后，你可以摸一张牌。
		枪舞：出牌阶段限一次，你可以进行判定，然后本回合，你使用点数小于判定结果的【杀】无距离限制，你使用点数大于判定结果的【杀】不计入次数限制。
	状态：复制原项目
]]--
XingCai = sgs.General(extensionSP, "XingCai", "shu", 3, false)
XingCai:addCompanion("liushan")

--[[
	技能名：甚贤
	技能：Shenxian
	描述：你的回合外，当其他角色因弃置而失去基本牌后，你可以摸一张牌。
	状态：复制原项目并大改
]]--
Shenxian = sgs.CreateTriggerSkill{
	--[[
	借用这个技能，来说一下对于延时类卡牌移动技能的通用写法。
	这类技能的最主要特点：在某个时机判断是否能发动技能，然后在之后某个时机延时执行效果
	典型例子包括：落英、甚贤、纵玄、礼让
	（落英纵玄礼让是因为弃牌分两步，需要在第一步（处理区）判断牌是否属于某一角色，然后在第二步判断牌是否进了弃牌堆(此时判断不出from_places)；
	  甚贤是因为需要在失去牌前判断此牌是否为基本牌，然后在失去牌后发动技能(此时武神已经失效)）
	源码中的屯田等技能严格来说也都算（虽然postpone原因存疑），但是毕竟改不了屯田源码嘛……
	可以即时发动的技能（如清俭）不包括在内。
	
	通过上面的描述可以看出，处理这类技能，最让人头疼的就是插入结算——记录时机与效果时机之间插一大堆东西，最坑爹的是插一个新的卡牌移动！
	（例：邓艾的梅花牌被弃置(落英记录时机1)，发动屯田，判定牌为梅花(落英记录时机2)，
		然后梅花判定牌进入弃牌堆(落英发动时机2)，然后原本梅花牌进入弃牌堆(落英发动时机1)
	再例：一名角色的基本牌被弃置(甚贤记录时机1)，15周泰弃置一张基本牌发动奋激(甚贤记录时机2)，
		周泰失去此基本牌(甚贤发动时机2)，然后原角色失去此基本牌(甚贤发动时机1)）
	这还不是最可怕的，可怕的是如果上面两个例子的记录时机2都是不满足发动条件的（比如判定牌非梅花、弃置非基本牌）。
	真的是横也不是竖也不是，原版代码手册的落英也无法完美解决。
	
	To make things worse，国战里还有对于hasSkill的判断问题——没亮将时是可以通过切换预亮状态而直接调整hasSkill的。
	想象一下上面两个例子，假如记录时机1预亮了，记录时机2取消预亮，发动时机2再预亮发动……
	因此直接导致记录时机需要对所有角色发动，不管有没有技能，hasSkill的判断只能放到发动时机。然后在发动时机，如果不满足发动条件或者没有发动，再删除记录。
	话是说得简单，但是没有什么好办法在发动时机判断到底能不能发动，因为这是记录时机该做的事情……
	我曾经写过的一版甚贤，就出现了在发动时机2甚贤摸牌的CardsMoveOneTime直接把记录时机1的记录清掉了的情况，因为没有找到与此摸牌对应的记录。
	
	因此，我们只剩下了一个思路：借用堆栈思想，不管白猫黑猫通通扔进栈里去。
	任何一个（满足条件A的）CardsMove，在对应的记录时机都要记录下来（同时记录是否满足技能发动条件，如梅花和基本牌），进入一个堆栈；
		（即使不满足技能发动条件，也要进入堆栈！！这是成功的关键）
	然后在任何一个（满足条件B的）CardsMove的发动时机，都要调用堆栈顶端的记录。
	由堆栈的实现原理，这个记录一定是在上一个记录时机的记录。然后处理这个记录，让记录出栈，发动技能就行了。
	
	然而“出栈”也不是简简单单一句话就能实现的，实测结果，唯一能保证完美出栈的方法：放到一个priority不同的技能，保证比发动时机的priority晚。
		（因为不能放到can_trigger，会导致在多次调用can_trigger的过程中反复出栈，抹掉栈里的其他信息——因为即使你发动完了还会再can_trigger一次。
		但也不能放在on_record和on_cost，因为如果有多个可以发动的技能，而你选择点击取消，那么on_cost不会执行。）
	实际应用中，建议将条件A入栈和条件B出栈写到同一个Record技能，priority设为1。（入栈priority没啥要紧的，但是一般1更合适，避免在2时发生了其他事件影响记录）
	另外，考虑到这样可能出现栈顶元素被判断了多次can_trigger的情况，需要加个Tag防止触发多余的can_trigger，在之后出栈时清除。
	
	★上文中的条件A和条件B由技能而定，但需要满足：任何一个满足条件A的记录时机，一定会触发一个满足条件B的发动时机；
												而任何一个满足条件B的发动时机，一定是由一个满足条件A的记录时机引发的。
	也就是说，不能同时有有A→B、A→C、A→∅，也不能同时有A→B、D→B、∅→B。
	道理很简单，有A→C的话，你无法确保下一次B读取的是它原本对应的A，而不是走向了C的这个A（A→(A→C)→B）。
	而有D→B的话，在此次B就会将上次A的记录出栈（A→(D→B)→B）。
	所以说，条件A和条件B越具体越好，因为你永远不知道中间那些奇葩的插入结算是什么样子。
	当然，你也要保证这个CardsMoveStruct能同时满足A和B，而不是在中间因为各种各样的变动就满足不了B啥的。
	（所以A和B中最好不要加入对card_ids的判断，因为它太容易改动了，清俭章武啥的）
	（因此落英甚贤也不要只记录梅花基本，更不要没有梅花基本就不入栈！同样是捡垃圾问题，在A有梅花基本你记下来了，到了B梅花在card_ids消失了，所以不出栈了？）
	
	条件A和条件B不一定非得是BeforeCardsMove和CardsMoveOneTime的关系，也不一定都是一个CardsMoveStruct。
	对于甚贤这样的来说是的，因为它就是对同一个Struct的判断，只是时机变了一下。
	而对落英这样的则不是，它需要判断的from_places完全可以在CardsMoveOneTime做到，所以两个时机都是CardsMoveOneTime。
	（此时为了确保B一定是A引发的，需要在B判断是否来自PlaceTable）
	
	这个体系还有一个问题，非常非常怕在BeforeCardsMove和CardsMoveOneTime返回true。
	原因是，这种情况下你就没法确保A→B而不是A→∅了。
	幸好现在还没有这种变态技能（FakeMoveSkill除外，但那是priority=10），这也告诉我们，珍爱生命远离return true。
	（挽危应该是possible candidate吧……todo：验证）
	同样的，在置入弃牌堆后也不要随便去改move.card_ids。（在此狠狠地批判一下代码手册的落英，人家礼让都没清ids）
	]]
	name = "Shenxian",
	can_preshow = true,
	events = {sgs.CardsMoveOneTime},
	frequency = sgs.Skill_Frequent,
 	can_trigger = function(self, event, room, player, data)
		if event == sgs.CardsMoveOneTime then
			if not player or player:isDead() then return "" end
			local move = data:toMoveOneTime()
			if player:getPhase() == sgs.Player_NotActive and move.from and move.from:objectName() ~= player:objectName()
				and (move.from_places:contains(sgs.Player_PlaceHand) or move.from_places:contains(sgs.Player_PlaceEquip))
				and (bit32.band(move.reason.m_reason, sgs.CardMoveReason_S_MASK_BASIC_REASON)) == sgs.CardMoveReason_S_REASON_DISCARD then  --条件B
				local ShenxianStack_str = player:getTag("ShenxianStack"):toString()
				if ShenxianStack_str == "" then return end
				local ShenxianStack = ShenxianStack_str:split("|")
				
				if player:hasSkill(self) and player:getTag("ShenxianPopIndex"):toInt() ~= #ShenxianStack then
					local ShenxianOneTime_str = ShenxianStack[#ShenxianStack]
					if ShenxianOneTime_str ~= "-1" then return self:objectName() end
				end
			end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		local ShenxianStack_str = player:getTag("ShenxianStack"):toString()
		local ShenxianStack = ShenxianStack_str:split("|")
		player:setTag("ShenxianPopIndex", sgs.QVariant(#ShenxianStack))  --防止栈顶元素触发多次can_trigger
		
		if player:askForSkillInvoke(self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), player)
			return true 
		end
		return false
	end,
	on_effect = function(self, event, room, player, data)
		player:drawCards(1, self:objectName())
	end,
}
ShenxianRecord = sgs.CreateTriggerSkill{
	name = "#Shenxian-record",
	events = {sgs.BeforeCardsMove, sgs.CardsMoveOneTime},
	priority = 1,
	global = true,
 	on_record = function(self, event, room, player, data)
		if event == sgs.BeforeCardsMove then  --记录弃牌前的信息（参见诸葛瑾小乔案例）
			if not (player and player:isAlive()) then return end  --作为一个RecordSkill，不应该加入hasSkill的判断
			
			local move = data:toMoveOneTime()
			if player:getPhase() == sgs.Player_NotActive and move.from and move.from:objectName() ~= player:objectName()
				and (move.from_places:contains(sgs.Player_PlaceHand) or move.from_places:contains(sgs.Player_PlaceEquip))
				and (bit32.band(move.reason.m_reason, sgs.CardMoveReason_S_MASK_BASIC_REASON)) == sgs.CardMoveReason_S_REASON_DISCARD then  --条件A
				local card_ids = {-1}  --占位用，用来区分空栈和有一个空元素的栈
				for i, id in sgs.qlist(move.card_ids) do
					if sgs.Sanguosha:getCard(id):getTypeId() == sgs.Card_TypeBasic
						and (move.from_places:at(i) == sgs.Player_PlaceHand or move.from_places:at(i) == sgs.Player_PlaceEquip) then
						table.insert(card_ids, id)
					end
				end
				
				--必须入栈，即使card_ids为空
				local ShenxianStack_str = player:getTag("ShenxianStack"):toString()
				local ShenxianStack = ShenxianStack_str:split("|")
				table.removeAll(ShenxianStack, "")
				table.insert(ShenxianStack, table.concat(card_ids, "+"))  --堆栈，记录可以触发技能的甚贤牌
				player:setTag("ShenxianStack", sgs.QVariant(table.concat(ShenxianStack, "|")))
			end
		elseif event == sgs.CardsMoveOneTime then  --出栈
			if not player or player:isDead() then return false end
			local move = data:toMoveOneTime()
			if player:getPhase() == sgs.Player_NotActive and move.from and move.from:objectName() ~= player:objectName()
				and (move.from_places:contains(sgs.Player_PlaceHand) or move.from_places:contains(sgs.Player_PlaceEquip))
				and (bit32.band(move.reason.m_reason, sgs.CardMoveReason_S_MASK_BASIC_REASON)) == sgs.CardMoveReason_S_REASON_DISCARD then  --条件B
				local ShenxianStack_str = player:getTag("ShenxianStack"):toString()
				if ShenxianStack_str == "" then return end
				local ShenxianStack = ShenxianStack_str:split("|")
				
				--注意只有满足条件B才能出栈
				table.remove(ShenxianStack, #ShenxianStack)
				if next(ShenxianStack) then player:setTag("ShenxianStack", sgs.QVariant(table.concat(ShenxianStack, "|")))
				else player:removeTag("ShenxianStack") end
				player:removeTag("ShenxianPopIndex")
			end
		end
	end,
 	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
XingCai:addSkill(Shenxian)
XingCai:addSkill(ShenxianRecord)
sgs.insertRelatedSkills(extensionSP, "Shenxian", "#Shenxian-record")

--[[
	技能名：枪舞
	技能：Qiangwu
	描述：出牌阶段限一次，你可以进行判定，然后本回合，你使用点数小于判定结果的【杀】无距离限制，你使用点数大于判定结果的【杀】不计入次数限制。
	状态：复制原项目并调整（因为有OL星彩）
]]--
function sgs.CreateQiangwuCard(name)
	local qiangwu_card = {
		name = "Qiangwu" .. name .. "Card",
		skill_name = "Qiangwu_" .. name,
		target_fixed = true,
		mute = true,
		on_use = function(self, room, source)
			room:broadcastSkillInvoke("Qiangwu_" .. name, 2, source)
			local judge = sgs.JudgeStruct()
			judge.pattern = "."
			judge.who = source
			judge.reason = "Qiangwu_" .. name
			judge.play_animation = false
			room:judge(judge)

			local num = tonumber(judge.pattern)
			if num then
				if source:getMark("QiangwuMin_" .. name) == 0 or source:getMark("QiangwuMin_" .. name) > num then
					room:setPlayerMark(source, "QiangwuMin_" .. name, num)
				end
				if source:getMark("QiangwuMax_" .. name) == 0 or source:getMark("QiangwuMax_" .. name) < num then
					room:setPlayerMark(source, "QiangwuMax_" .. name, num)
				end
			end
		end,
	}
	return sgs.CreateSkillCard(qiangwu_card)
end
QiangwuCard_XingCai = sgs.CreateQiangwuCard("XingCai")
function sgs.CreateQiangwuVSSkill(name, skillcard)
	local qiangwu_vs_skill = {
		name = "Qiangwu_" .. name,
		enabled_at_play = function(self, player)
			return not player:hasUsed("#" .. skillcard:objectName())
		end,
		view_as = function(self, cards)
			local card = skillcard:clone()
			card:setShowSkill(self:objectName())
			return card
		end,
	}
	return sgs.CreateZeroCardViewAsSkill(qiangwu_vs_skill)
end
QiangwuVS_XingCai = sgs.CreateQiangwuVSSkill("XingCai", QiangwuCard_XingCai)
function sgs.CreateQiangwuSkill(name, vs_skill)
	local qiangwu_skill = {
		name = "Qiangwu_" .. name,
		can_preshow = false,
		events = {sgs.FinishJudge, sgs.PreCardUsed},
		view_as_skill = vs_skill,
		on_record = function(self, event, room, player, data)  --这些代码需要调用视为技后才能执行，因此不需要global
			if event == sgs.FinishJudge then
				local judge = data:toJudge()
				if judge.reason == self:objectName() then
					judge.pattern = tostring(judge.card:getNumber())
				end
			elseif event == sgs.PreCardUsed then
				local use = data:toCardUse()
				if use.card:isKindOf("Slash") and (player:getMark("QiangwuMin_" .. name) > 0)
					and not (use.card:isVirtualCard() and (use.card:subcardsLength() ~= 1))
					and use.card:getNumber() > player:getMark("QiangwuMin_" .. name) and use.m_addHistory then
					room:broadcastSkillInvoke(self:objectName(), 1, player)
					room:notifySkillInvoked(player, self:objectName())
					room:addPlayerHistory(player, use.card:getClassName(), -1)
					use.m_addHistory = false
					data:setValue(use)
				end
			end
		end,
		can_trigger = function(self, event, room, player, data)	
			return ""
		end
	}
	return sgs.CreateTriggerSkill(qiangwu_skill)
end
Qiangwu_XingCai = sgs.CreateQiangwuSkill("XingCai", QiangwuVS_XingCai)
function sgs.CreateQiangwuClearSkill(name)
	local qiangwu_clear_skill = {
		name = "#Qiangwu-clear_" .. name,
		events = {sgs.EventPhaseStart},
		priority = 8,
		global = true,
		on_record = function(self, event, room, player, data)	
			if player:getPhase() == sgs.Player_NotActive then
				if player:getMark("QiangwuMin_" .. name) > 0 then
					room:setPlayerMark(player, "QiangwuMin_" .. name, 0)
				end
				if player:getMark("QiangwuMax_" .. name) > 0 then
					room:setPlayerMark(player, "QiangwuMax_" .. name, 0)
				end
			end
		end,
		can_trigger = function(self, event, room, player, data)	
			return ""
		end
	}
	return sgs.CreateTriggerSkill(qiangwu_clear_skill)
end
QiangwuClear_XingCai = sgs.CreateQiangwuClearSkill("XingCai")
function sgs.CreateQiangwuTarSkill(name)
	local qiangwu_tar_skill = {
		name = "#Qiangwu-target_" .. name,
		pattern = "Slash",
		distance_limit_func = function(self, from, card)
			if card:isVirtualCard() and card:subcardsLength() ~= 1 then return 0 end
			if card:getNumber() < from:getMark("QiangwuMax_" .. name) then return 1000
			else return 0 end
		end,
	}
	return sgs.CreateTargetModSkill(qiangwu_tar_skill)
end
QiangwuTar_XingCai = sgs.CreateQiangwuTarSkill("XingCai")
XingCai:addSkill(Qiangwu_XingCai)
XingCai:addSkill(QiangwuClear_XingCai)
XingCai:addSkill(QiangwuTar_XingCai)
sgs.insertRelatedSkills(extensionSP, "Qiangwu_XingCai", "#Qiangwu-clear_XingCai", "#Qiangwu-target_XingCai")

----------------------------------------------------------------------------------------------------

--[[ SP 030 祖茂
	武将：ZuMao
	武将名：祖茂
	体力上限：4
	武将技能：
		引兵：结束阶段开始时，你可以将至少一张非基本牌置于武将牌上；当你受到【杀】或【决斗】的伤害后，你移去一张“引兵”牌。
		绝地：准备阶段开始时，若你有“引兵”牌，你可以选择一项：1. 移去“引兵”牌，然后摸等量的牌；2. 令一名体力值不大于你且已受伤的其他角色回复1点体力，然后其获得“引兵”牌。
	状态：复制原项目并调整
]]--
ZuMao = sgs.General(extensionSP, "ZuMao", "wu", 4, true)
ZuMao:addCompanion("sunjian")

--[[
	技能名：引兵
	技能：Yinbing_ZuMao
	描述：结束阶段开始时，你可以将至少一张非基本牌置于武将牌上；当你受到【杀】或【决斗】的伤害后，你移去一张“引兵”牌。
	状态：复制原项目并调整
]]--
function sgs.CreateYinbingSkill(name)
	local yinbing_skill = {
		name = "Yinbing_" .. name,
		can_preshow = true,
		can_trigger = function(self, event, room, player, data)
			if not player or player:isDead() or not player:hasSkill(self) then return false end
			if player:getPhase() == sgs.Player_Finish then
				return self:objectName()
			end
			return ""
		end,
		on_cost = function(self, event, room, player, data)
			local exc_card = room:askForExchange(player, self:objectName(), 999, 0, "@Yinbing", "", "^BasicCard")
			if exc_card then
				local ids = {}
				for _,id in sgs.qlist(exc_card:getSubcards()) do
					table.insert(ids, id)
				end
				player:setTag("Yinbing" .. name .. "Cards", sgs.QVariant(table.concat(ids, "+")))
				local msg = sgs.LogMessage()
				msg.type, msg.from, msg.arg = "#InvokeSkill", player, self:objectName()
				room:sendLog(msg)
				room:broadcastSkillInvoke(self:objectName(), player)
				return true
			end
			return false
		end,
		on_phasechange = function(self, player)
			local ids_str = player:getTag("Yinbing" .. name .. "Cards"):toString():split("+")
			player:removeTag("Yinbing" .. name .. "Cards")
			local ids = sgs.IntList()
			for _,id_str in ipairs(ids_str) do
				if id_str ~= "" then ids:append(tonumber(id_str)) end
			end
			player:addToPile("Yinbing_" .. name, ids)
		end,
		on_turn_broken = function(self, function_name, event, room, player, data, ask_who)
			player:removeTag("Yinbing" .. name .. "Cards")
		end
	}
	return sgs.CreatePhaseChangeSkill(yinbing_skill)
end
function sgs.CreateYinbingThrowSkill(name)
	local yinbing_throw_skill = {
		name = "#Yinbing-throw_" .. name,
		events = {sgs.Damaged, sgs.EventLoseSkill},
		frequency = sgs.Skill_Compulsory,
		on_record = function(self, event, room, player, data)
			if event == sgs.EventLoseSkill and data:toString() == "Yinbing_" .. name then
				player:clearOnePrivatePile("Yinbing_" .. name)
			end
		end,
		can_trigger = function(self, event, room, player, data)
			if not player or player:isDead() or not player:hasSkill(self) then return false end
			if event == sgs.Damaged then
				local damage = data:toDamage()
				local card = damage.card
				if card and (card:isKindOf("Slash") or card:isKindOf("Duel")) then
					if player:getPile("Yinbing_" .. name):length() > 0 then
						return self:objectName()
					end
				end
			end
			return ""
		end,
		on_cost = function(self, event, room, player, data)
			local isComp = player:hasShownSkill(self)
			local exc_card = room:askForExchange(player, "Yinbing_" .. name, 1, isComp and 1 or 0, isComp and "@Yinbing-throw" or "@Yinbing-throw-noncomp", "Yinbing_" .. name)
			local card_id
			if exc_card then
				card_id = exc_card:getSubcards():first()
			elseif isComp then  --临时处理AI问题
				card_id = player:getPile("Yinbing_" .. name):at(math.random(0, player:getPile("Yinbing_" .. name):length() - 1))
			end
			if card_id then
				player:setTag("Yinbing" .. name .. "ThrowId", sgs.QVariant(card_id))
				player:showGeneral(player:inHeadSkills("Yinbing_" .. name))
				return true
			end
			return false
		end,
		on_effect = function(self, event, room, player, data)
			room:sendCompulsoryTriggerLog(player, "Yinbing_" .. name, true)
			local id = player:getTag("Yinbing" .. name .. "ThrowId"):toInt()
			player:removeTag("Yinbing" .. name .. "ThrowId")
			if not id or id < 0 then return end
			local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_REMOVE_FROM_PILE, "", "Yinbing_" .. name, "")
			room:throwCard(sgs.Sanguosha:getCard(id), reason, nil)
		end,
		on_turn_broken = function(self, function_name, event, room, player, data, ask_who)
			player:removeTag("Yinbing" .. name .. "ThrowId")
		end
	}
	return sgs.CreateTriggerSkill(yinbing_throw_skill)
end
Yinbing_ZuMao = sgs.CreateYinbingSkill("ZuMao")
YinbingThrow_ZuMao = sgs.CreateYinbingThrowSkill("ZuMao")
ZuMao:addSkill(Yinbing_ZuMao)
ZuMao:addSkill(YinbingThrow_ZuMao)
sgs.insertRelatedSkills(extensionSP, "Yinbing_ZuMao", "#Yinbing-throw_ZuMao")

--[[
	技能名：绝地
	技能：Juedi
	描述：准备阶段开始时，若你有“引兵”牌，你可以选择一项：1. 移去“引兵”牌，然后摸等量的牌；2. 令一名体力值不大于你且已受伤的其他角色回复1点体力，然后其获得“引兵”牌。
	状态：复制原项目并调整
]]--
Juedi = sgs.CreatePhaseChangeSkill{
	name = "Juedi",
	can_preshow = false,
	can_trigger = function(self, event, room, player, data)
		if not player or player:isDead() or not player:hasSkill(self) then return false end
		if player:getPhase() == sgs.Player_Start and player:getPile("Yinbing_ZuMao"):length() > 0 then
			return self:objectName()
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		local targets = sgs.SPlayerList()
		targets:append(player)
		for _,p in sgs.qlist(room:getOtherPlayers(player)) do
			if p:getHp() <= player:getHp() and p:isWounded() then
				targets:append(p)
			end
		end
		local target = room:askForPlayerChosen(player, targets, self:objectName(), "Juedi-invoke", true, true)
		if target then
			room:broadcastSkillInvoke(self:objectName(), player)
			local d = sgs.QVariant()
			d:setValue(target)
			player:setTag("Juedi_target", d)
			return true
		end
		return false
	end,
	on_phasechange = function(self, player)
		local room = player:getRoom()
		local target = player:getTag("Juedi_target"):toPlayer()
		player:removeTag("Juedi_target")
		if not target then return end
		if target ~= player then
			local recover = sgs.RecoverStruct()
			recover.who = player
			room:recover(target, recover)
			if target:isDead() then return end
			local dummy = sgs.DummyCard(player:getPile("Yinbing_ZuMao"))
			local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_EXCHANGE_FROM_PILE, player:objectName(), self:objectName(), "")
			room:obtainCard(target, dummy, reason)
			dummy:deleteLater()
		else
			local len = player:getPile("Yinbing_ZuMao"):length()
			player:clearOnePrivatePile("Yinbing_ZuMao")
			if player:isAlive() then
				room:drawCards(player, len, self:objectName())
			end
		end
	end,
	on_turn_broken = function(self, function_name, event, room, player, data, ask_who)
		player:removeTag("Juedi_target")
	end
}
ZuMao:addSkill(Juedi)

----------------------------------------------------------------------------------------------------

--[[ SP 032 诸葛诞
	武将：ZhuGeDan
	武将名：诸葛诞
	体力上限：4
	武将技能：
		功獒：锁定技，当其他角色死亡后，你加1点体力上限，然后回复1点体力。
		威重：主将技，锁定技，当你加/减体力上限后，你摸一张牌；主将技，锁定技，你拥有“崩坏”。
	状态：复制原项目并调整
]]--
ZhuGeDan = sgs.General(extensionSP, "ZhuGeDan", "wei", 4, true)

--[[
	技能名：功獒
	技能：Gongao
	描述：锁定技，当其他角色死亡后，你加1点体力上限，然后回复1点体力。
	状态：复制原项目并调整
]]--
Gongao = sgs.CreateTriggerSkill{
	name = "Gongao",
	events = {sgs.BuryVictim},
	frequency = sgs.Skill_Compulsory,
	priority = -2,
	can_trigger = function(self, event, room, player, data)
		local skill_list, player_list = {}, {}
		for _,zhugedan in sgs.qlist(room:findPlayersBySkillName(self:objectName())) do
			if zhugedan:objectName() == data:toDeath().who:objectName() then continue end
			table.insert(skill_list, self:objectName())
			table.insert(player_list, zhugedan:objectName())
		end
		return table.concat(skill_list, "|"), table.concat(player_list, "|")
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		if ask_who:hasShownSkill(self) or ask_who:askForSkillInvoke(self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), ask_who)
			return true
		end
		return false
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		room:sendCompulsoryTriggerLog(ask_who, self:objectName(), true)
		local log = sgs.LogMessage()
		log.type = "#GainMaxHp"
		log.from = ask_who
		log.arg = "1"
		room:sendLog(log)
		room:setPlayerProperty(ask_who, "maxhp", sgs.QVariant(ask_who:getMaxHp() + 1))
		if ask_who:isWounded() then
			local recover = sgs.RecoverStruct()
			recover.who = ask_who
			room:recover(ask_who, recover)
		else
			local msg = sgs.LogMessage()
			msg.type, msg.from, msg.arg, msg.arg2 = "#GetHp", ask_who, ask_who:getHp(), ask_who:getMaxHp()
			room:sendLog(msg)
		end
	end,
}
ZhuGeDan:addSkill(Gongao)

--[[
	技能名：威重
	技能：Weizhong
	描述：主将技，锁定技，当你加/减体力上限后，你摸一张牌；主将技，锁定技，你拥有“崩坏”。
	状态：复制原项目并调整
]]--
Weizhong = sgs.CreateTriggerSkill{
	name = "Weizhong",
	can_preshow = true,
	relate_to_place = "head",
	frequency = sgs.Skill_Compulsory,
	events = {sgs.MaxHpChanged},
	can_trigger = function(self, event, room, player, data)
		if player and player:isAlive() and player:hasSkill(self) then
			return self:objectName()
		end
	end,
	on_cost = function(self, event, room, player, data)
		if player:hasShownSkill(self) or player:askForSkillInvoke(self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), player)
			return true
		end
		return false
	end,
	on_effect = function(self, event, room, player, data)
		room:sendCompulsoryTriggerLog(player, self:objectName(), true)
		player:drawCards(1, self:objectName())
	end
}
benghuai_ZhuGeDan = sgs.CreatePhaseChangeSkill{
	name = "#benghuai_ZhuGeDan",
	relate_to_place = "head",
	frequency = sgs.Skill_Compulsory,
	events = {sgs.EventPhaseStart},
	can_trigger = function(self, event, room, player, data)
		if player and player:isAlive() and player:hasSkill(self) then
			if player:getPhase() == sgs.Player_Finish then  --照抄崩坏triggerable
				for _,p in sgs.qlist(room:getOtherPlayers(player)) do
					if player:getHp() > p:getHp() then
						return self:objectName()
					end
				end
			end
		end
	end,
	on_cost = function(self, event, room, player, data)
		if player:hasShownSkill(self) or player:askForSkillInvoke("benghuai", data) then
			if player:ownSkill("Weizhong") and not player:hasShownSkill("Weizhong") then
				player:showGeneral(player:inHeadSkills("Weizhong"))
			end
			return true
		end
		return false
	end,
	on_phasechange = function(self, player)
		local room = player:getRoom()
		room:sendCompulsoryTriggerLog(player, "benghuai", true)
		local result = room:askForChoice(player, "benghuai", "hp+maxhp")
		room:broadcastSkillInvoke("benghuai_ZhuGeDan", player)
		if result == "hp" then
			room:loseHp(player)
		else
			room:loseMaxHp(player)
		end
		return false
	end,
}
ZhuGeDan:addSkill(Weizhong)
ZhuGeDan:addSkill(benghuai_ZhuGeDan)
sgs.insertRelatedSkills(extensionSP, "Weizhong", "#benghuai_ZhuGeDan")
ZhuGeDan:addRelateSkill("benghuai")

----------------------------------------------------------------------------------------------------

--[[ SP 036 程昱
	武将：ChengYu
	武将名：程昱
	体力上限：3
	武将技能：
		设伏：结束阶段开始时，你可以将一张手牌扣置于武将牌旁，称为“伏兵”，并为该牌记录一张基本牌或锦囊牌的牌名（与其他“伏兵”均不相同）；你的回合外，当其他角色使用手牌时，若此牌的牌名与一张“伏兵”的记录相同，你可以将此“伏兵”置入弃牌堆，令此牌无效。
		贲育：当你受到伤害后，若伤害来源存活且你的手牌数：小于X，你可以将手牌补至X（至多为5）张；大于X，你可以弃置至少X+1张手牌，对伤害来源造成1点伤害。（X为伤害来源的手牌数）
	状态：验证通过
]]--
ChengYu = sgs.General(extensionSP, "ChengYu", "wei", 3, true)

--[[
	技能名：设伏
	技能：Shefu
	描述：结束阶段开始时，你可以将一张手牌扣置于武将牌旁，称为“伏兵”，并为该牌记录一张基本牌或锦囊牌的牌名（与其他“伏兵”均不相同）；你的回合外，当其他角色使用手牌时，若此牌的牌名与一张“伏兵”的记录相同，你可以将此“伏兵”置入弃牌堆，令此牌无效。
	状态：验证通过
	注：无法实现手牌上方的设伏按钮效果；由于不可抗拒因素（程序bug），此技能设为不可预亮
]]--
ShefuCard = sgs.CreateSkillCard{
	name = "ShefuCard",
	skill_name = "Shefu",
	target_fixed = true,
	will_throw = false,
	handling_method = sgs.Card_MethodNone,
	mute = true,
	on_use = function(self, room, source, targets)   ---process slash combined
		room:broadcastSkillInvoke("Shefu", 1, source)
		local mark = "Shefu_" .. self:getUserString()
		source:setMark(mark, self:getEffectiveId() + 1)
		local arg = {
			source:objectName(), 
			mark, 
			self:getEffectiveId() + 1,
		}
		room:doNotify(source, sgs.CommandType.S_COMMAND_SET_MARK, json.encode(arg))
		source:addToPile("ambush", self, false)
		local msg = sgs.LogMessage()
		msg.type, msg.from, msg.card_str, msg.arg = "$ShefuRecord", source, tostring(self:getSubcards():first()), self:getUserString()
		room:doNotify(source, sgs.CommandType.S_COMMAND_LOG_SKILL, msg:toVariant())
	end	
}
ShefuVS = sgs.CreateOneCardViewAsSkill{
	name = "Shefu",
	filter_pattern = ".|.|.|hand",
	response_pattern = "Shefu",
	guhuo_type = "!btd",
	view_as = function(self, card)
		local c = sgs.Self:getTag("Shefu"):toString()
        if c ~= "" then
			if sgs.Self:getMark("Shefu_" .. c) > 0 then
				return nil
			end
            local shefu_card = ShefuCard:clone()
            shefu_card:setUserString(c)
            shefu_card:addSubcard(card)
			shefu_card:setShowSkill(self:objectName())
            return shefu_card
        else
            return nil
        end
	end,
}
Shefu = sgs.CreatePhaseChangeSkill{
	name = "Shefu",
	--can_preshow = true,  --若能预亮会导致无法点击视为技按钮
	frequency = sgs.Skill_NotFrequent,
	view_as_skill = ShefuVS,  
	guhuo_type = "!btd",
	can_trigger = function(self, event, room, player, data)
		if not player or player:isDead() or not player:hasSkill(self:objectName()) then return false end
		if ((player:getPhase() == sgs.Player_Finish) and not player:isKongcheng()) then
			--刷新guhuo_box_allowed_elemet
			local name_func = function(card)
				return card:isKindOf("Slash") and "slash" or (card:isKindOf("Nullification") and "nullification" or card:objectName())
			end
			local check_func = function(card, player)
				local name = card:isKindOf("Slash") and "slash" or (card:isKindOf("Nullification") and "nullification" or card:objectName())  --以防万一（防止name_func传不过去）
				return (card:isKindOf("BasicCard") or card:isKindOf("TrickCard")) and (player:getMark("Shefu_" .. name) == 0)
			end
			local allowed_table = fetchCards(check_func, name_func, player)
			if #allowed_table > 0 then
				player:setTag("ShefuAllowedGuhuoButtons", sgs.QVariant(table.concat(allowed_table, "+")))
				return self:objectName()
			end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		local allowed_guhuo_buttons = player:getTag("ShefuAllowedGuhuoButtons"):toString()
		player:removeTag("ShefuAllowedGuhuoButtons")
		local original_guhuo_buttons = player:property("guhuo_box_allowed_elemet"):toString()  --为OldMoshi备份
		room:setPlayerProperty(player, "guhuo_box_allowed_elemet", sgs.QVariant(allowed_guhuo_buttons))
		local invoked = room:askForUseCard(player, "Shefu", "@Shefu-prompt")--不能用@@Shefu，因为国战在askForCard时只会highlight技能按钮（roomscene.cpp#2654），而不是去模拟click（身份roomscene.cpp#2597），而activate函数是在onMouseClick触发的
		room:setPlayerProperty(player, "guhuo_box_allowed_elemet", sgs.QVariant(original_guhuo_buttons))
		return invoked
	end,
	on_phasechange = function(self, player)
	end,
}
ShefuCancel = sgs.CreateTriggerSkill{
	name = "#Shefu-cancel",
	frequency = sgs.Skill_NotFrequent,
	events = {sgs.GeneralShown, sgs.DFDebut, sgs.CardUsed, sgs.CardResponded, sgs.EventLoseSkill},
	on_record = function(self, event, room, player, data)
		if ((event == sgs.GeneralShown) and (data:toBool() == player:inHeadSkills("Shefu"))) or (event == sgs.DFDebut) then
			if not (player and player:isAlive() and player:hasSkill(self:objectName())) then return "" end
			if player:property("ShefuAskState"):toString() == "" then
				local choice = room:askForChoice(player, "Shefu", "ShefuAskAll+ShefuAskNecessary")
				room:setPlayerProperty(player, "ShefuAskState", sgs.QVariant(choice))
			end
		elseif (event == sgs.EventLoseSkill) and data:toString() == "Shefu" then
			player:clearOnePrivatePile("ambush")
		end
	end,
	can_trigger = function(self, event, room, player, data)
		if (event == sgs.CardUsed) or (event == sgs.CardResponded) then
			local card
			local handcard = false
			if event == sgs.CardUsed then  
				card = data:toCardUse().card
				handcard = data:toCardUse().m_isHandcard
			elseif event == sgs.CardResponded then
				local response = data:toCardResponse()
				if response.m_isUse and response.m_card:isKindOf("Jink") then
					card = response.m_card
				end
				handcard = response.m_isHandcard
			end
			if not handcard then return "" end
			if not (card and ((card:getTypeId() == sgs.Card_TypeBasic) or (card:getTypeId() == sgs.Card_TypeTrick)) and (card:getHandlingMethod() == sgs.Card_MethodUse)) then
				return ""
			end
			local cardName = card:isKindOf("Slash") and "slash" or (card:isKindOf("Nullification") and "nullification" or card:objectName())
			
			local skill_list, player_list = {}, {}
			for _,chengyu in sgs.qlist(room:findPlayersBySkillName("Shefu")) do
				if not (room:getCurrent() and room:getCurrent():objectName() == chengyu:objectName()) and not (chengyu:objectName() == player:objectName()) and not chengyu:getPile("ambush"):isEmpty() then  --尽量用getCurrent，考虑到明鉴类技能
					table.insert(skill_list, self:objectName())
					table.insert(player_list, chengyu:objectName())
				end
			end
			return table.concat(skill_list, "|"), table.concat(player_list, "|")
		--[[elseif (event == sgs.JinkEffect) or (event == sgs.NullificationEffect) then
			card = data:toCard()  --由于这里的card是重新Parse得到的，没有Flag，所以只能用player来保存信息
			if event == sgs.JinkEffect then
				nullified_jinks = player:getTag("ShefuNullifiedJinks"):toString():split("|")
				if table.contains(nullified_jinks, card:toString()) then
					return self:objectName()
				end
			elseif event == sgs.NullificationEffect and player:hasFlag("ShefuNullifiedNullification") then
				return self:objectName()
			end]]
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		if (event == sgs.CardUsed) or (event == sgs.CardResponded) then
			local card = (event == sgs.CardUsed) and data:toCardUse().card or data:toCardResponse().m_card
			local cardName = card:isKindOf("Slash") and "slash" or (card:isKindOf("Nullification") and "nullification" or card:objectName())
			if ask_who:property("ShefuAskState"):toString() == "ShefuAskAll" then
				if not room:askForSkillInvoke(ask_who, "Shefu_cancel", sgs.QVariant("data:::" .. cardName)) or (ask_who:getMark("Shefu_" .. cardName) == 0) then return false end
			else
				if (ask_who:getMark("Shefu_" .. cardName) == 0) or not room:askForSkillInvoke(ask_who, "Shefu_cancel", sgs.QVariant("data:::" .. cardName)) then return false end
			end
			room:broadcastSkillInvoke("Shefu", 2, ask_who)
			local msg = sgs.LogMessage()
			msg.type, msg.from, msg.arg, msg.arg2 = "#ShefuEffect", ask_who, cardName, "Shefu"
			msg.to:append(player)
			room:sendLog(msg)
			
			local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_REMOVE_FROM_PILE, nil, "Shefu", nil)
			local id = ask_who:getMark("Shefu_" .. cardName) - 1
			room:setPlayerMark(ask_who, "Shefu_" .. cardName, 0)
			room:throwCard(sgs.Sanguosha:getCard(id), reason, nil)
			return true
		--[[elseif (event == sgs.JinkEffect) or (event == sgs.NullificationEffect) then
			return true]]
		end
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		if (event == sgs.CardUsed) or (event == sgs.CardResponded) then
			local card = (event == sgs.CardUsed) and data:toCardUse().card or data:toCardResponse().m_card
			if card:isKindOf("Jink") then
				local nullified_jinks = player:getTag("ShefuNullifiedJinks"):toString():split("|")
				if not table.contains(nullified_jinks, card:toString()) then
					table.insert(nullified_jinks, card:toString())
				end
				table.removeAll(nullified_jinks, "")
				player:setTag("ShefuNullifiedJinks", sgs.QVariant(table.concat(nullified_jinks, "|")))
			elseif card:isKindOf("Nullification") then
				player:setFlags("ShefuNullifiedNullification")
				if card:isKindOf("HegNullification") then
					player:setFlags("ShefuNullifiedHegNullification")
				end
				local dat = sgs.QVariant()
				dat:setValue(card)
				player:setTag("ShefuNullifiedNullificationCard", dat)
			else
				local use = data:toCardUse()
				local nullified_list = use.nullified_list
				table.insert(nullified_list, "_ALL_TARGETS")
				use.nullified_list = nullified_list
				data:setValue(use)
			end
			return false
		--elseif (event == sgs.JinkEffect) --[[or (event == sgs.NullificationEffect)]] then
			--[[local card = data:toCard()  --由于这里的card是重新Parse得到的，没有Flag，所以只能用player来保存信息
			if event == sgs.JinkEffect then
				nullified_jinks = player:getTag("ShefuNullifiedJinks"):toString():split("|")
				if table.contains(nullified_jinks, card:toString()) then
					table.removeOne(nullified_jinks, card:toString())
					if #nullified_jinks ~= 0 then
						player:setTag("ShefuNullifiedJinks", sgs.QVariant(table.concat(nullified_jinks, "|")))
					else
						player:removeTag("ShefuNullifiedJinks")
					end
					return true
				end]]
			--[[elseif event == sgs.NullificationEffect and player:hasFlag("ShefuNullifiedNullification") then
				player:setFlags("-ShefuNullifiedNullification")
				return true]]
			--end
		end
	end
}
ShefuCancelJink = sgs.CreateTriggerSkill{
	name = "#Shefu-cancel-jink",
	frequency = sgs.Skill_Compulsory,
	events = {sgs.JinkEffect},  --国战没有NullificationEffect
	can_trigger = function(self, event, room, player, data)
		card = data:toCard()  --由于这里的card是重新Parse得到的，没有Flag，所以只能用player来保存信息
		if event == sgs.JinkEffect then
			nullified_jinks = player:getTag("ShefuNullifiedJinks"):toString():split("|")
			if table.contains(nullified_jinks, card:toString()) then
				return  --[[.. "'" .. ]]self:objectName()  --由于源码bug暂无法实现（todo：新版本已修，恢复）
			end
		--elseif event == sgs.NullificationEffect and player:hasFlag("ShefuNullifiedNullification") then
		--	return self:objectName()
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		return true
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		local card = data:toCard()  --由于这里的card是重新Parse得到的，没有Flag，所以只能用player来保存信息
		if event == sgs.JinkEffect then
			nullified_jinks = player:getTag("ShefuNullifiedJinks"):toString():split("|")
			if table.contains(nullified_jinks, card:toString()) then
				table.removeOne(nullified_jinks, card:toString())
				if #nullified_jinks ~= 0 then
					player:setTag("ShefuNullifiedJinks", sgs.QVariant(table.concat(nullified_jinks, "|")))
				else
					player:removeTag("ShefuNullifiedJinks")
				end
				return true
			end
		--[[elseif event == sgs.NullificationEffect and player:hasFlag("ShefuNullifiedNullification") then
			player:setFlags("-ShefuNullifiedNullification")
			return true]]
		end
	end
}
ShefuCancelNullification = sgs.CreateTriggerSkill{
	name = "#Shefu-cancel-nullification",
	events = {sgs.TrickCardCanceling, sgs.ChoiceMade, sgs.CardEffectConfirmed, sgs.PostCardEffected},
	--[[思路：
		（0）在TrickCardCancelling记录要被无懈的锦囊牌（room.cpp #1243），用于在ChoiceMade读取数据验证；在CardUsed记录使用的无懈，用于（4）
		（1）模拟源码中的NullificationEffect时机，在ChoiceMade读取被设伏的无懈的使用信息及使用者（room.cpp #1385）
		（2）将这张被使用的无懈设为不可无懈，防止被反无懈（room.cpp #1393）（用setCancelable或TrickCardCancelling）
		（3）重新询问无懈，以模拟v2里无懈被设伏后重新询问的过程（v2 room.cpp #1160）
		（4）然后判断重新询问的结果：若有人再次使用无懈响应（即实际效果和不发动设伏相同），则不处理后续效果，否则继续执行（因设伏的效果而需要改变游戏进程）
		（5）然后分两种情况：
			1.  被设伏的无懈是第1、3、5……张无懈，那么原锦囊牌应该依然执行效果
				而按照游戏进程不会执行此牌效果（gamerule.cpp #673），因此在ChoiceMade手动令此牌生效（card->onEffect）
			2.  被设伏的无懈是第2、4、6……张无懈，那么第1、3、5……张无懈生效，原锦囊牌不应执行效果
				而按照游戏进程依然会执行此牌效果，因此在CardEffectConfirmed令目标视为已死亡，因此不会触发onEffect（gamerule.cpp #678）
				然后依然会触发PostCardEffected（room.cpp #3911），在此重新把目标设置为存活
		关于国无懈的处理：由于国无懈只有对非无懈的锦囊才有特殊效果，一定属于（5.1）类型，因此在PostCardEffected手动设置HegNullificationTargets这个Tag（room.cpp #1197, 1169）
			（不直接在ChoiceMade设置，是因源码中为对国无懈Tag的处理在isCanceled中，因此在ChoiceMade之后）
	]]
	--为了简化代码，所有操作均在on_record中执行
	frequency = sgs.Skill_Compulsory,
	priority = 10,
	on_record = function(self, event, room, player, data)
		if event == sgs.TrickCardCanceling then
			player:setTag("ShefuTrickCancelingTrickEffect", data)  --（0）
		elseif event == sgs.ChoiceMade then
			local decisionData = data:toString():split(":")  --（1）
			if (#decisionData ~= 4) or (decisionData[1] ~= "Nullification") then return end
			if not player:hasFlag("ShefuNullifiedNullification") then return end
			player:setFlags("-ShefuNullifiedNullification")
			local trickEffect = player:getTag("ShefuTrickCancelingTrickEffect"):toCardEffect()
			player:removeTag("ShefuTrickCancelingTrickEffect")
			local null = player:getTag("ShefuNullifiedNullificationCard"):toCard()
			player:removeTag("ShefuNullifiedNullificationCard")
			if (not trickEffect) or (not null) then return end
			if (trickEffect.card:getClassName() ~= decisionData[2]) or (trickEffect.to:objectName() ~= decisionData[3]) then return end
			local positive = (decisionData[4] == "true")
			local isHegNullification = room:getTag("NullificatonType"):toBool()  --本来是给AI用的，在此顺便借用（顺便吐槽typo）
			
			--null:setCancelable(false)  --（2）
			null:toTrick():setCancelable(false)  --（2）
			--（3）
			room:setTag("HegNullificationValid", sgs.QVariant(false))
			local is_reNullified = room:askForNullification(trickEffect.card, trickEffect.from, trickEffect.to, positive)
			if is_reNullified then  --（4）
				--判断新无懈是不是国无懈（如果是普通无懈的话依然需要取消国无懈的效果）
				if isHegNullification and not room:getTag("HegNullificationValid"):toBool() then
					trickEffect.to:setFlags("ShefuHegNullificationToBeNullified")
				end
				return
			end
			
			if positive then  --（5.1）
				--理论上应该去除Global_NonSkillNullify的flag，但是lua接触不到这个时机（在gamerule的CardEffected里，设好了就直接return true了）
				trickEffect.card:onEffect(trickEffect)
			else  --（5.2）
				trickEffect.to:setFlags("ShefuNeedDeadToPreventCardEffect")
			end
			
			if isHegNullification then
				trickEffect.to:setFlags("ShefuHegNullificationToBeNullified")
			end
		elseif event == sgs.CardEffectConfirmed then  --（5.2）后续
			if player:hasFlag("ShefuNeedDeadToPreventCardEffect") then
				player:setFlags("-ShefuNeedDeadToPreventCardEffect")
				if player:isDead() then return end
				player:setFlags("ShefuAlreadySetDeadToPreventCardEffect")
				player:setAlive(false)  --参考虫妹三将朱然lua
				room:broadcastProperty(player, "alive")
			end
		elseif event == sgs.PostCardEffected then  --（5.2）后续，（5.1）国无懈后续
			if player:hasFlag("ShefuAlreadySetDeadToPreventCardEffect") then
				player:setFlags("-ShefuAlreadySetDeadToPreventCardEffect")
				player:setAlive(true)
				room:broadcastProperty(player, "alive")
			end
			if player:hasFlag("ShefuHegNullificationToBeNullified") then
				player:setFlags("-ShefuHegNullificationToBeNullified")
				local trickEffect = data:toCardEffect()
				--local heg_targets = room:getTag(trickEffect.card:toString() .. "HegNullificationTargets"):toString():split("+")
				local heg_targets = room:getTag(trickEffect.card:toString() .. "HegNullificationTargets"):toStringList()
				for _,p in sgs.qlist(room:getAlivePlayers()) do
					if p:isFriendWith(player) then
						table.removeOne(heg_targets, p:objectName())
					end
				end
				table.removeAll(heg_targets, "")
				local list = sgs.VariantList()
				for _,str in pairs(heg_targets) do
					list:append(sgs.QVariant(str))
				end
				room:setTag(trickEffect.card:toString() .. "HegNullificationTargets", sgs.QVariant(list))
			end
		end
	end,
	can_trigger = function(self, event, room, player, data)  --防崩溃
		return ""
	end
}
ChengYu:addSkill(Shefu)
ChengYu:addSkill(ShefuCancel)
ChengYu:addSkill(ShefuCancelJink)
ChengYu:addSkill(ShefuCancelNullification)
sgs.insertRelatedSkills(extensionSP, "Shefu", "#Shefu-cancel", "#Shefu-cancel-jink", "#Shefu-cancel-nullification")

--[[
	技能名：贲育
	技能：Benyu
	描述：当你受到伤害后，若伤害来源存活且你的手牌数：小于X，你可以将手牌补至X（至多为5）张；大于X，你可以弃置至少X+1张手牌，对伤害来源造成1点伤害。（X为伤害来源的手牌数）
	状态：验证通过
]]--
Benyu = sgs.CreateMasochismSkill{
	name = "Benyu",
	frequency = sgs.Skill_Frequent,
	can_trigger = function(self, event, room, player, data)	
		if not player or player:isDead() or not player:hasSkill(self:objectName()) then return "" end
		local damage = data:toDamage()
		if damage.from and damage.from:isAlive() then
			return (damage.from:getHandcardNum() ~= player:getHandcardNum()) and self:objectName() or ""
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		local damage = data:toDamage()
		if damage.from:getHandcardNum() > player:getHandcardNum() then
			if player:askForSkillInvoke(self:objectName(), data) then
				room:broadcastSkillInvoke(self:objectName(), 1, player)
				player:setTag("BenyuType", sgs.QVariant(damage.from:getHandcardNum()))
				return true 
			end
		elseif damage.from:getHandcardNum() < player:getHandcardNum() then
			if room:askForDiscard(player, self:objectName(), 999, damage.from:getHandcardNum() + 1, true, false, "@Benyu-discard::" .. damage.from:objectName() .. ":" .. damage.from:getHandcardNum() + 1, true) then
				room:broadcastSkillInvoke(self:objectName(), 2, player)
				player:setTag("BenyuType", sgs.QVariant(-1))
				return true 
			end
		end
		return false
	end,
	on_damaged = function(self, player, damage)
		local room = player:getRoom()
		local x = player:getTag("BenyuType"):toInt()
		player:removeTag("BenyuType")
		if x > 0 then
			room:drawCards(player, math.max(math.min(x, 5) - player:getHandcardNum(), 0), self:objectName())
		elseif x == -1 then
			if damage.from and damage.from:isAlive() then
				room:damage(sgs.DamageStruct(self:objectName(), player, damage.from))
			end
		end
	end,
	on_turn_broken = function(self, function_name, event, room, player, data, ask_who)
		player:removeTag("BenyuType")
	end
}
ChengYu:addSkill(Benyu)

----------------------------------------------------------------------------------------------------

--[[ V.WEI 019 文聘
	武将：WenPin_3v3
	武将名：文聘-3v3
	体力上限：4
	武将技能：
		镇卫：锁定技，与你势力不同的角色与其他与你势力相同的角色的距离+1。 
	状态：
]]--

----------------------------------------------------------------------------------------------------

--[[ D.WEI 025 牛金
	武将：NiuJin
	武将名：牛金
	体力上限：4
	武将技能：
		挫锐：锁定技，当你首次明置此武将牌后，你摸三张牌；锁定技，限定技，你跳过判定阶段。
		裂围：当你杀死一名角色后，你可以摸三张牌。
	状态：
]]--

----------------------------------------------------------------------------------------------------

--[[ D.QUN 025 何进
	武将：HeJin
	武将名：何进
	体力上限：4
	武将技能：
		谋诛：出牌阶段限一次，你可以令一名有手牌的角色交给你一张手牌，然后若其手牌少于你，其选择一项：1. 视为对你使用一张【杀】（无距离限制）；2. 视为对你使用一张【决斗】。 
		延祸：当你死亡时，你可以依次弃置一名其他角色的X张牌（X为你的牌数）。
	状态：
]]--

----------------------------------------------------------------------------------------------------

--[[ D.QUN 027 韩遂
	武将：HanSui
	武将名：韩遂
	体力上限：4
	武将技能：
		马术：锁定技。你与其他角色的距离-1。 
		逆乱：其他角色的结束阶段开始时，若其体力值大于你，或其于此回合内对你使用过【杀】，你可以将一张黑色牌当【杀】对其使用。 
	状态：
]]--

---------------------------------------------界限突破SP---------------------------------------------

extensionJSP = sgs.Package("JSP", sgs.Package_GeneralPack)

--[[ J.SP 001 孙尚香
	武将：SunShangXiang_JSP
	武将名：孙尚香-界SP
	体力上限：3
	武将技能：
		良助: 当一名角色于其出牌阶段内回复体力后，你可以选择一项：1. 摸一张牌；2. 令其摸两张牌。
		返乡：限定技，准备阶段开始时，若有至少一名已受伤且你发动过“良助”令其摸牌的角色，你可失去“良助”并获得“结姻”和“枭姬”。
	状态：
]]--

----------------------------------------------------------------------------------------------------

--[[ J.SP 003 关羽
	武将：GuanYu_JSP
	武将名：关羽-界SP
	体力上限：4
	武将技能：
		武圣：你可以将一张红色牌当【杀】使用或打出。
		忠义：主将技，限定技，出牌阶段，你可以将一张红色手牌置于武将牌上，若如此做，准备阶段开始时，你将“忠义”牌置入弃牌堆；当与你势力相同的角色使用【杀】对目标角色造成伤害时，若你有“忠义”牌，你令此伤害+1。
		--单骑：副将技，锁定技，此武将牌上单独的阴阳鱼个数-1；你拥有“马术”和“怒斩”（锁定技，你使用的由一张锦囊牌转化的【杀】不计入限制的使用次数；锁定技，你使用的由一张装备牌转化的【杀】的伤害值基数+1）。【2.1.0实现太麻烦】
		马术：副将技，锁定技，你与其他角色的距离-1。
		怒斩：副将技，锁定技，你使用的由一张锦囊牌转化的【杀】不计入限制的使用次数；锁定技，你使用的由一张装备牌转化的【杀】的伤害值基数+1。
	状态：
]]--
GuanYu_JSP = sgs.General(extensionJSP, "GuanYu_JSP", "wei", 4, true)
GuanYu_JSP:addCompanion("zhangliao")
GuanYu_JSP:addCompanion("ZhangLiao_LB")

--[[
	技能名：武圣
	技能：wusheng_GuanYu_JSP
	描述：你可以将一张红色牌当【杀】使用或打出。
	状态：复制手册
]]--
wusheng_GuanYu_JSP = sgs.CreateWushengSkill("GuanYu_JSP")
GuanYu_JSP:addSkill(wusheng_GuanYu_JSP)

--[[
	技能名：忠义
	技能：Zhongyi
	描述：主将技，限定技，出牌阶段，你可以将一张红色手牌置于武将牌上，若如此做，准备阶段开始时，你将“忠义”牌置入弃牌堆；当与你势力相同的角色使用【杀】对目标角色造成伤害时，若你有“忠义”牌，你令此伤害+1。
	状态：
]]--
ZhongyiCard = sgs.CreateSkillCard{
	name = "ZhongyiCard",
	skill_name = "Zhongyi",
	mute = true,
	will_throw = false,
	target_fixed = true,
	handling_method = sgs.Card_MethodNone,
	about_to_use = function(self, room, cardUse)
		room:removePlayerMark(cardUse.from, "@loyal")
		room:broadcastSkillInvoke("Zhongyi", cardUse.from)
		room:doSuperLightbox("GuanYu_JSP", "Zhongyi")
		self:cardOnUse(room, cardUse)
	end,
	on_use = function(self, room, source, targets)
		source:addToPile("loyal", self)
	end
}
ZhongyiVS = sgs.CreateOneCardViewAsSkill{
	name = "Zhongyi",
	filter_pattern = ".|red|.|hand",
	view_as = function(self, card)
		local vs_card = ZhongyiCard:clone()
		vs_card:addSubcard(card)
		vs_card:setShowSkill(self:objectName())
		return vs_card
	end,
	enabled_at_play = function(self, player)
		return not player:isKongcheng() and player:getMark("@loyal") > 0
	end,
}
Zhongyi = sgs.CreateTriggerSkill{
	name = "Zhongyi",
	relate_to_place = "head",
	can_preshow = false,
	frequency = sgs.Skill_Limited,
	limit_mark = "@loyal",
	view_as_skill = ZhongyiVS,
}
ZhongyiAction = sgs.CreateTriggerSkill{
	name = "#Zhongyi-action",
	relate_to_place = "head",
	events = {sgs.DamageCaused},
	frequency = sgs.Skill_Compulsory,
	can_trigger = function(self, event, room, player, data)
		local damage = data:toDamage()
		if damage.chain or damage.transfer or not damage.by_user then return "" end
		if damage.card and damage.card:isKindOf("Slash") and damage.from then
			local skill_list = {}
			local name_list = {}
			for _, guanyu in sgs.qlist(room:findPlayersBySkillName(self:objectName())) do
				if guanyu:willBeFriendWith(damage.from) and not guanyu:getPile("loyal"):isEmpty() then
					table.insert(skill_list, self:objectName())
					table.insert(name_list, guanyu:objectName())
				end
			end
			return table.concat(skill_list, "|"), table.concat(name_list, "|")
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		return true
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		local damage = data:toDamage()
		
		local l = sgs.LogMessage()
		l.type = "#ZhongyiBuff"
		l.from = ask_who
		l.arg = damage.damage
		l.arg2 = damage.damage + 1
		room:sendLog(l)

		damage.damage = damage.damage + 1
		data:setValue(damage)
		return false
	end,
}
ZhongyiClear = sgs.CreateTriggerSkill{
	name = "#Zhongyi-clear",
	frequency = sgs.Skill_Wake,
	global = true,
	events = {sgs.EventPhaseStart, sgs.EventLoseSkill},
	on_record = function(self, event, room, player, data)
		if event == sgs.EventLoseSkill and data:toString() == "Zhongyi" then
			player:clearOnePrivatePile("loyal")
		end
	end,
	can_trigger = function(self, event, room, player, data)
		if not player or player:isDead() then return false end
		if event == sgs.EventPhaseStart and (player:getPhase() == sgs.Player_Start) and not player:getPile("loyal"):isEmpty() then
			return self:objectName()
		end
	end,
	on_cost = function(self, event, room, player, data)
		return true
	end,
	on_effect = function(self, event, room, player, data)
		player:clearOnePrivatePile("loyal")
	end,
}
GuanYu_JSP:addSkill(Zhongyi)
GuanYu_JSP:addSkill(ZhongyiAction)
GuanYu_JSP:addSkill(ZhongyiClear)
sgs.insertRelatedSkills(extensionJSP, "Zhongyi", "#Zhongyi-action", "#Zhongyi-clear")

--[[
	技能名：马术
	技能：Mashu_GuanYu_JSP
	描述：副将技，锁定技，你与其他角色的距离-1。
	状态：复制手册
]]--
Mashu_GuanYu_JSP = sgs.CreateDistanceSkill{
	name = "Mashu_GuanYu_JSP",
	relate_to_place = "deputy",
	correct_func = function(self, from, to)
		if from:hasSkill(self) and from:hasShownSkill(self) then
			return -1
		end
		return 0
	end
}
GuanYu_JSP:addSkill(Mashu_GuanYu_JSP)

--[[
	技能名：怒斩
	技能：Nuzhan
	描述：副将技，锁定技，你使用的由一张锦囊牌转化的【杀】不计入限制的使用次数；锁定技，你使用的由一张装备牌转化的【杀】的伤害值基数+1。
	状态：验证通过
	注：伤害值基数+1其实是状态类技能，目前按照状态类技能的“需要用到效果时明置”的规则设置为在ConfirmDamage明置（即当成了一个在此时机的触发技，不用处理死亡）
]]--
Nuzhan = sgs.CreateTriggerSkill{  --todo：验证谮毁（怒斩2）
	name = "Nuzhan",
	relate_to_place = "deputy",
	can_preshow = true,
	frequency = sgs.Skill_Compulsory,
	events = {sgs.PreCardUsed, sgs.ConfirmDamage},
	on_record = function(self, event, room, player, data)
		if event == sgs.PreCardUsed then
			local use = data:toCardUse()
			if use.card and use.card:isKindOf("Slash") and use.card:isVirtualCard() and (use.card:subcardsLength() == 1)
				and sgs.Sanguosha:getCard(use.card:getSubcards():first()):isKindOf("EquipCard") then
				use.card:setFlags("Nuzhan_slash")  --在离开手牌之前记录（预防FilterSkill）
			end
		end
	end,
	can_trigger = function(self, event, room, player, data)
		if event == sgs.PreCardUsed then
			if not player or player:isDead() or not player:hasSkill(self) then return false end
			local use = data:toCardUse()
			if use.card and use.card:isKindOf("Slash") and use.card:isVirtualCard() and (use.card:subcardsLength() == 1)
				and sgs.Sanguosha:getCard(use.card:getSubcards():first()):isKindOf("TrickCard") and use.m_addHistory then
				return self:objectName()
			end
		elseif event == sgs.ConfirmDamage then
			if not player or player:isDead() or not player:hasSkill(self) then return false end
			local damage = data:toDamage()
			if damage.card and damage.card:hasFlag("Nuzhan_slash") and damage.by_user then
				return self:objectName()
			end
		end
	end,
	on_cost = function(self, event, room, player, data)	
		player:setTag("NuzhanData", data)  --For AI
		if player:hasShownSkill(self:objectName()) or player:askForSkillInvoke(self:objectName(), sgs.QVariant((event == sgs.PreCardUsed) and "trick" or "equip")) then
			player:removeTag("NuzhanData")
			room:broadcastSkillInvoke(self:objectName(), (event == sgs.PreCardUsed) and 1 or 2, player)
			return true
		end
		player:removeTag("NuzhanData")
		return false
	end,
	on_effect = function(self, event, room, player, data)
		if event == sgs.PreCardUsed then
			room:sendCompulsoryTriggerLog(player, self:objectName(), true)
			local use = data:toCardUse()
			room:addPlayerHistory(player, use.card:getClassName(), -1)
			use.m_addHistory = false
			data:setValue(use)
		else
			local damage = data:toDamage()
			local msg = sgs.LogMessage()
			msg.type, msg.from, msg.arg, msg.arg2 = "#NuzhanBuff", damage.from, damage.damage, damage.damage + 1
			room:sendLog(msg)
			damage.damage = damage.damage + 1
			data:setValue(damage)
		end
	end
}
GuanYu_JSP:addSkill(Nuzhan)
GuanYu_JSP:setDeputyMaxHpAdjustedValue(-1)

----------------------------------------------------------------------------------------------------

--[[ J.SP 004 姜维
	武将：JiangWei_JSP
	武将名：姜维-界SP
	体力上限：4
	武将技能：
		困奋：锁定技，结束阶段开始时，你失去1点体力，然后摸两张牌。 
		逢亮：锁定技，限定技，当你进入濒死状态时，你将体力上限调整为3点并将体力值回复至2点，将势力改为蜀，然后获得“挑衅”并将“困奋”改为非锁定技。 
	状态：
]]--

----------------------------------------------------------------------------------------------------

--[[ J.SP 005 赵云
	武将：ZhaoYun_JSP
	武将名：赵云-界SP
	体力上限：4
	武将技能：
		赤心：你可以将一张♦牌当【杀】或【闪】使用或打出；出牌阶段内，你对此阶段内你没有对其使用过【杀】，且在你攻击范围内的角色使用【杀】无次数限制。 
		随仁：主将技，限定技，准备阶段开始时，你可令一名角色摸三张牌，然后你回复1点体力。
		义从：副将技，锁定技，此武将牌上单独的阴阳鱼个数-1；若你的体力值大于2，你与其他角色的距离-1；若你的体力值不大于2，其他角色与你的距离+1。
	状态：
]]--

---------------------------------------------RE修订武将---------------------------------------------

extensionRE = sgs.Package("RE", sgs.Package_GeneralPack)

--[[ RE 002 于禁
	武将：YuJin_RE
	武将名：于禁-RE
	体力上限：4
	武将技能：
		节钺：结束阶段开始时，你可以弃置一张手牌并选择一名其他角色，令其选择一项：将一张牌置于你的武将牌上；或令你弃置其一张牌。若你有“节钺”牌，你可以将红色手牌当【闪】、黑色的手牌当【无懈可击】使用或打出；准备阶段开始时，你获得“节钺”牌。
	状态：验证通过
]]--
YuJin_RE = sgs.General(extensionRE, "YuJin_RE", "wei", 4, true)

--[[
	技能名：节钺
	技能：Jieyue
	描述：节钺：结束阶段开始时，你可以弃置一张手牌并选择一名其他角色，令其选择一项：将一张牌置于你的武将牌上；或令你弃置其一张牌。若你有“节钺”牌，你可以将红色手牌当【闪】、黑色的手牌当【无懈可击】使用或打出；准备阶段开始时，你获得“节钺”牌。	
	状态：验证通过
]]--
JieyueCard = sgs.CreateSkillCard{
	name = "JieyueCard",
	skill_name = "Jieyue",
    will_throw = true,
	on_effect = function(self, effect)
		if effect.from:isDead() or effect.to:isDead() or effect.to:isNude() then return end
		local room = effect.to:getRoom()
		local card = room:askForExchange(effect.to, "Jieyue", 1, effect.from:canDiscard(effect.to, "he") and 0 or 1, "@Jieyue-put:" .. effect.from:objectName())  --无法弃牌（如新标月英）则必须给牌
		if card then
			effect.from:addToPile("Jieyue_pile", card)
		elseif effect.from:canDiscard(effect.to, "he") then
			local id = room:askForCardChosen(effect.from, effect.to, "he", "Jieyue", false, sgs.Card_MethodDiscard)
			local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_DISMANTLE, effect.from:objectName(), effect.to:objectName(), "Jieyue", nil)
			room:throwCard(sgs.Sanguosha:getCard(id), reason, effect.to, effect.from)
		end
	end,
}
JieyueVS = sgs.CreateOneCardViewAsSkill{
	name = "Jieyue",
	response_or_use = true,  --国战无法在此放函数，因此弃牌处理转移到view_filter
	view_filter = function(self, card)
		if card:isEquipped() then return false end
		local pattern = sgs.Sanguosha:getCurrentCardUsePattern()
		if pattern == "@@Jieyue" then
			return sgs.Self:getHandcards():contains(card) and not sgs.Self:isJilei(card)
		end
		if pattern == "jink" then
			return card:isRed()
		elseif pattern == "nullification" then
			return card:isBlack()
		end
		return false
	end,
	view_as = function(self, card)
		local pattern = sgs.Sanguosha:getCurrentCardUsePattern()
		if pattern == "@@Jieyue" then
			local vs_card = JieyueCard:clone()
			vs_card:addSubcard(card)
			vs_card:setShowSkill(self:objectName())
			return vs_card
		end
		local vs_card = sgs.Sanguosha:cloneCard(card:isRed() and "jink" or "nullification", sgs.Card_SuitToBeDecided, -1)
		vs_card:addSubcard(card)
		vs_card:setSkillName(self:objectName())
		vs_card:setShowSkill(self:objectName())
		return vs_card
	end,
	enabled_at_play = function(self, player)
		return false
	end,
	enabled_at_response = function(self, player, pattern)
		return ((pattern == "@@Jieyue") and not player:isKongcheng()) or ((not player:getPile("Jieyue_pile"):isEmpty()) and ((pattern == "jink") or (pattern == "nullification")))
	end,
	enabled_at_nullification = function(self, player)
		if not player:getPile("Jieyue_pile"):isEmpty() then
			for _,cd in sgs.qlist(player:getHandcards()) do
				if cd:isBlack() then return true end
			end
			for _,id in sgs.qlist(player:getHandPile()) do
				if sgs.Sanguosha:getCard(id):isBlack() then return true end
			end
		end
	end
}
Jieyue = sgs.CreatePhaseChangeSkill{
	name = "Jieyue",  
	can_preshow = true,
	frequency = sgs.Skill_NotFrequent,
	view_as_skill = JieyueVS,
	can_trigger = function(self, event, room, player, data)
		if not player or player:isDead() or not player:hasSkill(self:objectName()) then return false end
		if ((player:getPhase() == sgs.Player_Finish) and not player:isKongcheng()) then
			return self:objectName()
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		if player:getPhase() == sgs.Player_Finish then
			return room:askForUseCard(player, "@@Jieyue", "@Jieyue", -1, sgs.Card_MethodDiscard, false)
		end
	end,
	on_phasechange = function(self, player)
		return false
	end,
}
JieyueObtain = sgs.CreatePhaseChangeSkill{
	name = "#Jieyue-obtain",
	frequency = sgs.Skill_Compulsory,
	can_trigger = function(self, event, room, player, data)
		if not player or player:isDead() or not player:hasSkill(self:objectName()) then return false end
		return ((player:getPhase() == sgs.Player_Start) and not player:getPile("Jieyue_pile"):isEmpty()) and self:objectName() or ""
	end,
	on_cost = function(self, event, room, player, data)
		if player:ownSkill("Jieyue") and not player:hasShownSkill("Jieyue") then
			player:showGeneral(player:inHeadSkills("Jieyue"))
		end
		return true
	end,
	on_phasechange = function(self, player)
		local room = player:getRoom()
		local dummy = sgs.DummyCard(player:getPile("Jieyue_pile"))
		local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_EXCHANGE_FROM_PILE, player:objectName(), "Jieyue", "")
		room:obtainCard(player, dummy, reason)
		dummy:deleteLater()
	end,
}
JieyueClear = sgs.CreateTriggerSkill{
	name = "#Jieyue-clear",
	frequency = sgs.Skill_Compulsory,
	events = {sgs.EventLoseSkill},
	on_record = function(self, event, room, player, data)
		if data:toString() == "Jieyue" then
			player:clearOnePrivatePile("Jieyue_pile")
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
YuJin_RE:addSkill(Jieyue)
YuJin_RE:addSkill(JieyueObtain)
YuJin_RE:addSkill(JieyueClear)
sgs.insertRelatedSkills(extensionRE, "Jieyue", "#Jieyue-obtain", "#Jieyue-clear")

----------------------------------------------------------------------------------------------------

--[[ RE 004 马岱
	武将：MaDai_RE
	武将名：马岱-RE
	体力上限：4
	武将技能：
		潜袭：准备阶段开始时，你可以摸一张牌，然后弃置一张牌，若如此做，你令距离为1的一名角色于此回合内不能使用或打出与你以此法弃置的牌颜色相同的手牌。
		马术：锁定技，你与其他角色的距离-1。
	状态：验证通过
]]--
MaDai_RE = sgs.General(extensionRE, "MaDai_RE", "shu", 4, true, true)
MaDai_RE:addCompanion("machao")
MaDai_RE:addCompanion("MaChao_LB")

--[[
	技能名：潜袭
	技能：QianxiRE
	描述：准备阶段开始时，你可以摸一张牌，然后弃置一张牌，若如此做，你令距离为1的一名角色于此回合内不能使用或打出与你以此法弃置的牌颜色相同的手牌。
	状态：验证通过
]]--
QianxiRE = sgs.CreatePhaseChangeSkill{
	name = "QianxiRE",
	can_preshow = false,
	can_trigger = function(self, event, room, player, data)
		if not player or player:isDead() or not player:hasSkill(self) then return false end
		if player:getPhase() == sgs.Player_Start then
			return self:objectName()
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		if room:askForSkillInvoke(player, self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), player)
			return true
		end
		return false
	end,
	on_phasechange = function(self, player)
		local room = player:getRoom()
		player:drawCards(1, self:objectName())
		if player:isDead() or not player:canDiscard(player, "he") then return false end
		local c = room:askForCard(player, "..!", "@QianxiRE")
		if not c then
			c = player:getCards("he"):at(math.random(0, player:getCardCount(true) - 1))
			room:throwCard(c, player)
		end
		if player:isDead() then return false end
		
		local color = c:isBlack() and "black" or (c:isRed() and "red")
		if not color then return false end
		player:setTag(self:objectName(), sgs.QVariant(color))
		local to_choose = sgs.SPlayerList()
		for _,p in sgs.qlist(room:getOtherPlayers(player)) do
			if player:distanceTo(p) == 1 then
				to_choose:append(p)
			end
		end
		if to_choose:isEmpty() then return false end
		
		local victim = room:askForPlayerChosen(player, to_choose, self:objectName())
		room:doAnimate(1, player:objectName(), victim:objectName())
		local pattern = ".|" .. color .. "|.|hand$0"
		room:setPlayerFlag(victim, "QianxiRETarget")
		room:addPlayerMark(victim, "@qianxi_" .. color)
		room:setPlayerCardLimitation(victim, "use,response", pattern, false)
		local msg = sgs.LogMessage()
		msg.type, msg.from, msg.arg = "#Qianxi", victim, "no_suit_" .. color
		room:sendLog(msg)
		return false
	end,
}
QianxiREClear = sgs.CreateTriggerSkill{
	name = "#QianxiRE-clear",
	events = {sgs.EventPhaseStart},
	priority = 8,
	global = true,
	on_record = function(self, event, room, player, data)
		if player:getPhase() ~= sgs.Player_NotActive then return false end
		local color = player:getTag("QianxiRE"):toString()
		player:removeTag("QianxiRE")
		if not color or color == "" then return end
		for _,p in sgs.qlist(room:getOtherPlayers(player)) do
			if p:hasFlag("QianxiRETarget") then
				room:removePlayerCardLimitation(p, "use,response", ".|" .. color .. "|.|hand$0")
				room:setPlayerMark(p, "@qianxi_" .. color, 0)
			end
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end
}
MaDai_RE:addSkill(QianxiRE)
MaDai_RE:addSkill(QianxiREClear)
sgs.insertRelatedSkills(extensionRE, "QianxiRE", "#QianxiRE-clear")

--[[
	技能名：马术
	技能：mashu_MaDai_RE
	描述：锁定技，你与其他角色的距离-1。 
	状态：验证通过
]]--
mashu_MaDai_RE = sgs.CreateMashuSkill("MaDai_RE")
MaDai_RE:addSkill(mashu_MaDai_RE)

----------------------------------------------------------------------------------------------------

--[[ RE 006 徐盛
	武将：XuSheng_RE
	武将名：徐盛-RE
	体力上限：4
	武将技能：
		破军：当你于出牌阶段内使用【杀】指定一个目标后，你可以将其一至X张牌扣置于其武将牌旁（X为其体力值），若如此做，当前回合结束后，其获得这些牌。
	状态：验证通过
]]--
XuSheng_RE = sgs.General(extensionRE, "XuSheng_RE", "wu", 4, true)
XuSheng_RE:addCompanion("dingfeng")

--[[
	技能名：破军
	技能：PojunRE
	描述：当你于出牌阶段内使用【杀】指定一个目标后，你可以将其一至X张牌扣置于其武将牌旁（X为其体力值），若如此做，当前回合结束后，其获得这些牌。
	状态：验证通过
]]--
PojunRE = sgs.CreateTriggerSkill{
	name = "PojunRE", 
	can_preshow = true,
	events = {sgs.TargetChosen},
	can_trigger = function(self, event, room, player, data)
		if not (player and player:isAlive() and player:hasSkill(self)) then return "" end
		if player:getPhase() == sgs.Player_Play then
			local use = data:toCardUse()
			if use.card and use.card:isKindOf("Slash") then
				local targets = {}
				for _, p in sgs.qlist(use.to) do
					if not p:isNude() and (p:getHp() > 0) then table.insert(targets, p:objectName()) end
				end
				if #targets > 0 then return self:objectName() .. "->" .. table.concat(targets, "+") end
			end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		local d = sgs.QVariant()
		d:setValue(player)
		ask_who:setTag("PojunRECardUse", data)  --for AI
		if room:askForSkillInvoke(ask_who, self:objectName(), d) then
			room:broadcastSkillInvoke(self:objectName(), ask_who)
			return true
		end
		ask_who:removeTag("PojunRECardUse")
		return false
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		local n = math.min(player:getCards("he"):length(), player:getHp())
		if n <= 0 then return false end
		local num = 1
		if n > 1 then
			local nums = "1"
			for i = 2, n do
				nums = (math.mod(i, 5) == 1) and nums.."|"..i or nums.."+"..i
			end
			num = tonumber(room:askForChoice(ask_who, "PojunRE_num", nums))
		end
		if not num then return false end
		
		local handle_str = {}
		for i = 1, num do
			table.insert(handle_str, "he^false^none")
		end
		local cards = room:askForCardsChosen(ask_who, player, table.concat(handle_str, "|"), self:objectName())
		ask_who:removeTag("PojunRECardUse")
		local dummy = sgs.DummyCard()
		dummy:addSubcards(cards)
		local open_list = sgs.SPlayerList()
		open_list:append(player)
		player:addToPile(self:objectName(), dummy, false, open_list)
		
		local ids = dummy:getSubcards()
		--源码用QVariantMap，而Lua用不了，因此改用字符串：id1+sgs1|id2+sgs3+sgs4|...
		local tab = player:getTag(self:objectName()):toString():split("|")
		table.removeAll(tab, "")
		for i, str in pairs(tab) do
			if ids:contains(tonumber(str:split("+")[1])) then
				ids:removeAll(tonumber(str:split("+")[1]))
				local new_str = str:split("+")
				if not table.contains(new_str, ask_who:objectName()) then table.insert(new_str, ask_who:objectName()) end
				tab[i] = table.concat(new_str, "+")
			end
		end
		if not ids:isEmpty() then
			for _,id in sgs.qlist(ids) do
				table.insert(tab, id .. "+" .. ask_who:objectName())
			end
		end
		player:setTag(self:objectName(), sgs.QVariant(table.concat(tab, "|")))
		dummy:deleteLater() 
	end,
}
PojunREReturn = sgs.CreateTriggerSkill{
	name = "#PojunRE-return",
	frequency = sgs.Skill_Wake,
	global = true,
	events = {sgs.EventPhaseStart},
	can_trigger = function(self, event, room, player, data)  --只处理获得牌（先不清除Tag，因为可能有角色已死亡或者破军牌已经被拿走等奇葩情况）
		if (player:getPhase() == sgs.Player_NotActive) then
			local skill_list, player_list = {}, {}
			for _, p in sgs.qlist(room:getAlivePlayers()) do
				local tab_str = p:getTag("PojunRE"):toString()
				if tab_str and tab_str ~= "" then
					local tab = tab_str:split("|")
					table.removeAll(tab, "")
					for i, str in pairs(tab) do
						local id = tonumber(str:split("+")[1])
						if id and room:getCardPlace(id) == sgs.Player_PlaceSpecial and room:getCardOwner(id) and room:getCardOwner(id):objectName() == p:objectName()
							and #(str:split("+")) == 2 and table.contains(str:split("+"), player:objectName()) then
							if player:isAlive() then
								table.insert(skill_list, player:objectName() .. "'" .. self:objectName())
							else  --将死亡角色设成技能拥有者的话会闪退
								table.insert(skill_list, self:objectName())
							end
							table.insert(player_list, p:objectName())
						end
					end
				end
			end
			return table.concat(skill_list, "|"), table.concat(player_list, "|")
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		return true
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		local tab_str = ask_who:getTag("PojunRE"):toString()
		local dummy = sgs.DummyCard()
		if tab_str and tab_str ~= "" then
			local tab = tab_str:split("|")
			table.removeAll(tab, "")
			for i, str in pairs(tab) do
				local id = tonumber(str:split("+")[1])
				if id and room:getCardPlace(id) == sgs.Player_PlaceSpecial and room:getCardOwner(id) and room:getCardOwner(id):objectName() == ask_who:objectName()
					and #(str:split("+")) == 2 and table.contains(str:split("+"), player:objectName()) then
					dummy:addSubcard(id)
				end
			end
		end
		if dummy:subcardsLength() > 0 then
			local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_EXCHANGE_FROM_PILE, ask_who:objectName(), "PojunRE", "")
			room:obtainCard(ask_who, dummy, reason, false)
			dummy:deleteLater()
		end
	end
}
PojunREClear = sgs.CreateTriggerSkill{
	name = "#PojunRE-clear",
	global = true,
	events = {sgs.EventPhaseStart},
	priority = 1,
	on_record = function(self, event, room, player, data)  --清除Tag
		if (player:getPhase() == sgs.Player_NotActive) then
			local skill_list, player_list = {}, {}
			for _, p in sgs.qlist(room:getAllPlayers(true)) do
				local tab_str = p:getTag("PojunRE"):toString()
				if tab_str and tab_str ~= "" then
					local tab = tab_str:split("|")
					table.removeAll(tab, "")
					for i, str in pairs(tab) do
						local id = tonumber(str:split("+")[1])
						if id and (room:getCardPlace(id) ~= sgs.Player_PlaceSpecial or not room:getCardOwner(id) or room:getCardOwner(id):objectName() ~= p:objectName()) then
							tab[i] = ""
						elseif table.contains(str:split("+"), player:objectName()) then
							local new_str = str:split("+")
							table.removeAll(new_str, player:objectName())
							tab[i] = (#new_str == 1) and "" or table.concat(new_str, "+")
						end
					end
					table.removeAll(tab, "")
					if #tab > 0 then
						p:setTag("PojunRE", sgs.QVariant(table.concat(tab, "|")))
					else
						p:removeTag("PojunRE")
					end
				end
			end
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
XuSheng_RE:addSkill(PojunRE)
XuSheng_RE:addSkill(PojunREReturn)
XuSheng_RE:addSkill(PojunREClear)
sgs.insertRelatedSkills(extensionRE, "PojunRE", "#PojunRE-return", "#PojunRE-clear")

-----------------------------------------------OL专属-----------------------------------------------

extensionOL = sgs.Package("OL", sgs.Package_GeneralPack)

--[[ OL ??? 马云禄
	武将：MaYunLu
	武将名：马云禄
	体力上限：4
	武将技能：
		凤魄：当你于出牌阶段内使用第一张【杀】或【决斗】指定目标后，若目标数为1，你可以选择一项：1. 摸X张牌；2. 此牌伤害值+X（X为目标角色手牌中的方块牌数）。
		马术：锁定技，你与其他角色的距离-1。
	状态：验证通过
]]--
MaYunLu = sgs.General(extensionOL, "MaYunLu", "shu", 4, false)
MaYunLu:addCompanion("zhaoyun")
MaYunLu:addCompanion("machao")
MaYunLu:addCompanion("ZhaoYun_LB")
MaYunLu:addCompanion("MaChao_LB")

--[[
	技能名：凤魄
	技能：Fengpo
	描述：当你于出牌阶段内使用第一张【杀】或【决斗】指定目标后，若目标数为1，你可以选择一项：1. 摸X张牌；2. 此牌伤害值+X（X为目标角色手牌中的方块牌数）。
	状态：验证通过
]]--
FengpoRecord = sgs.CreateTriggerSkill{
	name = "#Fengpo-record", 
	events = {sgs.PreCardUsed, sgs.CardResponded, sgs.EventPhaseChanging},
	global = true,
	on_record = function(self, event, room, player, data)
		if ((event == sgs.PreCardUsed) or (event == sgs.CardResponded)) and (player:getPhase() == sgs.Player_Play) and not player:hasFlag("FengpoRec") then
			local card = nil
			if event == sgs.PreCardUsed then
				card = data:toCardUse().card
			elseif event == sgs.CardResponded then
				local response = data:toCardResponse()
				if response.m_isUse then
					card = response.m_card
				end
			end
			if card and (card:getHandlingMethod() == sgs.Card_MethodUse) and (card:getTypeId() ~= sgs.Card_TypeSkill) then
				if card:isKindOf("Slash") or card:isKindOf("Duel") then
					room:setCardFlag(card, "FengpoRec")
					room:setPlayerFlag(player, "FengpoRec")
				end
			end
		elseif (event == sgs.EventPhaseChanging) and (data:toPhaseChange().to == sgs.Player_Play) then  --todo：验证被明鉴是否会清空
			room:setPlayerFlag(player, "-FengpoRec")
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
Fengpo = sgs.CreateTriggerSkill{
	name = "Fengpo", 
	can_preshow = true,
	events = {sgs.TargetChosen},  --尼玛TargetSpecified改TargetChosen改你个头啊！
	frequency = sgs.Skill_Frequent,
	can_trigger = function(self, event, room, player, data)
		if not (player and player:isAlive() and player:hasSkill(self:objectName())) then return "" end
		local use = data:toCardUse()
		if (getEffectiveTargetNum(use.to) == 1) and use.card and use.card:hasFlag("FengpoRec") then
				if use.to:first():isDead() or use.to:first():isKongcheng() then return "" end
			return self:objectName() .. "->" .. use.to:first():objectName()
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		if room:askForSkillInvoke(ask_who, self:objectName(), data) then
			return true
		end
		return false
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		local use = data:toCardUse()
		local choice = room:askForChoice(ask_who, self:objectName(), "drawCards+addDamage", data)
		room:broadcastSkillInvoke(self:objectName(), (choice == "drawCards") and 1 or 2, ask_who)
		local x = 0
		for _, card in sgs.qlist(player:getHandcards()) do
			if card:getSuit() == sgs.Card_Diamond then 
				x = x + 1
			end
		end
		if choice == "drawCards" then
			ask_who:drawCards(x, self:objectName())
		elseif choice == "addDamage" then
			local msg = sgs.LogMessage()
			if use.card:isVirtualCard() then
				msg.type, msg.from = "#FengpoInvoke", ask_who
				msg.arg = use.card:objectName()
			else
				msg.type, msg.from = "$FengpoInvoke", ask_who
				msg.card_str = use.card:toString()
			end
			room:sendLog(msg)
			local tag = room:getTag("FengpoAddDamage" .. use.card:toString()):toInt()
			if tag then
				tag = tag + x
			else
				tag = x
			end
			room:setTag("FengpoAddDamage" .. use.card:toString(), sgs.QVariant(tag))
		end
	end,
}
FengpoAddDamage = sgs.CreateTriggerSkill{
	name = "#Fengpo-adddamage", 
	events = {sgs.ConfirmDamage, sgs.CardFinished},
	frequency = sgs.Skill_Compulsory,
	on_record = function(self, event, room, player, data)
		if event == sgs.CardFinished then
			local use = data:toCardUse()
			if room:getTag("FengpoAddDamage" .. use.card:toString()) and (room:getTag("FengpoAddDamage" .. use.card:toString()):toInt() > 0) then
				room:removeTag("FengpoAddDamage" .. use.card:toString())
			end
		end
	end,
	can_trigger = function(self, event, room, player, data)
		if event == sgs.ConfirmDamage then
			local damage = data:toDamage()
			if damage.card and damage.from then
				if room:getTag("FengpoAddDamage" .. damage.card:toString()):toInt() then
					local x = room:getTag("FengpoAddDamage" .. damage.card:toString()):toInt()
					if x <= 0 then return "" end
					return self:objectName() .. "->" .. damage.to:objectName()
				end
			end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		return true
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		local damage = data:toDamage()
		local x = room:getTag("FengpoAddDamage" .. damage.card:toString()):toInt()
		local msg = sgs.LogMessage()
		msg.type, msg.from, msg.arg, msg.arg2 = "#FengpoBuff", ask_who, damage.damage, damage.damage + x
		room:sendLog(msg)
		damage.damage = damage.damage + x
		data:setValue(damage)
		room:removeTag("FengpoAddDamage" .. damage.card:toString())
	end,
}
MaYunLu:addSkill(Fengpo)
MaYunLu:addSkill(FengpoRecord)
MaYunLu:addSkill(FengpoAddDamage)
sgs.insertRelatedSkills(extensionOL, "Fengpo", "#Fengpo-record", "#Fengpo-adddamage")

--[[
	技能名：马术
	技能：mashu_MaYunLu
	描述：锁定技，你与其他角色的距离-1。 
	状态：验证通过
]]--
mashu_MaYunLu = sgs.CreateMashuSkill("MaYunLu")
MaYunLu:addSkill(mashu_MaYunLu)

----------------------------------------------------------------------------------------------------

--[[ OL 00X 兀突骨
	武将：WuTuGu
	武将名：兀突骨
	体力上限：4
	武将技能：
		燃殇：锁定技，当你首次明置此武将牌后，你加X点体力上限，然后回复X点体力（X为15-你的体力上限）；当你受到1点火焰伤害后，你获得1枚“燃”标记；结束阶段开始时，你失去Y点体力（Y为“燃”标记数）。
		悍勇：当你使用【南蛮入侵】或【万箭齐发】时，若你的体力值小于轮数，你可以令此牌的伤害值基数+1。
	状态：验证通过
]]--
WuTuGu = sgs.General(extensionOL, "WuTuGu", "qun", 4, true)

--[[
	技能名：燃殇
	技能：Ranshang
	描述：锁定技，当你首次明置此武将牌后，你加X点体力上限，然后回复X点体力（X为15-你的体力上限）；当你受到1点火焰伤害后，你获得1枚“燃”标记；结束阶段开始时，你失去Y点体力（Y为“燃”标记数）。
	状态：验证通过
]]--
Ranshang = sgs.CreateTriggerSkill{
	name = "Ranshang",
	can_preshow = true,
	frequency = sgs.Skill_Compulsory,
	events = {sgs.GeneralShown, sgs.DFDebut, sgs.Damaged, sgs.EventPhaseStart},
	can_trigger = function(self, event, room, player, data)
		if not (player and player:isAlive() and player:hasSkill(self:objectName())) then return "" end
		if (event == sgs.GeneralShown) and (player:getMark(self:objectName()) == 0) then
			return (data:toBool() == player:inHeadSkills(self:objectName())) and self:objectName() or ""
		elseif (event == sgs.DFDebut) and (player:getMark(self:objectName()) == 0) then
			return self:objectName()
		elseif event == sgs.Damaged then
			local damage = data:toDamage()
			if damage.nature == sgs.DamageStruct_Fire then
				local trigger_list = {}
				for i = 1, damage.damage, 1 do
					table.insert(trigger_list, self:objectName())
				end
				return table.concat(trigger_list, ",")
			end
		elseif event == sgs.EventPhaseStart and player:getPhase() == sgs.Player_Finish and player:getMark("@ranshang") > 0 then
			return self:objectName()
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		if (event == sgs.DFDebut) or (event == sgs.GeneralShown) then
			room:setPlayerMark(player, self:objectName(), 1)
			return true
		end
		if player:hasShownSkill(self:objectName()) or player:askForSkillInvoke(self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), (event == sgs.Damaged) and 1 or ((event == sgs.EventPhaseStart) and 2 or -1), player)
			return true
		end
		return false
	end,
	on_effect = function(self, event, room, player, data)
		room:sendCompulsoryTriggerLog(player, self:objectName(), true)
		if event == sgs.Damaged then
			player:gainMark("@ranshang", 1)
		elseif event == sgs.EventPhaseStart then
			room:loseHp(player, player:getMark("@ranshang"))
		elseif (event == sgs.DFDebut) or (event == sgs.GeneralShown) then
			local x = 15 - player:getMaxHp()
			if x <= 0 then return end
			room:setPlayerProperty(player, "maxhp", sgs.QVariant(player:getMaxHp() + x))
			local recover = sgs.RecoverStruct()
			recover.recover, recover.who = x, player
			room:recover(player, recover)
		end
		return false
	end,
}
WuTuGu:addSkill(Ranshang)

--[[
	技能名：悍勇
	技能：Hanyong
	描述：当你使用【南蛮入侵】或【万箭齐发】时，若你的体力值小于轮数，你可以令此牌的伤害值基数+1。
	状态：验证通过
]]--
HanyongTurnCount = sgs.CreateTriggerSkill{
	name = "#Hanyong-turncount",  --轮数不包括额外回合，而神杀的Global_TurnCount包括，因此需要手动清除
	events = {sgs.TurnStart, sgs.ChoiceMade},
	global = true,
	priority = -1,  --此时机在GameRule中的player->play之后，在通过ExtraTurnList获得额外回合玩家之前，可用来检测额外回合
	on_record = function(self, event, room, player, data)
		if event == sgs.TurnStart then
			local extraTurnList = room:getTag("ExtraTurnList"):toStringList()
			local extraTurnPlayerName = extraTurnList[1]
			local extraTurnPlayer = room:findPlayer(extraTurnPlayerName)
			if extraTurnPlayer then
				extraTurnPlayer:addMark("HanyongExtraTurnCount")
			end
		elseif event == sgs.ChoiceMade then  --单独记录飞龙夺凤（revivePlayer会导致所有Mark全部清除）
			if player:isDead() then
				local data_str = data:toString():split(":")
				if (#data_str == 3) and (data_str[1] == "skillInvoke") and (data_str[2] == "DragonPhoenix") and (data_str[3] == "yes") then
					local old = player:property("HanyongDragonPhoenixTurnCount"):toInt()
					room:setPlayerProperty(player, "HanyongDragonPhoenixTurnCount", sgs.QVariant(player:getMark("Global_TurnCount") - player:getMark("HanyongExtraTurnCount") + old))
				end
			end
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
Hanyong = sgs.CreateTriggerSkill{
	name = "Hanyong",
	can_preshow = true,
	events = {sgs.CardUsed, sgs.TurnStart, sgs.GeneralShown},
	on_record = function(self, event, room, player, data)
		if event == sgs.TurnStart then
			local turn_count = player:getMark("Global_TurnCount") - player:getMark("HanyongExtraTurnCount") + player:property("HanyongDragonPhoenixTurnCount"):toInt() + 1  --+1是因为在priority=3时发动，此时还没有通过GameRule加上这回合
			for _,wutugu in sgs.qlist(room:getAllPlayers()) do
				if wutugu:hasShownSkill(self) then
					room:setPlayerMark(wutugu, "@clock_time", turn_count)
				elseif wutugu:hasSkill(self) then
					wutugu:setMark("@clock_time", turn_count)
					local arg = {
						wutugu:objectName(), 
						"@clock_time", 
						turn_count,
					}
					room:doNotify(wutugu, sgs.CommandType.S_COMMAND_SET_MARK, json.encode(arg))
				end
			end
		elseif (event == sgs.GeneralShown) and player:hasSkill(self) and (data:toBool() == player:inHeadSkills(self:objectName())) then
			if player:getMark("@clock_time") == 0 then return end
			room:setPlayerMark(player, "@clock_time", player:getMark("@clock_time"))
		end
	end,
	can_trigger = function(self, event, room, player, data)
		if not (player and player:isAlive() and player:hasSkill(self:objectName())) then return "" end
		if event == sgs.CardUsed then
			local use = data:toCardUse()
			if (use.card:isKindOf("SavageAssault") or use.card:isKindOf("ArcheryAttack")) then
				local first
				for _,p in sgs.qlist(room:getAllPlayers()) do
					if p:getSeat() == 1 then
						first = p
						break
					end
				end
				if player:getHp() < first:getMark("Global_TurnCount") - first:getMark("HanyongExtraTurnCount") + first:property("HanyongDragonPhoenixTurnCount"):toInt() then
					return self:objectName()
				end
			end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		if player:askForSkillInvoke(self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), player)
			return true
		end
		return false
	end,
	on_effect = function(self, event, room, player, data)
		local use = data:toCardUse()
		room:setCardFlag(use.card, "HanyongAddDamage")
		return false
	end,
}
HanyongAddDamage = sgs.CreateTriggerSkill{
	name = "#Hanyong-adddamage",
	events = {sgs.ConfirmDamage},
	frequency = sgs.Skill_Wake,
	global = true,
	on_record = function(self, event, room, player, data)
		if not player or player:isDead() then  --由于不明原因，隙仇死亡后无法执行此技能的on_cost，先这样修
			local damage = data:toDamage()
			if damage.card and damage.card:hasFlag("HanyongAddDamage") then
				local msg = sgs.LogMessage()
				msg.type, msg.from, msg.arg, msg.arg2 = "#HanyongBuff", damage.from, damage.damage, damage.damage + 1
				room:sendLog(msg)
				damage.damage = damage.damage + 1
				data:setValue(damage)
			end
		end
	end,
	can_trigger = function(self, event, room, player, data)
		if player and player:isAlive() then
			local damage = data:toDamage()
			if damage.card and damage.card:hasFlag("HanyongAddDamage") then
				return self:objectName()
			end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		return true
	end,
	on_effect = function(self, event, room, player, data)
		local damage = data:toDamage()
		local msg = sgs.LogMessage()
		msg.type, msg.from, msg.arg, msg.arg2 = "#HanyongBuff", damage.from, damage.damage, damage.damage + 1
		room:sendLog(msg)
		damage.damage = damage.damage + 1
		data:setValue(damage)
	end,
}
WuTuGu:addSkill(Hanyong)
WuTuGu:addSkill(HanyongTurnCount)
WuTuGu:addSkill(HanyongAddDamage)
sgs.insertRelatedSkills(extensionOL, "Hanyong", "#Hanyong-turncount", "#Hanyong-adddamage")

----------------------------------------------------------------------------------------------------

--[[ OL ??? 王基
	武将：WangJi
	武将名：王基
	体力上限：3
	武将技能：
		奇制：当你于回合内使用基本牌或锦囊牌指定目标后，你可以选择一名不是此牌目标的角色，弃置其一张牌，然后其摸一张牌。
		进趋：结束阶段开始时，你可以摸两张牌，然后将手牌弃置至X张（X为此回合内你发动“奇制”的次数）。
	状态：验证通过
]]--
WangJi = sgs.General(extensionOL, "WangJi", "wei", 3, true)

--[[
	技能名：奇制
	技能：Qizhi
	描述：当你于回合内使用基本牌或锦囊牌指定目标后，你可以选择一名不是此牌目标的角色，弃置其一张牌，然后其摸一张牌。
	状态：验证通过
]]--
Qizhi = sgs.CreateTriggerSkill{
	name = "Qizhi",
	can_preshow = true,
	events = {sgs.TargetChosen},
	frequency = sgs.Skill_NotFrequent,
	can_trigger = function(self, event, room, player, data)
		if not player or player:isDead() or not player:hasSkill(self) then return "" end
		if player:getPhase() == sgs.Player_NotActive then return false end
		local use = data:toCardUse()
		if not use.card or not use.from or player:objectName() ~= use.from:objectName() then return "" end
		if use.card:isKindOf("TrickCard") or use.card:isKindOf("BasicCard") then
			for _ , p in sgs.qlist(room:getAlivePlayers()) do
				if not use.to:contains(p) and player:canDiscard(p, "he") then
					return self:objectName()
				end
			end
		end
	end,	
	on_cost = function(self, event, room, player, data)
		local use = data:toCardUse()
		local targets = sgs.SPlayerList()
		for _ , p in sgs.qlist(room:getAlivePlayers()) do
			if not use.to:contains(p) and player:canDiscard(p, "he") then
				targets:append(p)
			end
		end
		local target = room:askForPlayerChosen(player, targets, self:objectName(), "Qizhi-choice:::" .. use.card:objectName(), true, true)
		if target then
			room:broadcastSkillInvoke(self:objectName(), player)
			local d = sgs.QVariant()
			d:setValue(target)
			player:setTag("Qizhieffect", d)
			return true
		end
	end,	
	on_effect = function(self, event, room, player, data)
		room:addPlayerMark(player, "@Qizhi")
		local target = player:getTag("Qizhieffect"):toPlayer()
		player:removeTag("Qizhieffect")
		local to_throw = room:askForCardChosen(player, target, "he", self:objectName(), false, sgs.Card_MethodDiscard)
		local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_DISMANTLE, player:objectName(), target:objectName(), self:objectName(), nil)
		room:throwCard(sgs.Sanguosha:getCard(to_throw), reason, target, player)
		target:drawCards(1, self:objectName())
	end,
	on_turn_broken = function(self, function_name, event, room, player, data, ask_who)
		player:removeTag("Qizhieffect")
	end
}
QizhiClear = sgs.CreateTriggerSkill{
	name = "#Qizhi-clear",
	events = {sgs.EventPhaseStart},
	priority = 8,
	global = true,
	on_record = function(self, event, room, player, data)
		if player:getPhase() == sgs.Player_NotActive then
			room:setPlayerMark(player, "@Qizhi", 0)
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
WangJi:addSkill(Qizhi)
WangJi:addSkill(QizhiClear)
sgs.insertRelatedSkills(extensionOL, "Qizhi", "#Qizhi-clear")

--[[
	技能名：进趋
	技能：Jinqu
	描述：结束阶段开始时，你可以摸两张牌，然后将手牌弃置至X张（X为此回合内你发动“奇制”的次数）。
	状态：验证通过
]]--
Jinqu = sgs.CreatePhaseChangeSkill{
	name = "Jinqu",
	can_preshow = true,
	frequency = sgs.Skill_NotFrequent,
	can_trigger = function(self, event, room, player, data)
		if player and player:isAlive() and player:hasSkill(self) then
			if player:getPhase() == sgs.Player_Finish then 
				return self:objectName()
			end	
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		local x = player:getMark("@Qizhi")
		if room:askForSkillInvoke(player, self:objectName(), sgs.QVariant("HandNumMax:::" .. player:getMark("@Qizhi"))) then
			return true 
		end
		return false 
	end,
	on_phasechange = function(self, player)
		local room = player:getRoom()
		player:drawCards(2, self:objectName())
		local x = player:getMark("@Qizhi")
		local y = player:getHandcardNum()
		if y > x then
			room:broadcastSkillInvoke(self:objectName(), 1, player)
			room:askForDiscard(player, self:objectName(), y - x, y - x)
		elseif y <= x then
			room:broadcastSkillInvoke(self:objectName(), 2, player)
		end
		return false 
	end,
}
WangJi:addSkill(Jinqu)

----------------------------------------------------------------------------------------------------

--[[ OL ??? 蹋顿
	武将：TaDun
	武将名：蹋顿
	体力上限：4
	武将技能：
		乱战：当一名角色因受到伤害而扣减体力前，若来源为你，你获得1枚“乱战”标记；你使用【杀】或黑色普通锦囊牌可以多选择一至X名目标；当你使用【杀】或黑色普通锦囊牌指定目标后，若目标数小于X，你弃所有“乱战”标记。（X为“乱战”标记数）
	状态：验证通过
]]--
TaDun = sgs.General(extensionOL, "TaDun", "qun", 4, true)

--[[
	技能名：乱战
	技能：Luanzhan
	描述：当一名角色因受到伤害而扣减体力前，若来源为你，你获得1枚“乱战”标记；你使用【杀】或黑色普通锦囊牌可以多选择一至X名目标；当你使用【杀】或黑色普通锦囊牌指定目标后，若目标数小于X，你弃所有“乱战”标记。（X为“乱战”标记数）
	状态：验证通过
]]--
ExtraAllianceFeastCard = sgs.CreateSkillCard{
	name = "ExtraAllianceFeastCard",
	filter = function(self, targets, to_select, player)
		local af = sgs.Card_Parse(player:property("extra_af"):toString())
		if (not af) then return false end
		local tos = player:property("extra_af_current_targets"):toString():split("+")
		if table.contains(tos, to_select:objectName()) or player:isProhibited(to_select, af) or not af:targetFilter(sgs.PlayerList(), to_select, player) then return false end  --注意targetFilter必须留空
		for _,to in sgs.qlist(player:getAliveSiblings()) do
			if table.contains(tos, to:objectName()) then
				if to:isFriendWith(to_select) then return false end
			end
		end
		for _,target in ipairs(targets) do
			if to_select:isFriendWith(target) then return false end
		end
		
		local max_targets = player:getMark("LuanzhanCount")
		local new_chosen_targets = table.copyFrom(targets)
		table.insert(new_chosen_targets, to_select)
		local new_effective_targets = {}
		for _,target in ipairs(new_chosen_targets) do
			table.insert(new_effective_targets, target)
			for _,liege in sgs.qlist(player:getAliveSiblings()) do
				if target:isFriendWith(liege) and liege ~= target and not player:isProhibited(liege, af) then
					table.insert(new_effective_targets, liege)
				end
			end
		end
		return #new_effective_targets <= max_targets
	end,
	about_to_use = function(self, room, cardUse)
		for _,p in sgs.qlist(cardUse.to) do
			p:setFlags("ExtraAllianceFeastTarget")
			for _,p2 in sgs.qlist(room:getLieges(p:getKingdom(), p)) do
				if not cardUse.from:isProhibited(p2, cardUse.card) then
					p2:setFlags("ExtraAllianceFeastTarget")
				end
			end
		end
	end
}
LuanzhanVS = sgs.CreateZeroCardViewAsSkill{
	name = "Luanzhan",
	view_as = function(self)
		if sgs.Sanguosha:getCurrentCardUsePattern() == "@@Luanzhan1" then
			return ExtraCollateralCard:clone()
		elseif sgs.Sanguosha:getCurrentCardUsePattern() == "@@Luanzhan2" then
			return ExtraAllianceFeastCard:clone()
		end
	end,
	enabled_at_play = function(self, player)
		return false
	end,
	enabled_at_response = function(self, player, pattern)
		return string.find(pattern, "@@Luanzhan")
	end,
}
Luanzhan = sgs.CreateTriggerSkill{
	name = "Luanzhan",
	can_preshow = true,
	events = {sgs.PreCardUsed},
	view_as_skill = LuanzhanVS,
	can_trigger = function(self, event, room, player, data)
		if not (player and player:isAlive() and player:hasSkill(self)) then return "" end
		if player:getMark("LuanzhanCount") <= 0 then return "" end
		local use = data:toCardUse()
		if use.card:isNDTrick() and use.card:isBlack() and (use.card:isKindOf("ExNihilo") or use.card:isKindOf("Collateral") or use.card:isKindOf("ThreatenEmperor") or use.card:isKindOf("AllianceFeast")) then
			local available_targets = sgs.VariantList()
			local dat = sgs.QVariant()
			for _, p in sgs.qlist(room:getAlivePlayers()) do
				if (use.to:contains(p) or player:isProhibited(p, use.card)) then continue end
				if (use.card:targetFixed()) then
					if use.card:isAvailable(p) then
						dat = sgs.QVariant()
						dat:setValue(p)
						available_targets:append(dat)
					end
				elseif not use.card:isKindOf("AllianceFeast") then
					if (use.card:targetFilter(sgs.PlayerList(), p, player)) then
						dat = sgs.QVariant()
						dat:setValue(p)
						available_targets:append(dat)
					end
				elseif use.card:isKindOf("AllianceFeast") and use.card:targetFilter(sgs.PlayerList(), p, player) then  --联军盛宴只能选择目标数不大于X的势力
					local same_kingdom_targets = sgs.SPlayerList()
					same_kingdom_targets:append(p)
					for _,p2 in sgs.qlist(room:getLieges(p:getKingdom(), p)) do  --getLieges还能这样用……
						if not player:isProhibited(p2, use.card) then
							same_kingdom_targets:append(p2)
						end
					end
					if same_kingdom_targets:length() <= player:getMark("LuanzhanCount") then
						dat = sgs.QVariant()
						dat:setValue(p)
						available_targets:append(dat)
					end
				end
			end
			if available_targets:isEmpty() then return "" end
			player:setTag("LuanzhanAvailableTargets", sgs.QVariant(available_targets))
			return self:objectName()
		end
	end,
	on_cost = function(self, event, room, player, data)
		local use = data:toCardUse()
		local available_targets_qvar = player:getTag("LuanzhanAvailableTargets"):toList()
		player:removeTag("LuanzhanAvailableTargets")
		local extras = sgs.SPlayerList()
		local available_targets = sgs.SPlayerList()
		for _,qvar in sgs.qlist(available_targets_qvar) do
			available_targets:append(qvar:toPlayer())
		end
		if not use.card:isKindOf("Collateral") and not use.card:isKindOf("AllianceFeast") then
			local dat = sgs.QVariant()
			dat:setValue(use)
			player:setTag("LuanzhanCardUse", dat)  --for AI
			extras = room:askForPlayersChosen(player, available_targets, "LuanzhanTarget", 0, player:getMark("LuanzhanCount"), "@Luanzhan-add:::" .. use.card:objectName() .. ":" .. player:getMark("LuanzhanCount"))
			player:removeTag("LuanzhanCardUse")
		elseif use.card:isKindOf("Collateral") then
			local tos = {}
			for _, t in sgs.qlist(use.to) do
				table.insert(tos, t:objectName())
			end
			local extra = nil
			for i = 1, player:getMark("LuanzhanCount") do
				extra = nil
				room:setPlayerProperty(player, "extra_collateral", sgs.QVariant(use.card:toString()))
				room:setPlayerProperty(player, "extra_collateral_current_targets", sgs.QVariant(table.concat(tos, "+")))
				room:askForUseCard(player, "@@Luanzhan1", "@Luanzhan-add:::collateral:" .. player:getMark("LuanzhanCount") - extras:length(), 1)  --index本来是给配音用的（？），但是不这样加的话会导致~Luanzhan1变成~Luanzhan
				room:setPlayerProperty(player, "extra_collateral", sgs.QVariant(""))
				room:setPlayerProperty(player, "extra_collateral_current_targets", sgs.QVariant("+"))
				for _, p in sgs.qlist(room:getOtherPlayers(player)) do
					if p:hasFlag("ExtraCollateralTarget") then
						p:setFlags("-ExtraCollateralTarget")
						extra = p
						break
					end
				end
				if (extra == nil) then break end
				extras:append(extra)
				table.insert(tos, extra:objectName())
				available_targets:removeAll(extra)
				if available_targets:isEmpty() then break end
			end
		elseif use.card:isKindOf("AllianceFeast") then
			local tos = {}
			for _, t in sgs.qlist(use.to) do
				table.insert(tos, t:objectName())
			end
			room:setPlayerProperty(player, "extra_af", sgs.QVariant(use.card:toString()))
			room:setPlayerProperty(player, "extra_af_current_targets", sgs.QVariant(table.concat(tos, "+")))
			room:askForUseCard(player, "@@Luanzhan2", "@Luanzhan-add:::alliance_feast:" .. player:getMark("LuanzhanCount"), 2)
			room:setPlayerProperty(player, "extra_af", sgs.QVariant(""))
			room:setPlayerProperty(player, "extra_af_current_targets", sgs.QVariant("+"))
			for _, p in sgs.qlist(room:getOtherPlayers(player)) do
				if p:hasFlag("ExtraAllianceFeastTarget") then
					p:setFlags("-ExtraAllianceFeastTarget")
					extras:append(p)
				end
			end
		end
		if extras:isEmpty() then return false end
		room:sortByActionOrder(extras)
		local extras_qvar = sgs.VariantList()
		for _,p in sgs.qlist(extras) do
			dat = sgs.QVariant()
			dat:setValue(p)
			extras_qvar:append(dat)
		end
		player:setTag("Luanzhan_invoke", sgs.QVariant(extras_qvar))
		room:broadcastSkillInvoke(self:objectName(), player)
		return true
	end,
	on_effect = function(self, event, room, player, data)
		local use = data:toCardUse()
		local extras_qvar = player:getTag("Luanzhan_invoke"):toList()
		player:removeTag("Luanzhan_invoke")
		local extra
		local extras = sgs.SPlayerList()  --For LogMessage
		for _,extra_qvar in sgs.qlist(extras_qvar) do
			extra = extra_qvar:toPlayer()
			if not extra then continue end
			use.to:append(extra)
			extras:append(extra)
			room:sortByActionOrder(use.to)
			room:doAnimate(1, player:objectName(), extra:objectName())
		end
		local msg = sgs.LogMessage()
		if use.card:isVirtualCard() then
			msg.type, msg.from, msg.arg2, msg.arg = "#LuanzhanAdd", player, use.card:objectName(), self:objectName()
		else
			msg.type, msg.from, msg.card_str, msg.arg = "$LuanzhanAdd", player, use.card:toString(), self:objectName()
		end
		msg.to = extras
		room:sendLog(msg)
		if use.card:isKindOf("Collateral") then
			for _,extra in sgs.qlist(extras) do
				local victim = extra:getTag("collateralVictim"):toPlayer()
				if victim then
					msg = sgs.LogMessage()
					msg.type, msg.from = "#CollateralSlash", player
					msg.to:append(victim)
					room:sendLog(msg)
					room:doAnimate(1, extra:objectName(), victim:objectName())
				end
			end
		end
		data:setValue(use)
		return false
	end,
	on_turn_broken = function(self, function_name, event, room, player, data)
		player:removeTag("Luanzhan_invoke")
		player:removeTag("LuanzhanAvailableTargets")
	end
}
LuanzhanMark = sgs.CreateTriggerSkill{
	name = "#Luanzhan-mark", 
	events = {sgs.PreDamageDone},
	frequency = sgs.Skill_Compulsory,
	can_trigger = function(self, event, room, player, data)
		local damage = data:toDamage()
		if damage.from and damage.from:isAlive() and damage.from:hasSkill(self) then
			return self:objectName(), damage.from
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		if ask_who:hasShownSkill(self) or room:askForSkillInvoke(ask_who, "Luanzhan", sgs.QVariant("Mark")) then
			room:broadcastSkillInvoke("Luanzhan", ask_who)
			ask_who:showGeneral(ask_who:inHeadSkills("Luanzhan"))
			return true
		end
		return false
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		room:addPlayerMark(ask_who, "LuanzhanCount")
		ask_who:gainMark("@luanz")
	end,
}
LuanzhanZero = sgs.CreateTriggerSkill{
	name = "#Luanzhan-zero", 
	events = {sgs.TargetChosen},
	frequency = sgs.Skill_Compulsory,
	can_trigger = function(self, event, room, player, data)
		if not (player and player:isAlive() and player:hasSkill(self)) then return "" end
		if event == sgs.TargetChosen then
			local use = data:toCardUse()
			if use.card and (use.card:isKindOf("Slash") or (use.card:isNDTrick() and use.card:isBlack())) and (getEffectiveTargetNum(use.to) < player:getMark("LuanzhanCount")) then
				return self:objectName()
			end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		if player:hasShownSkill(self) or room:askForSkillInvoke(player, "Luanzhan", sgs.QVariant("Zero")) then
			player:showGeneral(player:inHeadSkills("Luanzhan"))
			return true
		end
		return false
	end,
	on_effect = function(self, event, room, player, data)
		room:setPlayerMark(player, "LuanzhanCount", 0)
		player:loseAllMarks("@luanz")
	end,
}
LuanzhanTargetMod = sgs.CreateTargetModSkill{
	name = "#Luanzhan-target", 
	pattern = "TrickCard+^DelayedTrick|black#Slash",
	extra_target_func = function(self, from, card)
		if from:hasSkill("Luanzhan") then
			return from:getMark("LuanzhanCount")
		else
			return 0
		end
	end
}
TaDun:addSkill(Luanzhan)
TaDun:addSkill(LuanzhanMark)
TaDun:addSkill(LuanzhanZero)
TaDun:addSkill(LuanzhanTargetMod)
sgs.insertRelatedSkills(extensionOL, "Luanzhan", "#Luanzhan-mark", "#Luanzhan-zero", "#Luanzhan-target")

----------------------------------------------------------------------------------------------------

--[[ OL ??? 严白虎
	武将：YanBaiHu
	武将名：严白虎
	体力上限：4
	武将技能：
		雉盗：锁定技，当你于出牌阶段内对一名其他角色造成伤害后，若此伤害是你本回合造成的第一次伤害，且该角色的区域内有牌，你获得其所有区域内的各一张牌，若如此做，当你于此回合内使用牌时，你取消除你外的目标。
		寄篱：锁定技，当其他角色成为红色基本牌或红色普通锦囊牌的目标时，若该角色与你的距离为1，且你不是此牌的使用者或目标，你也成为此牌的目标。
	状态：验证通过
]]--
YanBaiHu = sgs.General(extensionOL, "YanBaiHu", "qun", 4, true)

--[[
	技能名：雉盗
	技能：Zhidao
	描述：锁定技，当你于出牌阶段内对一名其他角色造成伤害后，若此伤害是你本回合造成的第一次伤害，且该角色的区域内有牌，你获得其所有区域内的各一张牌，若如此做，当你于此回合内使用牌时，你取消除你外的目标。
	状态：验证通过
	注：需要用到惴恐中的sgs.CreateCancelOtherTargetsSkill函数
]]--
Zhidao = sgs.CreateTriggerSkill{
	name = "Zhidao", 
	can_preshow = true,
	frequency = sgs.Skill_Compulsory, 
	events = {sgs.Damage}, 
	can_trigger = function(self, event, room, player, data)
		if player:getPhase() ~= sgs.Player_NotActive and player:hasFlag("ZhidaoStackOpened") and not player:hasFlag("ZhidaoStackClosed") then  --条件B
			local damage = data:toDamage()
			local ZhidaoStack = player:getTag("ZhidaoStack"):toList()
			if not ZhidaoStack or ZhidaoStack:isEmpty() then return "" end
			
			if player:isAlive() and player:hasSkill(self) and (player:getPhase() == sgs.Player_Play) and player:getTag("ZhidaoPopIndex"):toInt() ~= ZhidaoStack:length() then
				local damage2 = ZhidaoStack:at(ZhidaoStack:length() - 1):toDamage()
				if damage.to:objectName() ~= damage2.to:objectName() then return "" end  --象征性地验证是否match（实际上因为堆栈原理肯定是一样的）
				if damage.to and damage.to:isAlive() and not damage.to:isAllNude() and (damage.to:objectName() ~= player:objectName()) then
					return self:objectName() .. "->" .. damage.to:objectName()
				end
			end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		local ZhidaoStack = ask_who:getTag("ZhidaoStack"):toList()
		ask_who:setTag("ZhidaoPopIndex", sgs.QVariant(ZhidaoStack:length()))
		
		if ask_who:hasShownSkill(self:objectName()) or room:askForSkillInvoke(ask_who, self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), ask_who)
			return true
		end
		return false
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		room:sendCompulsoryTriggerLog(ask_who, self:objectName(), true)
		local cards_chosen_list = {}
		if not player:isKongcheng() then  --to be replaced with canGetCard
			table.insert(cards_chosen_list, "h^false^none")  --to be replaced with "get"
		end
		if player:getEquips():length() > 0 then
			table.insert(cards_chosen_list, "e^false^none")
		end
		if player:getJudgingArea():length() > 0 then
			table.insert(cards_chosen_list, "j^false^none")
		end
		if next(cards_chosen_list) ~= nil then
			local cards = room:askForCardsChosen(ask_who, player, table.concat(cards_chosen_list, "|"), self:objectName())
			local dummy = sgs.DummyCard()
			dummy:addSubcards(cards)
			room:obtainCard(ask_who, dummy, sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_EXTRACTION, ask_who:objectName(), self:objectName(), ""), false)
			dummy:deleteLater()
		end
		if ask_who:isAlive() then room:setPlayerFlag(ask_who, "DisableOtherTargets") end
	end,
}
ZhidaoRecord = sgs.CreateTriggerSkill{
	name = "#Zhidao-record",
	events = {sgs.PreDamageDone, sgs.Damage},
	priority = 1,
	global = true,
 	on_record = function(self, event, room, player, data)
		if not (player and player:isAlive()) then return end
		if event == sgs.PreDamageDone then
			local damage = data:toDamage()
			if damage.from and (damage.from:getPhase() ~= sgs.Player_NotActive) then  --条件A（注意出牌阶段的限制要放到条件B内部）
				local ZhidaoStack = damage.from:getTag("ZhidaoStack"):toList()
				if not ZhidaoStack or ZhidaoStack:isEmpty() then
					if damage.from:hasFlag("ZhidaoStackOpened") then return end  --条件A延续（保证每回合只会新开一个栈）
					ZhidaoStack = sgs.VariantList()
				end
				ZhidaoStack:append(data)
				damage.from:setTag("ZhidaoStack", sgs.QVariant(ZhidaoStack))
				room:setPlayerFlag(damage.from, "ZhidaoStackOpened")
			end
		elseif event == sgs.Damage then
			if player:getPhase() ~= sgs.Player_NotActive and player:hasFlag("ZhidaoStackOpened") and not player:hasFlag("ZhidaoStackClosed") then  --条件B
				local damage = data:toDamage()
				local ZhidaoStack = player:getTag("ZhidaoStack"):toList()
				if not ZhidaoStack or ZhidaoStack:isEmpty() then return end
				
				ZhidaoStack:removeAt(ZhidaoStack:length() - 1)
				if not ZhidaoStack:isEmpty() then
					player:setTag("ZhidaoStack", sgs.QVariant(ZhidaoStack))
				else
					room:setPlayerFlag(player, "ZhidaoStackClosed")
					player:removeTag("ZhidaoStack")
				end
				player:removeTag("ZhidaoPopIndex")
			end
		end
	end,
 	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
--[[zhidaomod = sgs.CreateProhibitSkill{
	name = "#zhidaomod", 
	is_prohibited = function(self, from, to, card)
		return from:hasSkill(self:objectName()) and not card:isKindOf("SkillCard") and from:objectName() ~= to:objectName() and from:getMark("zhidao_Play") ~= 0
	end
}]]
YanBaiHu:addSkill(Zhidao)
YanBaiHu:addSkill(ZhidaoRecord)
sgs.insertRelatedSkills(extensionOL, "Zhidao", "#Zhidao-record")

--[[
	技能名：寄篱
	技能：JiliYBH
	描述：锁定技，当其他角色成为红色基本牌或红色普通锦囊牌的目标时，若该角色与你的距离为1，且你不是此牌的使用者或目标，你也成为此牌的目标。
	状态：验证通过
]]--
JiliYBH = sgs.CreateTriggerSkill{
	name = "JiliYBH", 
	frequency = sgs.Skill_Compulsory, 
	events = {sgs.TargetConfirming}, 
	can_trigger = function(self, event, room, player, data)
		local use = data:toCardUse()
		local card = use.card
		if card and card:isRed() and (card:isKindOf("BasicCard") or card:isNDTrick()) and use.to:contains(player) and player:isAlive() then
			local skill_list = {}
			local player_list = {}
			for _, yanbaihu in sgs.qlist(room:findPlayersBySkillName(self:objectName())) do
				if (player:distanceTo(yanbaihu) == 1) and (not use.from or use.from:objectName() ~= yanbaihu:objectName()) and (not use.to:contains(yanbaihu)) then
					table.insert(skill_list, self:objectName())
					table.insert(player_list, yanbaihu:objectName())
				end
			end
			return table.concat(skill_list, "|"), table.concat(player_list, "|")
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		if ask_who:hasShownSkill(self:objectName()) or room:askForSkillInvoke(ask_who, self:objectName(), data) then
			local n = 1
			if data:toCardUse().card:isKindOf("Peach") or data:toCardUse().card:isKindOf("ExNihilo") or data:toCardUse().card:isKindOf("Analeptic") or data:toCardUse().card:isKindOf("AwaitExhausted") or data:toCardUse().card:isKindOf("ThreatenEmperor") or data:toCardUse().card:isKindOf("BefriendAttacking") or data:toCardUse().card:isKindOf("AllianceFeast") then
				n = 2
			end
			room:broadcastSkillInvoke(self:objectName(), n, ask_who)
			return true
		end
		return false
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		room:sendCompulsoryTriggerLog(ask_who, self:objectName(), true)
		local use = data:toCardUse()
		use.to:append(ask_who)
		room:sortByActionOrder(use.to)
		local msg = sgs.LogMessage()
		if use.card:isVirtualCard() then
			msg.type, msg.from = "#BecomeTarget", ask_who
			msg.arg = use.card:objectName()
		else
			msg.type, msg.from = "$BecomeTarget", ask_who
			msg.card_str = use.card:toString()
		end
		room:sendLog(msg)
		room:doAnimate(1, use.from:objectName(), ask_who:objectName())
		if use.card:isKindOf("Analeptic") and not ask_who:hasFlag("Global_Dying") then
			room:setCardFlag(use.card, "JiliYBHAffected")  --For JiliTBHAnaleptic
			room:setPlayerFlag(ask_who, "JiliYBHAffected" .. use.card:toString())  --For JiliTBHAnaleptic
		end
		
		--[[if use.card:isKindOf("Collateral") then  --设计本意借刀严白虎不能选目标
			local prompt = "@JiliYBHCollateral:" .. ask_who:objectName()
			local coll_targets = sgs.PlayerList()
			coll_targets:append(ask_who)
			local slash_targets = sgs.SPlayerList()
			for _,p in sgs.qlist(room:getOtherPlayers(ask_who)) do
				if use.card:targetFilter(coll_targets, p, use.from) then
					slash_targets:append(p)
				end
			end
			if not slash_targets:isEmpty() then
				local slash_target = room:askForPlayerChosen(use.from, slash_targets, "Collateral", prompt)
				if slash_target then
					local msg = sgs.LogMessage()
					msg.type = "#CollateralSlash"
					msg.from = use.from
					msg.to:append(slash_target)
					room:sendLog(msg)
					local _data = sgs.QVariant()
					_data:setValue(slash_target)
					ask_who:setTag("collateralVictim", _data)
				end
			end
		end]]
		data:setValue(use)
		room:getThread():trigger(sgs.TargetConfirming, room, ask_who, data)
		return false
	end
}
JiliYBHAnaleptic = sgs.CreateTriggerSkill{
	name = "#JiliYBH-analeptic", 
	frequency = sgs.Skill_Compulsory, 
	events = {sgs.CardEffectConfirmed, sgs.PostCardEffected, sgs.CardFinished},  --撤销系统自动对严白虎的酒1效果，并改为酒2
	global = true,  --这里的Compulsory+Global是故意的
	priority = 7,
	on_record = function(self, event, room, player, data)
		if event == sgs.CardFinished then  --Clear
			local use = data:toCardUse()
			if use.card:hasFlag("JiliYBHAffected") then
				room:setCardFlag(use.card, "-JiliYBHAffected")
				for _,p in sgs.qlist(room:getAlivePlayers()) do
					room:setPlayerFlag(p, "-JiliYBHAffected" .. use.card:toString()) 
				end
			end
			return
		end
		
		local effect = data:toCardEffect()
		if not (effect.card:isKindOf("Analeptic") and effect.card:hasFlag("JiliYBHAffected")) then return false end
		if not player:hasFlag("JiliYBHAffected" .. effect.card:toString()) then return false end
		
		if event == sgs.CardEffectConfirmed then
			local has_dying = (sgs.Sanguosha:getCurrentCardUseReason() ~= sgs.CardUseStruct_CARD_USE_REASON_PLAY)
			for _,p in sgs.qlist(room:getOtherPlayers(player)) do
				if p:hasFlag("Global_Dying") then
					has_dying = true
				end
			end
			if not has_dying then return end
			room:addPlayerMark(player, "JiliYBHAnaleptic")
			room:setPlayerMark(player, "JiliYBHDrank", player:getMark("drank"))
		elseif event == sgs.PostCardEffected then
			if player:getMark("JiliYBHAnaleptic") > 0 then
				room:removePlayerMark(player, "JiliYBHAnaleptic")
				room:setPlayerMark(player, "drank", player:getMark("JiliYBHDrank"))
				room:setPlayerMark(player, "JiliYBHDrank", 0)
				if not player:isAlive() then return end
				local recover = sgs.RecoverStruct()
				recover.card = effect.card
				recover.who = effect.from
				room:recover(player, recover)
			end
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end
}
YanBaiHu:addSkill(JiliYBH)
YanBaiHu:addSkill(JiliYBHAnaleptic)
sgs.insertRelatedSkills(extensionOL, "JiliYBH", "#JiliYBH-analeptic")

----------------------------------------------------------------------------------------------------

--[[ OL 021 关索
	武将：GuanSuo
	武将名：关索
	体力上限：4
	武将技能：
		征南：当其他角色死亡后，你可以摸三张牌，然后获得下列技能之一：“武圣”、“制蛮”、“当先”。
		撷芳：锁定技，你与其他角色的距离-X（X为女性角色数）。
	状态：验证通过
]]--
GuanSuo = sgs.General(extensionOL, "GuanSuo", "shu", 4, true)

--[[
	技能名：征南
	技能：Zhengnan
	描述：当其他角色死亡后，你可以摸三张牌，然后获得下列技能之一：“武圣”、“制蛮”、“当先”。
	状态：验证通过
]]--
Zhengnan = sgs.CreateTriggerSkill{
	name = "Zhengnan", 
	events = {sgs.BuryVictim}, 
	frequency = sgs.Skill_Frequent, 
	priority = -2,
	can_trigger = function(self, event, room, player, data)
		local skill_list, player_list = {}, {}
		for _,guansuo in sgs.qlist(room:findPlayersBySkillName(self:objectName())) do
			if guansuo:objectName() == data:toDeath().who:objectName() then continue end
			table.insert(skill_list, self:objectName())
			table.insert(player_list, guansuo:objectName())
		end
		return table.concat(skill_list, "|"), table.concat(player_list, "|")
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		if ask_who:askForSkillInvoke(self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), ask_who)
			return true 
		end
		return false
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		ask_who:drawCards(3, self:objectName())
		local choices = {}
		local skills = {"wusheng_GuanSuo", "Zhiman_GuanSuo", "Dangxian_GuanSuo"}
		for _,skill in ipairs(skills) do
			if not ask_who:hasSkill(skill) then
				table.insert(choices, skill)
			end
		end
		if #choices ~= 0 then
			local choice = room:askForChoice(ask_who, self:objectName(), table.concat(choices, "+"))
			room:acquireSkill(ask_who, choice, true, ask_who:inHeadSkills(self:objectName()))
		end
	end,
}
GuanSuo:addSkill(Zhengnan)
function sgs.CreateZhimanSkill(name)
	local zhiman_skill = {
		name = "Zhiman_" .. name,
		can_preshow = true,
		events = {sgs.DamageCaused},
		can_trigger = function(self, event, room, player, data)
			if not (player and player:isAlive() and player:hasSkill(self:objectName())) then return "" end
			local damage = data:toDamage()
			if damage.to and (player:objectName() ~= damage.to:objectName()) then
				return self:objectName()
			end
			return ""
		end,
		on_cost = function(self, event, room, player, data)
			player:setTag(self:objectName() .. "_data", data)  --for AI
			local dat = sgs.QVariant()
			dat:setValue(data:toDamage().to)
			local invoke = room:askForSkillInvoke(player, self:objectName(), dat)
			player:removeTag(self:objectName() .. "_data")
			if invoke then
				room:broadcastSkillInvoke(self:objectName(), player)
				return true
			end
			return false
		end,
		on_effect = function(self, event, room, player, data)
			local damage = data:toDamage()
			local to = damage.to
			local msg = sgs.LogMessage()
			msg.type, msg.from, msg.arg = "#Zhiman", player, self:objectName()
			msg.to:append(to)
			room:sendLog(msg)
			room:setPlayerMark(to, self:objectName(), 1)
			local dat = sgs.QVariant()
			dat:setValue(player)
			to:setTag(self:objectName() .. "_from", dat)
			
			--按理说如果没有enter_stack（即没走到PreDamageDone），prevented会自动设成true；但由于源码DamageComplete传入了错误的data，未能自动设置prevented，
			--因此会导致对铁索传导的目标发动制蛮会解铁索的bug；但是如果在DamageComplete返回true，又会导致南蛮发动制蛮会跳过对下个目标结算的bug。
			--所以在源码修复之前，先用以下三行临时解决
			damage.prevented = true  
			data:setValue(damage)
			return true
		end,
	}
	return sgs.CreateTriggerSkill(zhiman_skill)
end
function sgs.CreateZhimanSecondSkill(name)
	local zhiman_second_skill = {
		name = "#Zhiman-second_" .. name,
		events = {sgs.DamageComplete},
		frequency = sgs.Skill_Compulsory,
		can_trigger = function(self, event, room, player, data)
			local damage = data:toDamage()
			if (damage.to:objectName() == player:objectName()) and (player:getMark("Zhiman_" .. name) > 0) then
				local masu = player:getTag("Zhiman_" .. name .. "_from"):toPlayer()
				if masu and (masu:objectName() == damage.from:objectName()) and masu:hasShownSkill("Zhiman_" .. name) then
					return self:objectName(), masu
				end
			end
			return ""
		end,
		on_cost = function(self, event, room, player, data, ask_who)
			return true
		end,
		on_effect = function(self, event, room, player, data, ask_who)
			player:removeTag("Zhiman_" .. name .. "_from")
			room:setPlayerMark(player, "Zhiman_" .. name, 0)
			if not player:getCards("ej"):isEmpty() then  --to be replaced with canget
				local card_id = room:askForCardChosen(ask_who, player, "ej", "Zhiman_" .. name)
				local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_EXTRACTION, ask_who:objectName())
				room:obtainCard(ask_who, sgs.Sanguosha:getCard(card_id), reason)
			end
			--if player:isFriendWith(ask_who) and player:askForSkillInvoke("transform") then
			--end
			return false
		end,
	}
	return sgs.CreateTriggerSkill(zhiman_second_skill)
end
wusheng_GuanSuo = sgs.CreateWushengSkill("GuanSuo")
Zhiman_GuanSuo = sgs.CreateZhimanSkill("GuanSuo")
ZhimanSecond_GuanSuo = sgs.CreateZhimanSecondSkill("GuanSuo")
Dangxian_GuanSuo = sgs.CreateDangxianSkill("GuanSuo")
local skillList = sgs.SkillList()
if not sgs.Sanguosha:getSkill("wusheng_GuanSuo") then skillList:append(wusheng_GuanSuo) end
if not sgs.Sanguosha:getSkill("Zhiman_GuanSuo") then skillList:append(Zhiman_GuanSuo) end
if not sgs.Sanguosha:getSkill("#Zhiman-second_GuanSuo") then skillList:append(ZhimanSecond_GuanSuo) end
if not sgs.Sanguosha:getSkill("Dangxian_GuanSuo") then skillList:append(Dangxian_GuanSuo) end
sgs.Sanguosha:addSkills(skillList)
sgs.insertRelatedSkills(extensionOL, "Zhiman_GuanSuo", "#Zhiman-second_GuanSuo")
GuanSuo:addRelateSkill("wusheng_GuanSuo")
GuanSuo:addRelateSkill("Zhiman_GuanSuo")
GuanSuo:addRelateSkill("Dangxian_GuanSuo")

--[[
	技能名：撷芳
	技能：Xiefang
	描述：锁定技，你与其他角色的距离-X（X为女性角色数）。
	状态：验证通过
]]--
Xiefang = sgs.CreateDistanceSkill{
	name = "Xiefang", 
	correct_func = function(self, from, to)
		if from:hasShownSkill("Xiefang") then
			local wife = 0
			if from:isFemale() then wife = wife - 1 end
			for _, p in sgs.qlist(from:getAliveSiblings()) do
				if p:isFemale() then 
					wife = wife - 1 
				end
			end
			return wife
		end
	end
}
GuanSuo:addSkill(Xiefang)

----------------------------------------------------------------------------------------------------

--[[ OL ??? 王朗
	武将：WangLang
	武将名：王朗
	体力上限：3
	武将技能：
		鼓舌：出牌阶段限一次，你可以用一张手牌与至多三名角色同时拼点，然后依次结算拼点结果，没赢的角色选择一项：1.弃置一张牌；2.令你摸一张牌。若拼点没赢的角色是你，你需先获得一个“饶舌”标记（你有7个饶舌标记时，你死亡）。
		激词：当你发动“鼓舌”拼点的牌亮出后，若此牌的点数：小于X，你可令此牌的点数于此次拼点中+X；等于X，你于此阶段内可以多发动一次“鼓舌”。（X为你的“饶舌”标记数）
	状态：验证通过
]]--
WangLang = sgs.General(extensionOL, "WangLang", "wei", 3, true)

--[[
	技能名：鼓舌
	技能：Gushe
	描述：出牌阶段限一次，你可以用一张手牌与至多三名角色同时拼点，然后依次结算拼点结果，没赢的角色选择一项：1.弃置一张牌；2.令你摸一张牌。若拼点没赢的角色是你，你需先获得一个“饶舌”标记（你有7个饶舌标记时，你死亡）。
	状态：验证通过
]]--
function askForMultiplePindianRace(from, tos, reason)
	if not from:isAlive() then
		return nil
	else
		for _,to in sgs.qlist(tos) do
			if not to:isAlive() then return nil end
		end
	end
	local cards = sgs.CardList()
	local room = from:getRoom()	
	cards:append(room:askForPindian(from, from, tos:first(), reason))
	for _,to in sgs.qlist(tos) do
		cards:append(room:askForPindian(to, from, to, reason))
	end
	return cards
end
function processSinglePindianSelect(source, target, reason, card1, card2, first)
	local room = source:getRoom()
	local pindian_struct = sgs.PindianStruct()
	pindian_struct.from, pindian_struct.to, pindian_struct.from_card, pindian_struct.to_card = source, target, card1, card2
	pindian_struct.from_number = card1:getNumber()
	pindian_struct.to_number = card2:getNumber()
	pindian_struct.reason = reason
	
	local moves = sgs.CardsMoveList()
	if first then
		local move_table1 = sgs.CardsMoveStruct()
		move_table1.card_ids:append(pindian_struct.from_card:getEffectiveId())
		move_table1.from, move_table1.to, move_table1.to_place = pindian_struct.from, nil, sgs.Player_PlaceTable
		move_table1.reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_PINDIAN, pindian_struct.from:objectName(), pindian_struct.to:objectName(), pindian_struct.reason, "")
		moves:append(move_table1)
	end
	local move_table2 = sgs.CardsMoveStruct()
	move_table2.card_ids:append(pindian_struct.to_card:getEffectiveId())
	move_table2.from, move_table2.to, move_table2.to_place = pindian_struct.to, nil, sgs.Player_PlaceTable
	move_table2.reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_PINDIAN, pindian_struct.from:objectName(), pindian_struct.to:objectName(), pindian_struct.reason, "")
	moves:append(move_table2)
	room:moveCardsAtomic(moves, true)
	local msg = sgs.LogMessage()
	msg.type, msg.from, msg.card_str = "$PindianResult", pindian_struct.from, pindian_struct.from_card:toString()
	room:sendLog(msg)
	msg.type, msg.from, msg.card_str = "$PindianResult", pindian_struct.to, pindian_struct.to_card:toString()
	room:sendLog(msg)
	
	return pindian_struct
end
function processSinglePindian(pindian_struct, last)
	local source = pindian_struct.from
	local target = pindian_struct.to
	local room = source:getRoom()
	
	local thread = room:getThread()
	local data = sgs.QVariant()
	data:setValue(pindian_struct)
	thread:trigger(sgs.PindianVerifying, room, source, data)
	pindian_struct = data:toPindian()
	pindian_struct.success = (pindian_struct.from_number > pindian_struct.to_number)
	
	local msg2 = sgs.LogMessage()
	msg2.type, msg2.from = (pindian_struct.success) and "#PindianSuccess" or "#PindianFailure", pindian_struct.from
	msg2.to:append(pindian_struct.to)
	room:sendLog(msg2)
	local arg = {16, pindian_struct.from:objectName(), pindian_struct.from_card:getEffectiveId(), pindian_struct.to:objectName(), pindian_struct.to_card:getEffectiveId(), pindian_struct.success, pindian_struct.reason}  --S_GAME_EVENT_REVEAL_PINDIAN（为啥是从1开始？）
	room:doBroadcastNotify(sgs.CommandType.S_COMMAND_LOG_EVENT, json.encode(arg))
	
	local data = sgs.QVariant()
	data:setValue(pindian_struct)
	thread:trigger(sgs.Pindian, room, source, data)
	
	local moves = sgs.CardsMoveList()
	if last and (room:getCardPlace(pindian_struct.from_card:getEffectiveId()) == sgs.Player_PlaceTable) then
		local move_discard1 = sgs.CardsMoveStruct()
		move_discard1.card_ids:append(pindian_struct.from_card:getEffectiveId())
		move_discard1.from, move_discard1.to, move_discard1.to_place = pindian_struct.from, nil, sgs.Player_DiscardPile
		move_discard1.reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_PINDIAN, pindian_struct.from:objectName(), pindian_struct.to:objectName(), pindian_struct.reason, "")
		moves:append(move_discard1)
	end
	if room:getCardPlace(pindian_struct.to_card:getEffectiveId()) == sgs.Player_PlaceTable then
		local move_discard2 = sgs.CardsMoveStruct()
		move_discard2.card_ids:append(pindian_struct.to_card:getEffectiveId())
		move_discard2.from, move_discard2.to, move_discard2.to_place = pindian_struct.to, nil, sgs.Player_DiscardPile
		move_discard2.reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_PINDIAN, pindian_struct.to:objectName())
		moves:append(move_discard2)
	end
	if not moves:isEmpty() then
		room:moveCardsAtomic(moves, true)
	end
	
	local decision_str = "pindian:" .. pindian_struct.reason .. ":" .. pindian_struct.from:objectName() .. ":" .. pindian_struct.from_card:getEffectiveId() .. ":" .. pindian_struct.to:objectName() .. ":" .. pindian_struct.to_card:getEffectiveId()
	thread:trigger(sgs.ChoiceMade, room, source, sgs.QVariant(decision_str))
	
	return pindian_struct.success
	--[[if pindian_struct.from_number > pindian_struct.to_number then
		return 1
	elseif pindian_struct.from_number < pindian_struct.to_number then
		return -1
	else
		return 0
	end]]
end
function GushePunishment(target, wanglang)
	local room = target:getRoom()
	if (target:objectName() == wanglang:objectName()) and wanglang:isAlive() then
		wanglang:gainMark("@tongue")
		if wanglang:getMark("@tongue") >= 7 then
			room:killPlayer(wanglang)
		end
	end
	if wanglang:isAlive() then
		if (not target:canDiscard(target, "he")) or (not room:askForDiscard(target, "Gushe", 1, 1, wanglang:isAlive(), true, "@GusheDiscard:" .. wanglang:objectName())) then
			room:drawCards(wanglang, 1, "Gushe")
		end
	elseif target:canDiscard(target, "he") then
		room:askForDiscard(target, "Gushe", 1, 1)
	end
end
GusheCard = sgs.CreateSkillCard{
	name = "GusheCard",
	skill_name = "Gushe",
	target_fixed = false,
	will_throw = false,
	mute = true,
	filter = function(self, targets, to_select)
		return (#targets <= 2) and not to_select:isKongcheng() and (to_select:objectName() ~= sgs.Self:objectName())
	end,
	feasible = function(self, targets)
		return #targets > 0
	end,
	extra_cost = function(self, room, use)
		local source = use.from
		local targetlist = use.to
		room:broadcastSkillInvoke("Gushe", source)
		--ServerPlayer::pindianSelect
		local msg = sgs.LogMessage()
		msg.type, msg.from, msg.to = "#Pindian", source, targetlist
		room:sendLog(msg)
		
		local cards = askForMultiplePindianRace(source, targetlist, "Gushe")
		
		local pd = processSinglePindianSelect(source, targetlist:first(), "Gushe", cards:at(0), cards:at(1), true)
		local d = sgs.QVariant()
		d:setValue(pd)
		source:setTag("Gushe_pd", d)
		
		local dummy = sgs.DummyCard()
		dummy:addSubcards(cards)
		local dat = sgs.QVariant()
		dat:setValue(dummy)
		source:setTag("Gushe_Cards", dat)
	end,
	on_use = function(self, room, source, targets)
		local targetlist = sgs.SPlayerList()
		for _,target in ipairs(targets) do
			targetlist:append(target)
		end
		local card_ids = source:getTag("Gushe_Cards"):toCard():getSubcards()
		source:removeTag("Gushe_Cards")
		
		local pd
		for i, target in sgs.qlist(targetlist) do
			if i == 0 then
				pd = source:getTag("Gushe_pd"):toPindian()
				source:removeTag("Gushe_pd")
			else
				pd = processSinglePindianSelect(source, target, "Gushe", sgs.Sanguosha:getCard(card_ids:at(0)), sgs.Sanguosha:getCard(card_ids:at(targetlist:indexOf(target) + 1)), false)
			end
			if pd then
				processSinglePindian(pd, (targetlist:indexOf(target) == targetlist:length() - 1))
			end
			if target:getMark("JiciIncrease") > 0 then
				room:setPlayerMark(target, "JiciIncrease", 0)
			end
			room:setPlayerFlag(source, "JiciForbidden")   --DIRTY HACK
		end
		room:setPlayerFlag(source, "-JiciForbidden")
		if source:getMark("JiciIncrease") > 0 then   --DIRTY HACK
			room:setPlayerMark(source, "JiciIncrease", 0)
		end
	end,
	on_turn_broken = function(self, function_name, room, data)
		local source = data:toCardUse().from
		if source then
			source:removeTag("Gushe_pd")
			source:removeTag("Gushe_Cards")
			room:setPlayerMark(source, "JiciIncrease", 0)
			room:setPlayerFlag(source, "-JiciForbidden")
		end
		for _,target in sgs.qlist(data:toCardUse().to) do
			if target:getMark("JiciIncrease") > 0 then
				room:setPlayerMark(target, "JiciIncrease", 0)
			end
		end
	end,
}
GusheVS = sgs.CreateZeroCardViewAsSkill{
	name = "Gushe",
	view_as = function(self, cards)
		local card = GusheCard:clone()
		card:setShowSkill(self:objectName())
		return card
	end,
	enabled_at_play = function(self, player)
		return (player:usedTimes("#GusheCard") < 1 + player:getMark("JiciExtra")) and not player:isKongcheng()
	end
}
Gushe = sgs.CreateTriggerSkill{  --给VSskill加子技能TriggerSkill的话，由于不明原因加不上，而GushePunish又必须锁定，因此写个空技能
	name = "Gushe",
	view_as_skill = GusheVS,
}
GushePunish = sgs.CreateTriggerSkill{
	name = "#Gushe-punish",
	frequency = sgs.Skill_Compulsory,
	events = {sgs.Pindian},
	global = true,  --global且compulsory的技能会优先发动，但是对这个技能没有别的办法（否则简雍就可以点取消了，因为是否有取消是根据技能发动者的hasShownSkill），此为源码bug
	can_trigger = function(self, event, room, player, data)
		local pindian = data:toPindian()
		if pindian.reason ~= "Gushe" then return "" end
		local skill_list, player_list = {}, {}
		if pindian.from_number <= pindian.to_number then
			table.insert(skill_list, self:objectName())
			table.insert(player_list, pindian.from:objectName())
		end
		if pindian.from_number >= pindian.to_number then
			table.insert(skill_list, --[[pindian.from:objectName() .. "'" .. ]]self:objectName())  --暂时无法这样处理，因为源码bug导致sgs1显示在技能名中
			table.insert(player_list, pindian.to:objectName())
		end
		return table.concat(skill_list, "|"), table.concat(player_list, "|")
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		return true
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		if ask_who:isDead() then return end
		local pindian = data:toPindian()
		GushePunishment(ask_who, pindian.from)
	end
}
WangLang:addSkill(Gushe)
WangLang:addSkill(GushePunish)
sgs.insertRelatedSkills(extensionOL, "Gushe", "#Gushe-punish")

--[[
	技能名：激词
	技能：Jici
	描述：当你发动“鼓舌”拼点的牌亮出后，若此牌的点数：小于X，你可令此牌的点数于此次拼点中+X；等于X，你于此阶段内可以多发动一次“鼓舌”。（X为你的“饶舌”标记数）
	状态：验证通过
]]--
Jici = sgs.CreateTriggerSkill{
	name = "Jici",
	can_preshow = true,
	frequency = sgs.Skill_NotFrequent,
	events = {sgs.PindianVerifying},
	can_trigger = function(self, event, room, player, data)
		local pindian = data:toPindian()
		if pindian.reason == "Gushe" then
			local skill_list, player_list = {}, {}
			for _,wanglang in sgs.qlist(room:findPlayersBySkillName(self:objectName())) do  --同将模式
				if wanglang:hasFlag("JiciForbidden") then continue end
				if (wanglang:objectName() == pindian.from:objectName()) and (pindian.from_number < wanglang:getMark("@tongue")) then
					table.insert(skill_list, self:objectName())
					table.insert(player_list, wanglang:objectName())
				end
				if (wanglang:objectName() == pindian.to:objectName()) and (pindian.to_number < wanglang:getMark("@tongue")) then
					table.insert(skill_list, self:objectName())
					table.insert(player_list, wanglang:objectName())
				end
			end
			return table.concat(skill_list, "|"), table.concat(player_list, "|")
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		if room:askForSkillInvoke(ask_who, self:objectName(), sgs.QVariant("Increase:::" .. tostring(ask_who:getMark("@tongue")))) then
			room:broadcastSkillInvoke(self:objectName(), ask_who)
			return true
		end
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		local pindian = data:toPindian()
		local x = ask_who:getMark("@tongue")
		room:setPlayerMark(ask_who, "JiciIncrease", x)
		local new
		if ask_who:objectName() == pindian.from:objectName() then
			new = math.min(x + pindian.from_number, 13)
		end
		if ask_who:objectName() == pindian.to:objectName() then
			new = math.min(x + pindian.to_number, 13)
		end
		local msg = sgs.LogMessage()
		msg.type, msg.from, msg.arg = "#JiciIncrease", ask_who, new
		room:sendLog(msg)
	end
}
JiciIncrease = sgs.CreateTriggerSkill{
	name = "#Jici-increase",
	frequency = sgs.Skill_Compulsory,
	events = {sgs.PindianVerifying},
	priority = 1,
	can_trigger = function(self, event, room, player, data)
		local pindian = data:toPindian()
		if pindian.reason == "Gushe" then
			local skill_list, player_list = {}, {}
			for _,wanglang in sgs.qlist(room:getAllPlayers(true)) do
				if (wanglang:getMark("JiciIncrease") > 0) then
					table.insert(skill_list, self:objectName())
					table.insert(player_list, wanglang:objectName())
				end
			end
			return table.concat(skill_list, "|"), table.concat(player_list, "|")
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		return true
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		local pindian = data:toPindian()
		if ask_who:objectName() == pindian.from:objectName() then
			pindian.from_number = math.min(pindian.from_number + ask_who:getMark("JiciIncrease"), 13)
		end
		if ask_who:objectName() == pindian.to:objectName() then
			pindian.to_number = math.min(pindian.to_number + ask_who:getMark("JiciIncrease"), 13)
		end
		data:setValue(pindian)
	end
}
JiciExtra = sgs.CreateTriggerSkill{
	name = "#Jici-extra",
	frequency = sgs.Skill_Compulsory,
	events = {sgs.PindianVerifying, sgs.EventPhaseStart},
	on_record = function(self, event, room, player, data)
		if (event == sgs.EventPhaseStart) and (player:getPhase() == sgs.Player_NotActive) then
			room:setPlayerMark(player, "JiciExtra", 0)
		end
	end,
	can_trigger = function(self, event, room, player, data)
		if event == sgs.PindianVerifying then
			local pindian = data:toPindian()
			if pindian.reason == "Gushe" then
				local skill_list, player_list = {}, {}
				for _,wanglang in sgs.qlist(room:findPlayersBySkillName(self:objectName())) do  --同将模式
					if wanglang:hasFlag("JiciForbidden") or (wanglang:getPhase() ~= sgs.Player_Play) then continue end
					if (wanglang:objectName() == pindian.from:objectName()) and (pindian.from_number == wanglang:getMark("@tongue")) then
						table.insert(skill_list, self:objectName())
						table.insert(player_list, wanglang:objectName())
					end
					if (wanglang:objectName() == pindian.to:objectName()) and (pindian.to_number == wanglang:getMark("@tongue")) then
						table.insert(skill_list, self:objectName())
						table.insert(player_list, wanglang:objectName())
					end
				end
				return table.concat(skill_list, "|"), table.concat(player_list, "|")
			end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		room:broadcastSkillInvoke("Jici", ask_who)
		if ask_who:ownSkill("Jici") and not ask_who:hasShownSkill("Jici") then
			ask_who:showGeneral(ask_who:inHeadSkills("Jici"))
		end
		return true
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		local msg = sgs.LogMessage()
		msg.type, msg.from, msg.arg = "#JiciExtra", ask_who, ask_who:getMark("@tongue")
		room:sendLog(msg)
		room:addPlayerMark(ask_who, "JiciExtra")
	end
}
WangLang:addSkill(Jici)
WangLang:addSkill(JiciIncrease)
WangLang:addSkill(JiciExtra)
sgs.insertRelatedSkills(extensionOL, "Jici", "#Jici-increase", "#Jici-extra")

----------------------------------------------------------------------------------------------------

--[[ OL ??? 步骘
	武将：BuZhi
	武将名：步骘
	体力上限：3
	武将技能：
		弘德：当你获得或失去至少两张牌后，你可以令一名其他角色摸一张牌。每名角色的回合限四次。
		定叛：出牌阶段限X次（X为大势力角色数且至少为1），你可以令一名装备区里有牌的角色摸一张牌，然后其选择一项：1.令你弃置其装备区里的一张牌；2.获得其装备区里的所有牌，若如此做，你对其造成1点伤害。
	状态：验证通过
]]--
BuZhi = sgs.General(extensionOL, "BuZhi", "wu", 3, true)

--[[
	技能名：弘德
	技能：Hongde
	描述：当你获得或失去至少两张牌后，你可以令一名其他角色摸一张牌。每名角色的回合限四次。
	状态：验证通过
]]--
Hongde = sgs.CreateTriggerSkill{
	name = "Hongde",
	can_preshow = true,
	events = {sgs.CardsMoveOneTime},
	can_trigger = function(self, event, room, player, data)
		if not (player and player:isAlive() and player:hasSkill(self:objectName())) then return "" end
		if room:getCurrent() and room:getCurrent():getMark(self:objectName()) >= 4 then return "" end
		local move = data:toMoveOneTime()
		if not room:getTag("FirstRound"):toBool() and move.card_ids:length() >= 2 then
			local isGet = (move.to and move.to:objectName() == player:objectName() and move.to_place == sgs.Player_PlaceHand --[[and move.reason.m_reason ~= sgs.CardMoveReason_S_REASON_PREVIEWGIVE]])
			local isLose = false
			local lostCount = 0
			if move.from and move.from:objectName() == player:objectName() and (move.from_places:contains(sgs.Player_PlaceHand) or move.from_places:contains(sgs.Player_PlaceEquip)) and not (move.to and move.to:objectName() == player:objectName() and (move.to_place == sgs.Player_PlaceHand or move.to_place == sgs.Player_PlaceEquip)) then
				for i = 0, move.from_places:length() - 1 do
					if (move.from_places:at(i) == sgs.Player_PlaceHand) or (move.from_places:at(i) == sgs.Player_PlaceEquip) then
						lostCount = lostCount + 1
						if lostCount >= 2 then isLose = true break end
					end
				end
			end
			if isGet or isLose then return self:objectName() end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		local to = room:askForPlayerChosen(player, room:getOtherPlayers(player), self:objectName(), self:objectName().."-invoke", true, true)
		if to then
			room:broadcastSkillInvoke(self:objectName(), player)
			local to_data = sgs.QVariant()
			to_data:setValue(to)
			player:setTag(self:objectName(), to_data)
			return true 
		end
		return false 
	end,
	on_effect = function(self, event, room, player, data)
		local to = player:getTag(self:objectName()):toPlayer()
		player:removeTag(self:objectName())
		room:drawCards(to, 1, self:objectName())
		room:getCurrent():addMark(self:objectName())
	end,
	on_turn_broken = function(self, function_name, event, room, player, data, ask_who)
		player:removeTag(self:objectName())
	end
}
HongdeClear = sgs.CreateTriggerSkill{
	name = "#Hongde-clear",
	events = {sgs.EventPhaseStart},
	priority = 8,
	global = true,
 	on_record = function(self, event, room, player, data)
		if (event == sgs.EventPhaseStart) and (player:getPhase() == sgs.Player_NotActive) then
			if player:getMark("Hongde") > 0 then
				player:setMark("Hongde", 0)
			end
		end
	end,
 	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
BuZhi:addSkill(Hongde)
BuZhi:addSkill(HongdeClear)
sgs.insertRelatedSkills(extensionOL, "Hongde", "#Hongde-clear")

--[[
	技能名：定叛
	技能：Dingpan
	描述：出牌阶段限X次（X为大势力角色数且至少为1），你可以令一名装备区里有牌的角色摸一张牌，然后其选择一项：1.令你弃置其装备区里的一张牌；2.获得其装备区里的所有牌，若如此做，你对其造成1点伤害。
	状态：验证通过
]]--
DingpanCard = sgs.CreateSkillCard{
	name = "DingpanCard",
	skill_name = "Dingpan",
	mute = true,
	filter = function(self, selected, to_select)
		return #selected == 0 and not to_select:getEquips():isEmpty()
	end,
	on_use = function(self, room, source, targets)
		local target = targets[1]
		target:drawCards(1, self:objectName())
		local choices = {}
		if source:isAlive() and source:canDiscard(target, "e") then
			table.insert(choices, "discard")
		end
		table.insert(choices, "damage")
		local choice = room:askForChoice(target, "Dingpan", table.concat(choices, "+"))
		if choice == "discard" and source:canDiscard(target, "e") then
			room:broadcastSkillInvoke("Dingpan", 1, source)
			local id = room:askForCardChosen(source, target, "e", "Dingpan", false, sgs.Card_MethodDiscard)
			local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_DISMANTLE, source:objectName(), target:objectName(), "Dingpan", nil)
			room:throwCard(sgs.Sanguosha:getCard(id), reason, target, source)
		elseif choice == "damage" then
			room:broadcastSkillInvoke("Dingpan", 2, source)
			local dummy = sgs.DummyCard()
			for _, equip in sgs.qlist(target:getEquips()) do
			    dummy:addSubcard(equip:getEffectiveId())
		    end
			dummy:deleteLater()
			room:obtainCard(target, dummy, sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_EXTRACTION, source:objectName(), target:objectName(), "Dingpan", ""))
			room:damage(sgs.DamageStruct("Dingpan", source, target))
		end
	end
}
Dingpan = sgs.CreateZeroCardViewAsSkill{
	name = "Dingpan",
	view_as = function(self) 
		local card = DingpanCard:clone()
		card:setShowSkill(self:objectName())
		return card
	end,
	enabled_at_play = function(self, player)  --待定，可能需要重写getBigKingdoms，因为暗置发动技能时是否属于吴势力的问题
		local big_kingdoms = player:getBigKingdoms("Dingpan")
		local big_kingdom_count = 0
		local players = player:getAliveSiblings()
		players:append(player)
		for _,p in sgs.qlist(players) do
			if table.contains(big_kingdoms, p:objectName()) or (table.contains(big_kingdoms, p:getKingdom()) and (p:getRole() ~= "careerist")) then  --野心家的同势力角色数永远不可能大于1，因此不可能出现在big_kingdoms中
				big_kingdom_count = big_kingdom_count + 1
			end
		end
		return player:usedTimes("#DingpanCard") < math.max(1, big_kingdom_count)
	end
}
BuZhi:addSkill(Dingpan)

----------------------------------------------------------------------------------------------------

--[[ OL ??? 李通
	武将：LiTong
	武将名：李通
	体力上限：4
	武将技能：
		推锋：当你受到1点伤害后，你可以将一张牌置于武将牌上，称为“锋”；准备阶段开始时，若你的武将牌上有“锋”，你移去所有“锋”，摸2X张牌，若如此做，你于此回合的出牌阶段内可以多使用X张【杀】（X为你此次移去的“锋”数）。
	状态：验证通过
]]--
LiTong = sgs.General(extensionOL, "LiTong", "wei", 4, true)

--[[
	技能名：推锋
	技能：Tuifeng
	描述：当你受到1点伤害后，你可以将一张牌置于武将牌上，称为“锋”；准备阶段开始时，若你的武将牌上有“锋”，你移去所有“锋”，摸2X张牌，若如此做，你于此回合的出牌阶段内可以多使用X张【杀】（X为你此次移去的“锋”数）。
	状态：验证通过
]]--
Tuifeng = sgs.CreateMasochismSkill{
	name = "Tuifeng",
	can_preshow = true,
	frequency = sgs.Skill_Frequent,
	can_trigger = function(self, event, room, player, data)	
		if not player or player:isDead() or not player:hasSkill(self:objectName()) then return "" end
		if player:isNude() then return "" end
		local damage = data:toDamage()
		local trigger_list = {}
		for i = 1, damage.damage, 1 do
			table.insert(trigger_list, self:objectName())
		end
		return table.concat(trigger_list, ",")
	end,
	on_cost = function(self, event, room, player, data)
		local exc_card = room:askForExchange(player, self:objectName(), 1, 0, "TuifengPush", "", ".")
		if exc_card then
			player:setTag("TuifengCardId", sgs.QVariant(exc_card:getSubcards():first()))
			local msg = sgs.LogMessage()
			msg.type, msg.from, msg.arg = "#InvokeSkill", player, self:objectName()
			room:sendLog(msg)
			room:broadcastSkillInvoke(self:objectName(), 2, player)
			return true
		end
		player:removeTag("TuifengCardId")
		return false 
	end,
	on_damaged = function(self, player, damage)
		local id = player:getTag("TuifengCardId"):toInt()
		player:removeTag("TuifengCardId")
		if id then
			player:addToPile("lead", id)
		end
	end,
	on_turn_broken = function(self, function_name, event, room, player, data, ask_who)
		player:removeTag("TuifengCardId")
	end
}
TuifengThrow = sgs.CreateTriggerSkill{
	name = "#Tuifeng-throw",
	events = {sgs.EventPhaseStart},
	frequency = sgs.Skill_Compulsory,
	can_trigger = function(self, event, room, player, data)
		if not (player and player:isAlive() and player:hasSkill(self:objectName())) then return "" end
		if player:getPhase() ~= sgs.Player_Start then return "" end
		return (player:getPile("lead"):length() > 0) and self:objectName() or ""
	end,
	on_cost = function(self, event, room, player, data)
		room:broadcastSkillInvoke("Tuifeng", 1, player)
		if player:ownSkill("Tuifeng") and not player:hasShownSkill("Tuifeng") then
			player:showGeneral(player:inHeadSkills("Tuifeng"))
		end
		return true
	end,
	on_effect = function(self, event, room, player, data)
		local x = player:getPile("lead"):length()
		if x > 0 then
			room:sendCompulsoryTriggerLog(player, "Tuifeng", true)
			local dummy = sgs.DummyCard(player:getPile("lead"))
			dummy:deleteLater()
			local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_REMOVE_FROM_PILE, "", "Tuifeng", "")
			room:throwCard(dummy, reason, nil)
			player:drawCards(2*x)
			room:setPlayerMark(player, "@lead", x)
		end
	end,
}
TuifengClear = sgs.CreateTriggerSkill{
	name = "#Tuifeng-clear",
	events = {sgs.EventPhaseStart, sgs.EventLoseSkill},
	priority = 8,
	global = true,
	on_record = function(self, event, room, player, data)
		if event == sgs.EventPhaseStart then
			if player:getPhase() ~= sgs.Player_NotActive then return end
			for _,p in sgs.qlist(room:getAllPlayers()) do
				if p:getMark("@lead") > 0 then
					room:setPlayerMark(p, "@lead", 0)
				end
			end
		elseif (event == sgs.EventLoseSkill) and data:toString() == "Tuifeng" then
			player:clearOnePrivatePile("lead")
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
TuifengTargetMod = sgs.CreateTargetModSkill{
	name = "#Tuifeng-targetmod",
	pattern = "Slash",
	residue_func = function(self, from, card)
		return from:getMark("@lead")
	end,
}
LiTong:addSkill(Tuifeng)
LiTong:addSkill(TuifengThrow)
LiTong:addSkill(TuifengClear)
LiTong:addSkill(TuifengTargetMod)
sgs.insertRelatedSkills(extensionOL, "Tuifeng", "#Tuifeng-throw", "#Tuifeng-clear", "#Tuifeng-targetmod")

----------------------------------------------------------------------------------------------------

--[[ OL ??? 糜竺
	武将：MiZhu
	武将名：糜竺
	体力上限：3
	武将技能：
		资援：出牌阶段限一次，你可以将至少一张点数之和为13的手牌交给一名其他角色，令其回复1点体力。
		巨贾：锁定技，你的手牌上限+X；当你首次明置此武将牌后，你摸X张牌。（X为你的体力上限）
	状态：验证通过
]]--
MiZhu = sgs.General(extensionOL, "MiZhu", "shu", 3, true)
MiZhu:addCompanion("mifuren")

--[[
	技能名：资援
	技能：Ziyuan
	描述：出牌阶段限一次，你可以将至少一张点数之和为13的手牌交给一名其他角色，令其回复1点体力。
	状态：验证通过
]]--
ZiyuanCard = sgs.CreateSkillCard{
	name = "ZiyuanCard",
	skill_name = "Ziyuan",
	target_fixed = false,
	will_throw = false,
	handling_method = sgs.Card_MethodNone,
	filter = function(self, selected, to_select, player)
		return #selected == 0 and to_select:objectName() ~= player:objectName()
	end ,	
	extra_cost = function(self, room, card_use)
		local target = card_use.to:first()
		local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_GIVE, card_use.from:objectName(), target:objectName(), "Ziyuan", "")
		room:obtainCard(target, self, reason)
	end,
	on_effect = function(self, effect)
		if effect.to:isDead() then return end
		local recover = sgs.RecoverStruct()
		recover.who = effect.from
		effect.from:getRoom():recover(effect.to, recover)
	end
}
Ziyuan = sgs.CreateViewAsSkill{
	name = "Ziyuan",
	n = 999,
	view_filter = function(self, selected, to_select)
		if to_select:isEquipped() then return false end
		local sum = 0
		for _, card in ipairs(selected) do
			sum = sum + card:getNumber()
		end
		sum = sum + to_select:getNumber()
		return sum <= 13
	end,
	view_as = function(self, cards)
		local sum = 0
		for _, c in ipairs(cards) do
			sum = sum + c:getNumber()
		end
		if sum == 13 then
			local card = ZiyuanCard:clone()
			for _, c in ipairs(cards) do
				card:addSubcard(c)
			end
			card:setShowSkill(self:objectName())
			return card
		else
			return nil
		end
	end,
	enabled_at_play = function(self, player)
		return not player:hasUsed("#ZiyuanCard") and not player:isKongcheng()
	end
}
MiZhu:addSkill(Ziyuan)

--[[
	技能名：巨贾
	技能：Jugu
	描述：锁定技，你的手牌上限+X；当你首次明置此武将牌后，你摸X张牌。（X为你的体力上限）
	状态：验证通过
]]--
Jugu = sgs.CreateTriggerSkill{
	name = "Jugu",
	can_preshow = true,
	frequency = sgs.Skill_Compulsory,
	events = {sgs.GeneralShown, sgs.DFDebut},
	can_trigger = function(self, event, room, player, data)
		if not (player and player:isAlive() and player:hasSkill(self:objectName())) then return "" end
		if (event == sgs.GeneralShown) and (player:getMark(self:objectName()) == 0) then
			return (data:toBool() == player:inHeadSkills(self:objectName())) and self:objectName() or ""
		elseif (event == sgs.DFDebut) and (player:getMark(self:objectName()) == 0) then
			return self:objectName()
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		room:broadcastSkillInvoke(self:objectName(), player)
		room:setPlayerMark(player, self:objectName(), 1)
		return true
	end,
	on_effect = function(self, event, room, player, data)
		room:sendCompulsoryTriggerLog(player, self:objectName(), true)
		room:drawCards(player, player:getMaxHp(), self:objectName())
		return false
	end,
}
JuguMaxCards = sgs.CreateMaxCardsSkill{
	name = "#Jugu-MaxCards",
	extra_func = function(self, target)
		if target:hasShownSkill("Jugu") then
			return target:getMaxHp()
		else
			return 0
		end
	end
}
JuguShowMaxCards = sgs.CreateTriggerSkill{
	name = "#Jugu-showmaxcards",
	can_preshow = true,
	frequency = sgs.Skill_Compulsory,  --因为此技能必须尚未亮将，所以不需要处理无法取消的问题
	events = {sgs.EventPhaseProceeding},
	can_trigger = function(self, event, room, player, data)
		if not player or player:isDead() or not player:hasSkill(self:objectName()) then return "" end
		if (player:getPhase() == sgs.Player_Discard) and not player:hasShownSkill(self:objectName()) then  --进入弃牌阶段询问是否发动巨贾存牌
			if (player:getMaxCards(sgs.Max) < player:getHandcardNum()) then
				return self:objectName()
			end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		if player:hasShownSkill(self:objectName()) or room:askForSkillInvoke(player, self:objectName(), sgs.QVariant("keep:::" .. player:getMaxHp())) then
			if player:ownSkill("Jugu") and not player:hasShownSkill("Jugu") then
				player:showGeneral(player:inHeadSkills("Jugu"))
			end
			return true
		end
	end,
	on_effect = function(self, event, room, player, data)
		room:notifySkillInvoked(player, self:objectName())
	end,
}
MiZhu:addSkill(Jugu)
MiZhu:addSkill(JuguMaxCards)
MiZhu:addSkill(JuguShowMaxCards)
sgs.insertRelatedSkills(extensionOL, "Jugu", "#Jugu-MaxCards", "#Jugu-showmaxcards")

----------------------------------------------------------------------------------------------------

--[[ OL ??? 董白
	武将：DongBai
	武将名：董白
	体力上限：3
	武将技能：
		连诛：出牌阶段限一次，你可以展示一张牌并将之交给一名角色，若此牌为黑色，其选择是否弃置两张牌，若其选择否，你摸两张牌。
		黠慧：锁定技，你的黑色手牌于弃牌阶段内不计入手牌数且不能弃置；锁定技，当你的黑色牌被其他角色获得后，你令其于其扣减体力之前不能使用、打出或弃置之。
	状态：验证通过
]]--
DongBai = sgs.General(extensionOL, "DongBai", "qun", 3, false)

--[[
	技能名：连诛
	技能：Lianzhu
	描述：出牌阶段限一次，你可以展示一张牌并将之交给一名角色，若此牌为黑色，其选择是否弃置两张牌，若其选择否，你摸两张牌。
	状态：验证通过
]]--
LianzhuCard = sgs.CreateSkillCard{
	name = "LianzhuCard",
	skill_name = "Lianzhu",
	target_fixed = false, 
	will_throw = false, 
	extra_cost = function(self, room, card_use)
		local target = card_use.to:first()
		card_use.from:setTag("LianzhuColor", sgs.QVariant(self:getColor()))
		room:showCard(card_use.from, self:getEffectiveId())
		local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_GIVE, card_use.from:objectName(), target:objectName(), "Lianzhu", "")
		room:obtainCard(target, self, reason, true)
	end,
	on_use = function(self, room, source, targets)
		local color = source:getTag("LianzhuColor"):toInt()
		source:removeTag("LianzhuColor")
		if color == sgs.Card_Black then
			if not room:askForDiscard(targets[1], "Lianzhu", 2, 2, true, true, "@Lianzhu:" .. source:objectName()) then
				source:drawCards(2, "Lianzhu")
			end
		end
	end,
	on_turn_broken = function(self, function_name, room, data)
		data:toCardUse().from:removeTag("LianzhuColor")
	end,
}
Lianzhu = sgs.CreateOneCardViewAsSkill{
	name = "Lianzhu",
	filter_pattern = ".",
	view_as = function(self, card)
		local skill_card = LianzhuCard:clone()
		skill_card:addSubcard(card)
		skill_card:setSkillName(self:objectName())
		skill_card:setShowSkill(self:objectName())
		return skill_card
	end,
	enabled_at_play = function(self, player)
		return not player:hasUsed("#LianzhuCard")
	end
}
DongBai:addSkill(Lianzhu)

--[[
	技能名：黠慧
	技能：Xiahui
	描述：锁定技，你的黑色手牌于弃牌阶段内不计入手牌数且不能弃置；锁定技，当你的黑色牌被其他角色获得后，你令其于其扣减体力之前不能使用、打出或弃置之。
	状态：验证通过
]]--
Xiahui = sgs.CreateTriggerSkill{
	name = "Xiahui",
	can_preshow = true,
	events = {sgs.CardsMoveOneTime},
	frequency = sgs.Skill_Compulsory,
 	can_trigger = function(self, event, room, player, data)
		if event == sgs.CardsMoveOneTime then
			if not player or player:isDead() then return "" end
			local move = data:toMoveOneTime()
			if move.to and move.to:objectName() ~= player:objectName() and move.from and move.from:objectName() == player:objectName() and (move.from_places:contains(sgs.Player_PlaceHand) or move.from_places:contains(sgs.Player_PlaceEquip)) and move.to_place == sgs.Player_PlaceHand then  --条件B
				local XiahuiStack_str = player:getTag("XiahuiStack"):toString()
				if XiahuiStack_str == "" then return end
				local XiahuiStack = XiahuiStack_str:split("|")
				local XiahuiRemains = {}
				
				if player:hasSkill(self) and player:getTag("XiahuiPopIndex"):toInt() ~= #XiahuiStack then
					local XiahuiOneTime_str = XiahuiStack[#XiahuiStack]
					local XiahuiOneTime = XiahuiOneTime_str:split("+")
					table.removeAll(XiahuiOneTime, "-1")
					for i, id in sgs.qlist(move.card_ids) do
						if table.contains(XiahuiOneTime, tostring(id)) and room:getCardPlace(id) == sgs.Player_PlaceHand and room:getCardOwner(id):objectName() == move.to:objectName() then
							table.insert(XiahuiRemains, id)
						end
					end
				end
				if next(XiahuiRemains) then
					room:setPlayerProperty(player, "XiahuiToLock", sgs.QVariant(table.concat(XiahuiRemains, "+")))
					return self:objectName()
				end
			end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		local XiahuiStack_str = player:getTag("XiahuiStack"):toString()
		local XiahuiStack = XiahuiStack_str:split("|")
		player:setTag("XiahuiPopIndex", sgs.QVariant(#XiahuiStack))
		
		local invoke = player:hasShownSkill(self)
		if not invoke then
			local move = data:toMoveOneTime()
			--todo：Tag for AI Data
			local dat = sgs.QVariant()
			for _,p in sgs.qlist(room:getAllPlayers()) do
				if p:objectName() == move.to:objectName() then dat:setValue(p) break end
			end
			invoke = player:askForSkillInvoke(self:objectName(), dat)
		end
		if invoke then
			local XiahuiToLock = player:property("XiahuiToLock"):toString():split("+")  --判断黠慧牌是否全部公开，以决定是否播放配音
			local move, all_visible = data:toMoveOneTime(), true
			local id
			for _, idstring in ipairs(XiahuiToLock) do
				id = tonumber(idstring)
				if not sgs.Sanguosha:getCard(id):hasFlag("visible") and move.from_places:at(move.card_ids:indexOf(id)) ~= sgs.Player_PlaceEquip then
					all_visible = false
					break
				end
			end
			if all_visible then room:broadcastSkillInvoke(self:objectName(), player) end
			return true 
		end
		return false
	end,
	on_effect = function(self, event, room, player, data)
		local XiahuiToLock = player:property("XiahuiToLock"):toString():split("+")
		room:setPlayerProperty(player, "XiahuiToLock", sgs.QVariant())
		local card_ids = sgs.IntList()
		for _, idstring in ipairs(XiahuiToLock) do
			card_ids:append(tonumber(idstring))
		end
		
		local move = data:toMoveOneTime()
		local victim
		for _,p in sgs.qlist(room:getAllPlayers()) do
			if p:objectName() == move.to:objectName() then victim = p break end
		end
		local visible, invisible = {}, {}
		for _,id in sgs.qlist(card_ids) do
			room:setPlayerCardLimitation(victim, "use,response,discard", tostring(id), false)
			room:setCardFlag(sgs.Sanguosha:getCard(id), "XiahuiCard")
			if sgs.Sanguosha:getCard(id):hasFlag("visible") or move.from_places:at(move.card_ids:indexOf(id)) == sgs.Player_PlaceEquip then
				table.insert(visible, id)
			else
				table.insert(invisible, id)
			end
		end
		room:setPlayerMark(victim, "Xiahui", 1)
		
		local msg = sgs.LogMessage()
		msg.type, msg.from = "$XiahuiLock", player
		msg.to:append(victim)
		if next(visible) then
			for _,id in ipairs(visible) do  --无法同时显示多张牌
				msg.card_str = id
				room:sendLog(msg)
			end
		end
		if next(invisible) then
			for _,id in ipairs(invisible) do  --无法同时显示多张牌
				msg.card_str = id
				room:doNotify(player, sgs.CommandType.S_COMMAND_LOG_SKILL, msg:toVariant())
				room:doNotify(victim, sgs.CommandType.S_COMMAND_LOG_SKILL, msg:toVariant())
			end
		end
	end,
}
XiahuiRecord = sgs.CreateTriggerSkill{
	name = "#Xiahui-record",
	events = {sgs.BeforeCardsMove, sgs.CardsMoveOneTime},
	priority = 1,
	global = true,
 	on_record = function(self, event, room, player, data)
		if event == sgs.BeforeCardsMove then
			if not (player and player:isAlive()) then return end
			
			local move = data:toMoveOneTime()
			if move.to and move.to:objectName() ~= player:objectName() and move.from and move.from:objectName() == player:objectName() and (move.from_places:contains(sgs.Player_PlaceHand) or move.from_places:contains(sgs.Player_PlaceEquip)) and move.to_place == sgs.Player_PlaceHand then  --条件A
				local card_ids = {-1}
				for i, id in sgs.qlist(move.card_ids) do
					if sgs.Sanguosha:getCard(id):isBlack() and (move.from_places:at(i) == sgs.Player_PlaceHand or move.from_places:at(i) == sgs.Player_PlaceEquip) then
						table.insert(card_ids, id)
					end
				end
				
				local XiahuiStack_str = player:getTag("XiahuiStack"):toString()
				local XiahuiStack = XiahuiStack_str:split("|")
				table.removeAll(XiahuiStack, "")
				table.insert(XiahuiStack, table.concat(card_ids, "+"))
				player:setTag("XiahuiStack", sgs.QVariant(table.concat(XiahuiStack, "|")))
			end
		elseif event == sgs.CardsMoveOneTime then  --出栈
			if not player or player:isDead() then return false end
			local move = data:toMoveOneTime()
			if move.to and move.to:objectName() ~= player:objectName() and move.from and move.from:objectName() == player:objectName() and (move.from_places:contains(sgs.Player_PlaceHand) or move.from_places:contains(sgs.Player_PlaceEquip)) and move.to_place == sgs.Player_PlaceHand then  --条件B
				local XiahuiStack_str = player:getTag("XiahuiStack"):toString()
				if XiahuiStack_str == "" then return end
				local XiahuiStack = XiahuiStack_str:split("|")
				
				table.remove(XiahuiStack, #XiahuiStack)
				if next(XiahuiStack) then player:setTag("XiahuiStack", sgs.QVariant(table.concat(XiahuiStack, "|")))
				else player:removeTag("XiahuiStack") end
				player:removeTag("XiahuiPopIndex")
			end
		end
	end,
 	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
XiahuiDiscard = sgs.CreateTriggerSkill{
	name = "#Xiahui-discard",
	events = {sgs.EventPhaseStart, sgs.PostHpReduced, sgs.CardsMoveOneTime},
	frequency = sgs.Skill_Compulsory,
	priority = 8,
	on_record = function(self, event, room, player, data)  --蹭priority（反正也不用global，因为必须先发动主技能）
		if player:getMark("Xiahui") <= 0 then return end
		if event == sgs.PostHpReduced then
			for _,c in sgs.qlist(player:getCards("he")) do  --考虑到护援断粮，需要把装备也算进去
				if c:hasFlag("XiahuiCard") then
					room:removePlayerCardLimitation(player, "use,response,discard", c:toString() .. "$0")
				end
				room:setPlayerMark(player, "Xiahui", 0)
			end
		elseif event == sgs.CardsMoveOneTime then
			local move = data:toMoveOneTime()
			if move.from and move.from:objectName() == player:objectName() and (move.from_places:contains(sgs.Player_PlaceHand) or move.from_places:contains(sgs.Player_PlaceEquip)) then
				for i, id in sgs.qlist(move.card_ids) do
					if sgs.Sanguosha:getCard(id):hasFlag("XiahuiCard")
						and (move.from_places:at(i) == sgs.Player_PlaceHand or move.from_places:at(i) == sgs.Player_PlaceEquip)
						--and not (move.to and move.to:objectName() == player:objectName() and (move.to_place == sgs.Player_PlaceHand or move.to_place == sgs.Player_PlaceEquip))
						and not (room:getCardOwner(id) and room:getCardOwner(id) == player and (room:getCardPlace(id) == sgs.Player_PlaceHand or room:getCardPlace(id) == sgs.Player_PlaceEquip)) then  --失去牌时清空限制
						room:removePlayerCardLimitation(player, "use,response,discard", tostring(id) .. "$0")
						room:setCardFlag(id, "-XiahuiCard")
					end
				end
			end
		end
	end,
	can_trigger = function(self, event, room, player, data)
		if not player or player:isDead() or not player:hasSkill(self) then return "" end
		if event == sgs.EventPhaseStart and player:getPhase() == sgs.Player_Discard then
			if player:hasShownSkill(self) then return self:objectName() end  --防止暴露手牌无黑牌
			for _,c in sgs.qlist(player:getHandcards()) do
				if c:isBlack() then
					return self:objectName()
				end
			end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		if player:hasShownSkill(self) or player:askForSkillInvoke("Xiahui", sgs.QVariant("keep")) then
			room:broadcastSkillInvoke("Xiahui", player)
			if player:ownSkill("Xiahui") and not player:hasShownSkill("Xiahui") then
				player:showGeneral(player:inHeadSkills("Xiahui"))
			end
			return true
		end
	end,
	on_effect = function(self, event, room, player, data)
		local msg = sgs.LogMessage()
		msg.type, msg.from = "#Xiahui", player
		room:sendLog(msg)
		room:notifySkillInvoked(player, "Xiahui")
		room:setPlayerCardLimitation(player, "discard", ".|black|.|hand", true)
		room:setPlayerFlag(player, "XiahuiInvoked")
	end,
}
XiahuiKeep = sgs.CreateMaxCardsSkill{
	name = "#Xiahui-keep",
	extra_func = function(self, target)
		if target:hasShownSkill("Xiahui") and target:getPhase() == sgs.Player_Discard then
			local n = 0
			for _, card in sgs.qlist(target:getHandcards()) do
				if card:isBlack() then n = n + 1 end
			end
			return n
		end
	end
}
XiahuiClear = sgs.CreateTriggerSkill{
	name = "#Xiahui-clear",
	events = {sgs.EventPhaseEnd},
	priority = -1,
	global = true,
	on_record = function(self, event, room, player, data)
		if player:getPhase() == sgs.Player_Discard and player:hasFlag("XiahuiInvoked") then
			room:removePlayerCardLimitation(player, "discard", ".|black|.|hand$1")
			room:setPlayerFlag(player, "-XiahuiInvoked")
		end
		return ""
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
DongBai:addSkill(Xiahui)
DongBai:addSkill(XiahuiRecord)
DongBai:addSkill(XiahuiDiscard)
DongBai:addSkill(XiahuiKeep)
DongBai:addSkill(XiahuiClear)
sgs.insertRelatedSkills(extensionOL, "Xiahui", "#Xiahui-record", "#Xiahui-discard", "#Xiahui-keep", "#Xiahui-clear")

-----------------------------------------------OL修订-----------------------------------------------

extensionOLRenew = sgs.Package("OLRenew", sgs.Package_GeneralPack)

--[[ （LE 005） 神曹操
	武将：ShenCaoCao_OL
	武将名：神曹操
	体力上限：3
	武将技能：
		归心：当你受到1点伤害后，你可以选择一个区域的名称，随机获得每名其他角色此区域内的一张牌，然后叠置。
		飞影：锁定技，其他角色与你的距离+1。
	状态：验证通过
]]--
ShenCaoCao_OL = sgs.General(extensionOLRenew, "ShenCaoCao_OL", "god", 3, true, true)

--[[
	技能名：归心
	技能：GuixinOL
	描述：当你受到1点伤害后，你可以选择一个区域的名称，随机获得每名其他角色此区域内的一张牌，然后叠置。
	状态：验证通过
]]--
GuixinOL = sgs.CreateMasochismSkill{
	name = "GuixinOL",
	can_preshow = true,
	on_record = function(self, event, room, player, data)	
		if not player or player:isDead() or not player:hasSkill(self:objectName()) then return false end
		player:setMark("OldGuixinOLTimes", player:getMark("GuixinOLTimes"))  --插入结算（但是很难维护，而且没法处理三重嵌套）
		player:setMark("GuixinOLTimes", 0)  --for AI
	end,
	can_trigger = function(self, event, room, player, data)	
		if not player or player:isDead() or not player:hasSkill(self:objectName()) then return false end
		local canGet = false
		for _,p in sgs.qlist(room:getOtherPlayers(player)) do
			if p:isAlive() and not p:isAllNude() then canGet = true break end
		end
		if not canGet then return "" end
		local trigger_list = {}
		local damage = data:toDamage()
		for i = 1, damage.damage, 1 do
			table.insert(trigger_list, self:objectName())
		end
		return table.concat(trigger_list, ",")
	end,
	on_cost = function(self, event, room, player, data)
		player:addMark("GuixinOLTimes")
		if room:askForSkillInvoke(player, self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), player)
			room:doSuperLightbox("ShenCaoCao_OL", self:objectName())
			local choice = room:askForChoice(player, self:objectName(), "h+e+j")
			if not choice then return false end
			player:setTag("GuixinOLFlag", sgs.QVariant(choice))
			return true
		end
		player:setMark("GuixinOLTimes", player:getMark("OldGuixinOLTimes"))
		player:setMark("OldGuixinOLTimes", 0)
		return false
	end,
	on_damaged = function(self, player, damage)
		local room = player:getRoom()
		player:setFlags("GuixinOLUsing")  --Useless flag?
		local choice = player:getTag("GuixinOLFlag"):toString()
		player:removeTag("GuixinOLFlag")
		local flags_table = {h = "hej", e = "ehj", j = "jhe"}
		local flags = flags_table[choice]
		for _,p in sgs.qlist(room:getOtherPlayers(player)) do
			if p:isAlive() and not p:isAllNude() then
				--[[local flags, flags_avail = {"h", "e", "j"}, {}
				for _,flag in ipairs(flags) do
					if not p:getCards(flag):isEmpty() then table.insert(flags_avail, flag) end
				end
				local choice = room:askForChoice(player, self:objectName(), table.concat(flags_avail, "+"))
				if not choice then continue end
				local cards = p:getCards(choice)]]
				local canGet = false
				local cards = sgs.CardList()
				for i = 1, #flags do
					if not p:getCards(string.sub(flags, i, i)):isEmpty() then
						canGet = true
						cards = p:getCards(string.sub(flags, i, i))
						break
					end
				end
				if not canGet then continue end
				local card = cards:at(math.random(0, cards:length() - 1))
				local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_EXTRACTION, player:objectName(), self:objectName(), "")
				room:obtainCard(player, card, reason, false)
				
				if player:isDead() then
					player:setFlags("-GuixinOLUsing")
					player:setMark("GuixinOLTimes", 0)
					player:setMark("OldGuixinOLTimes", 0)
					return
				end
			end
		end
		player:turnOver()
		player:setFlags("-GuixinOLUsing")
		if player:getMark("GuixinOLTimes") == damage.damage then
			player:setMark("GuixinOLTimes", player:getMark("OldGuixinOLTimes"))
			player:setMark("OldGuixinOLTimes", 0)
		end
	end,
	on_turn_broken = function(self, function_name, event, room, player, data, ask_who)
		player:setFlags("-GuixinOLUsing")
		player:setMark("GuixinOLTimes", player:getMark("OldGuixinOLTimes"))
		player:setMark("OldGuixinOLTimes", 0)
		player:removeTag("GuixinOLFlag")
	end
}
ShenCaoCao_OL:addSkill(GuixinOL)

--[[
	技能名：飞影
	技能：feiying_ShenCaoCao_OL
	描述：锁定技，其他角色与你的距离+1。
	状态：验证通过
]]--
feiying_ShenCaoCao_OL = sgs.CreateFeiyingSkill("ShenCaoCao_OL")
ShenCaoCao_OL:addSkill(feiying_ShenCaoCao_OL)

----------------------------------------------------------------------------------------------------

--[[ （YJ 110） 王异
	武将：WangYi_OL
	武将名：王异
	体力上限：3
	武将技能：
		贞烈：当你成为其他角色使用【杀】或普通锦囊牌的目标后，你可以失去1点体力，令此牌对你无效，然后你弃置其一张牌。
		秘计：结束阶段开始时，若你已受伤，你可以摸一至X张牌（X为你已损失的体力值），然后你可以将等量的手牌交给其他角色。
	状态：复制手册
]]--
WangYi_OL = sgs.General(extensionOLRenew, "WangYi_OL", "wei", 3, false, true)

--[[
	技能名：贞烈
	技能：Zhenlie
	描述：当你成为其他角色使用【杀】或普通锦囊牌的目标后，你可以失去1点体力，令此牌对你无效，然后你弃置其一张牌。
	状态：复制手册
]]--
Zhenlie_WangYi_OL = sgs.CreateZhenlieSkill("WangYi_OL")
WangYi_OL:addSkill(Zhenlie_WangYi_OL)

--[[
	技能名：秘计
	技能：MijiOL
	描述：结束阶段开始时，若你已受伤，你可以摸一至X张牌（X为你已损失的体力值），然后你可以将等量的手牌交给其他角色。
	状态：复制手册并小改
]]--
MijiOLCard = sgs.CreateSkillCard{
	name = "MijiOLCard",
	skill_name = "MijiOL",
	target_fixed = false,
	will_throw = false,
	mute = true,
	handling_method = sgs.Card_MethodNone,
	filter = function(self, targets, to_select, player)
		return #targets == 0 and to_select:objectName() ~= player:objectName()
	end,
	feasible = function(self, targets, player)
		return #targets == 1
	end,
	about_to_use = function(self, room, cardUse)
		local source, target = cardUse.from, cardUse.to:at(0)
		room:removePlayerMark(source, self:getSkillName().."_num", self:subcardsLength())
		local data = sgs.QVariant()
		data:setValue(target)
		source:setTag(self:getSkillName().."_target", data)
	end,
}
MijiOLVS = sgs.CreateViewAsSkill{   
	name = "MijiOL",
	view_filter = function(self, selected, to_select)
		return sgs.Self:getMark(self:objectName().."_num") > #selected and table.contains(sgs.Self:property(self:objectName().."_hands"):toString():split("+"), tostring(to_select:getId()))
	end, 
	view_as = function(self, originalCards) 
		if #originalCards > 0 then
			local skillcard = MijiOLCard:clone()
			for _, card in ipairs(originalCards) do
				skillcard:addSubcard(card)
			end
			skillcard:setSkillName(self:objectName())
			return skillcard
		end
	end, 
	enabled_at_play = function(self, player)
		return false
	end,
	enabled_at_response = function(self, player, pattern)
		return string.startsWith(pattern, "@@"..self:objectName())
	end,
}
MijiOL = sgs.CreateTriggerSkill{
	name = "MijiOL",
	can_preshow = true,
	events = {sgs.EventPhaseStart},
	view_as_skill = MijiOLVS,
	can_trigger = function(self, event, room, player, data)
		if player and player:isAlive() and player:hasSkill(self:objectName()) then
			if player:getPhase() == sgs.Player_Finish and player:isWounded() then
				return self:objectName()
			end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		if player:askForSkillInvoke(self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), player)
			return true
		end
		return false 
	end,
	on_effect = function(self, event, room, player, data)
		local num = 1
		if player:getLostHp() > 1 then
			local nums = "1"
			for i = 2, player:getLostHp() do
				nums = (math.mod(i, 5) == 1) and nums.."|"..i or nums.."+"..i
			end
			num = tonumber(room:askForChoice(player, "MijiOL_draw", nums))
		end
		player:drawCards(num, self:objectName())
		num = math.min(num, player:getHandcardNum())
		if num <= 0 then return end
		room:setPlayerMark(player, self:objectName() .. "_num", num)
		
		if player:isKongcheng() then return end
		
		local ids, get = sgs.QList2Table(player:handCards()), {}

		local pattern, prompt = "@@"..self:objectName(), "@"..self:objectName()..":::"
		while #ids > 0 and player:getMark(self:objectName().."_num") > 0 do
			room:setPlayerProperty(player, self:objectName().."_hands", sgs.QVariant(table.concat(ids, "+")))
			local u_card = room:askForUseCard(player, pattern, prompt..player:getMark(self:objectName().."_num") )
			if not u_card then
				break
			end
			local target = player:getTag(self:objectName().."_target"):toPlayer()

			for _, id in sgs.qlist(u_card:getSubcards()) do
				table.removeOne(ids, id)
				table.insert(get, target:objectName().."|"..id)
			end
			pattern = "@@"..self:objectName().."!" 
			prompt = "@"..self:objectName().."2:::"
		end
		
		if string.sub(pattern, -1, -1) == "!" and (player:getMark(self:objectName() .. "_num") > 0) and (#ids > 0) and (not player:isKongcheng()) then  --Give the remaining cards randomly
			local rest_num = player:getMark(self:objectName() .. "_num")
			for i = 1, rest_num, 1 do
				id = ids[math.random(1, #ids)]
				local receiver = room:getOtherPlayers(player):at(math.random(0, player:aliveCount() - 2))
				table.insert(get, receiver:objectName() .. "|" .. id) 
				table.removeOne(ids, id)
			end
		end

		local moves = sgs.CardsMoveList()
		local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_GIVE, player:objectName(), self:objectName(), "")
		for _, p in sgs.qlist(room:getAllPlayers()) do
			local _ids = sgs.IntList()
			for _, toget in ipairs(get) do
				if toget:split("|")[1] == p:objectName() then _ids:append(tonumber(toget:split("|")[2])) end
			end
			if not _ids:isEmpty() then
				local move = sgs.CardsMoveStruct(_ids, player, p, sgs.Player_PlaceHand, sgs.Player_PlaceHand, reason)
				moves:append(move)
			end
		end
		player:setMark(self:objectName().."_num", 0)
		if not moves:isEmpty() then
			room:moveCardsAtomic(moves, false)
		end
		
		return false 
	end,
}
WangYi_OL:addSkill(MijiOL)

----------------------------------------------------------------------------------------------------

--[[ （YJ 302） 曹真
	武将：CaoZhen_OL
	武将名：曹真-OL
	体力上限：4
	武将技能：
		司敌：其他角色的出牌阶段开始时，你可以弃置一张与装备区里的牌颜色相同的非基本牌，令其本回合不能使用或打出与此装备牌颜色相同的牌，若如此做，此阶段结束时，若其未于此回合内使用过【杀】，你视为对其使用【杀】。
	状态：验证通过
]]--
CaoZhen_OL = sgs.General(extensionOLRenew, "CaoZhen_OL", "wei", 4, true)

--[[
	技能名：司敌
	技能：SidiOL
	描述：其他角色的出牌阶段开始时，你可以弃置一张与装备区里的牌颜色相同的非基本牌，令其本回合不能使用或打出与此装备牌颜色相同的牌，若如此做，此阶段结束时，若其未于此回合内使用过【杀】，你视为对其使用【杀】。
	状态：验证通过
]]--
SidiOL = sgs.CreateTriggerSkill{
	name = "SidiOL",
	can_preshow = true,
	events = {sgs.EventPhaseStart},
	can_trigger = function(self, event, room, player, data)
		if player:getPhase() == sgs.Player_Play then
			local skill_list = {}
			local name_list = {}
			for _, p in sgs.qlist(room:findPlayersBySkillName(self:objectName())) do
				if p ~= player and not p:getEquips():isEmpty() then
					table.insert(skill_list, self:objectName())
					table.insert(name_list, p:objectName())
				end
			end
			return table.concat(skill_list, "|"), table.concat(name_list, "|")
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		if ask_who and not ask_who:getEquips():isEmpty() then
			local colors = {}
			local color_strings = {"red", "black", ""}
			for _,equip in sgs.qlist(ask_who:getEquips()) do
				if not table.contains(colors, color_strings[equip:getColor() + 1]) then
					table.insert(colors, color_strings[equip:getColor() + 1])
				end
			end
			if not next(colors) then return false end
			local card = room:askForCard(ask_who, "EquipCard,TrickCard|" .. table.concat(colors, ","), "@SidiOL:" .. player:objectName(), data, self:objectName())
			if card then
				room:broadcastSkillInvoke(self:objectName(), 1, ask_who)
				local color_str = color_strings[card:getColor() + 1]
				ask_who:setTag("SidiOLColor", sgs.QVariant(color_str))
				return true
			end
		end
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		ask_who:setFlags("SidiOLInvoked")
		local color_str = ask_who:getTag("SidiOLColor"):toString()
		ask_who:removeTag("SidiOLColor")
		if not color_str or color_str == "" then return end
		room:setPlayerCardLimitation(player, "use,response", ".|" .. color_str, true)
		
		local msg = sgs.LogMessage()
		msg.type, msg.from, msg.arg = "#SidiOL", player, "no_suit_" .. color_str
		room:sendLog(msg)
	end,
	on_turn_broken = function(self, function_name, event, room, player, data, ask_who)
		ask_who:removeTag("SidiOLColor")
	end
}
SidiOLSlash = sgs.CreateTriggerSkill{
	name = "#SidiOL-slash",
	events = {sgs.PreCardUsed, sgs.EventPhaseEnd},
	frequency = sgs.Skill_Wake,
	global = true,
	on_record = function(self, event, room, player, data)
		if event == sgs.PreCardUsed then
			local card = data:toCardUse().card
			if card and card:getHandlingMethod() == sgs.Card_MethodUse and card:isKindOf("Slash") then
				if player:getPhase() ~= sgs.Player_NotActive then player:setFlags("SidiOLSlashInTurn") end
			end
		end
	end,
	can_trigger = function(self, event, room, player, data)
		if event == sgs.EventPhaseEnd and player:isAlive() and player:getPhase() == sgs.Player_Play and not player:hasFlag("SidiOLSlashInTurn") then
			local skill_list = {}
			local name_list = {}
			for _, p in sgs.qlist(room:getOtherPlayers(player)) do
				if p:hasFlag("SidiOLInvoked") and p:canSlash(player, false) then
					table.insert(skill_list, self:objectName())
					table.insert(name_list, p:objectName())
				end
			end
			return table.concat(skill_list, "|"), table.concat(name_list, "|")
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		return true
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		local slash = sgs.Sanguosha:cloneCard("slash", sgs.Card_NoSuit, 0)
		slash:setSkillName("_SidiOL")
		room:useCard(sgs.CardUseStruct(slash, ask_who, player))
	end,
}
SidiOLClear = sgs.CreateTriggerSkill{
	name = "#SidiOL-clear",
	events = {sgs.EventPhaseEnd},
	global = true,
	priority = -1,
	on_record = function(self, event, room, player, data)
		if player:getPhase() ~= sgs.Player_Play then return end
		for _, p in sgs.qlist(room:getOtherPlayers(player)) do
			p:setFlags("-SidiOLInvoked")
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
CaoZhen_OL:addSkill(SidiOL)
CaoZhen_OL:addSkill(SidiOLSlash)
CaoZhen_OL:addSkill(SidiOLClear)
sgs.insertRelatedSkills(extensionOLRenew, "SidiOL", "#SidiOL-slash", "#SidiOL-clear")

----------------------------------------------------------------------------------------------------

--[[ （YJ 310） 周仓
	武将：ZhouCang_OL
	武将名：周仓-OL
	体力上限：4
	武将技能：
		忠勇：当你使用的【杀】结算结束后，你可以将此【杀】或目标角色使用的所有【闪】交给一名不为此【杀】目标的其他角色，以此法获得红色牌的角色可以对你攻击范围内的一名角色使用一张【杀】（无距离限制）。
	状态：验证通过
]]--
ZhouCang_OL = sgs.General(extensionOLRenew, "ZhouCang_OL", "shu", 4, true)
ZhouCang_OL:addCompanion("guanyu")
ZhouCang_OL:addCompanion("GuanYu_LB")

--[[
	技能名：忠勇
	技能：ZhongyongOL
	描述：当你使用的【杀】结算结束后，你可以将此【杀】或目标角色使用的所有【闪】交给一名不为此【杀】目标的其他角色，以此法获得红色牌的角色可以对你攻击范围内的一名角色使用一张【杀】（无距离限制）。
	状态：验证通过
	注：如果在杀的使用结算中插入一张toString完全相同的杀，可能会导致结算bug（因为是靠toString存储信息的）
]]--
ZhongyongOLRecord1 = sgs.CreateTriggerSkill{
	name = "#ZhongyongOL-record1",
	events = {sgs.SlashProceed},
	--[[由于技能要求仅记录所有响应此杀使用的闪，思路如下：
	1. 在SlashProceed记录目标需要使用的闪的数量，且设置Mark（同时记录此杀）；（入栈）
	2. 然后目标选择是否使用闪，如果使用，则在JinkEffect会收到此闪，此时判断是否有Mark，有的话就是响应此杀使用的闪了，记下来；
	3. 最后在SlashProceed的Gamerule执行完以后出栈（保证不会入了栈却不出）。
	]]
	priority = 1,
	global = true,
    on_record = function(self, event, room, player, data)
		local effect = data:toSlashEffect()
		local slashes = effect.to:getTag("ZhongyongOLSlashStack"):toString():split("|")
		table.removeAll(slashes, "")
		local jink_nums = effect.to:getTag("ZhongyongOLJinkNumStack"):toString():split("|")
		table.removeAll(jink_nums, "")
		local jinks = effect.to:getTag("ZhongyongOLJinkRespondedStack"):toString():split("|") 
		table.removeAll(jinks, "")
		table.insert(slashes, effect.slash:toString())
		table.insert(jink_nums, effect.jink_num)
		table.insert(jinks, "-1")  --占位
		effect.to:setTag("ZhongyongOLSlashStack", sgs.QVariant(table.concat(slashes, "|")))
		effect.to:setTag("ZhongyongOLJinkNumStack", sgs.QVariant(table.concat(jink_nums, "|")))
		effect.to:setTag("ZhongyongOLJinkRespondedStack", sgs.QVariant(table.concat(jinks, "|")))
	end,
    can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
ZhongyongOLRecord2 = sgs.CreateTriggerSkill{
	name = "#ZhongyongOL-record2",
	events = {sgs.JinkEffect},
	priority = 8,
	global = true,
    on_record = function(self, event, room, player, data)
		local jink_nums = player:getTag("ZhongyongOLJinkNumStack"):toString():split("|")
		table.removeAll(jink_nums, "")
		local jinks = player:getTag("ZhongyongOLJinkRespondedStack"):toString():split("|")
		table.removeAll(jinks, "")
		if #jink_nums == 0 or tonumber(jink_nums[#jink_nums]) == 0 --[[or #sources == 0]] then return end  --已经响应完闪，说明有bug或奇葩插入结算
		
		local jink = data:toCard()
		local id_tab = {}
		if jink:isVirtualCard() then
			id_tab = sgs.QList2Table(jink:getSubcards())
		else
			table.insert(id_tab, jink:getEffectiveId())
		end
		local jinksOneTime = jinks[#jinks]:split("+")
		table.removeAll(jinksOneTime, "")
		table.insert(jinksOneTime, table.concat(id_tab, "~"))  --jinks栈的每个元素记录方式：-1+闪1子卡1~闪1子卡2+闪2子卡+闪3子卡+……（因为子卡必须全在弃牌堆）
		jink_nums[#jink_nums] = tostring(tonumber(jink_nums[#jink_nums]) - 1)  --注意不要删除！到出栈时再删除
		jinks[#jinks] = table.concat(jinksOneTime, "+")
		player:setTag("ZhongyongOLJinkNumStack", sgs.QVariant(table.concat(jink_nums, "|")))
		player:setTag("ZhongyongOLJinkRespondedStack", sgs.QVariant(table.concat(jinks, "|")))
	end,
    can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
ZhongyongOLRecord3 = sgs.CreateTriggerSkill{
	name = "#ZhongyongOL-record3",
	events = {sgs.SlashProceed},
	priority = -1,
	global = true,
    on_record = function(self, event, room, player, data)
		local effect = data:toSlashEffect()
		local slashes = effect.to:getTag("ZhongyongOLSlashStack"):toString():split("|")
		table.removeAll(slashes, "")
		local jink_nums = effect.to:getTag("ZhongyongOLJinkNumStack"):toString():split("|")
		table.removeAll(jink_nums, "")
		local jinks = effect.to:getTag("ZhongyongOLJinkRespondedStack"):toString():split("|") 
		table.removeAll(jinks, "")
		if not next(slashes) or not slashes[#slashes] or (slashes[#slashes] ~= effect.slash:toString()) then
			room:writeToConsole("Error with ZhongyongOL Stack pop")
			return
		end
		
		local jinksOneTime = jinks[#jinks]:split("+")
		table.removeAll(jinksOneTime, "")
		table.removeAll(jinksOneTime, "-1")
		if next(jinksOneTime) then  --注：根据OL结算，多目标的杀结算后只能选择要么给杀，要么给所有闪，因此直接将所有闪记录在一起
			local jinksReceived = effect.from:getTag("ZhongyongOLJinksReceived_" .. effect.slash:toString()):toString():split("+")  --记录所有目标响应此杀使用的所有闪
			table.removeAll(jinksReceived, "")
			table.insertTable(jinksReceived, jinksOneTime)
			effect.from:setTag("ZhongyongOLJinksReceived_" .. effect.slash:toString(), sgs.QVariant(table.concat(jinksReceived, "+")))
		end
		
		table.remove(slashes, #slashes)
		if next(slashes) then effect.to:setTag("ZhongyongOLSlashStack", sgs.QVariant(table.concat(slashes, "|"))) else effect.to:removeTag("ZhongyongOLSlashStack") end
		table.remove(jink_nums, #jink_nums)
		if next(jink_nums) then effect.to:setTag("ZhongyongOLJinkNumStack", sgs.QVariant(table.concat(jink_nums, "|"))) else effect.to:removeTag("ZhongyongOLJinkNumStack") end
		table.remove(jinks, #jinks)
		if next(jinks) then effect.to:setTag("ZhongyongOLJinkRespondedStack", sgs.QVariant(table.concat(jinks, "|"))) else effect.to:removeTag("ZhongyongOLJinkRespondedStack") end
	end,
    can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
ZhongyongOLCard = sgs.CreateSkillCard{
	name = "ZhongyongOLCard",
	skill_name = "ZhongyongOL",
	target_fixed = false,
	will_throw = false,
	handling_method = sgs.Card_MethodNone,
	filter = function(self, targets, to_select, player)
		return #targets == 0 and to_select:hasFlag("ZhongyongOLAvailable")
	end,
	about_to_use = function(self, room, cardUse)
		local source, target = cardUse.from, cardUse.to:at(0)
		local data = sgs.QVariant()
		data:setValue(target)
		source:setTag("ZhongyongOLTarget", data)
		local data2 = sgs.QVariant()
		data2:setValue(self)
		source:setTag("ZhongyongOLToGive", data2)
	end,
}
ZhongyongOLVS = sgs.CreateViewAsSkill{
	name = "ZhongyongOL",
	response_pattern = "@@ZhongyongOL",
	expand_pile = "#ZhongyongOL",
	view_filter = function(self, selected, to_select)
		local toGet = sgs.Self:property("ZhongyongOLCards"):toString():split("|")
		for _,toGetOneTime_str in pairs(toGet) do
			local toGetOneTime = toGetOneTime_str:split("+")
			if #selected == 0 and table.contains(toGetOneTime, tostring(to_select:getId())) then return true
			elseif #selected > 0 and table.contains(toGetOneTime, tostring(selected[1]:getId())) and table.contains(toGetOneTime, tostring(to_select:getId())) then return true end
		end
		return false
	end, 
	view_as = function(self, originalCards) 
		local containsAll = false
		local toGet = sgs.Self:property("ZhongyongOLCards"):toString():split("|")
		for _,toGetOneTime_str in pairs(toGet) do
			local toGetOneTime = toGetOneTime_str:split("+")
			containsAll = true
			if #toGetOneTime ~= #originalCards then containsAll = false continue end
			for _,card in pairs(originalCards) do
				if not table.contains(toGetOneTime, tostring(card:getId())) then containsAll = false continue end
			end
			if containsAll then break end
		end
		if containsAll then
			local skillcard = ZhongyongOLCard:clone()
			for _, card in ipairs(originalCards) do
				skillcard:addSubcard(card)
			end
			skillcard:setSkillName(self:objectName())
			return skillcard
		end
	end,
}
ZhongyongOL = sgs.CreateTriggerSkill{
	name = "ZhongyongOL",
	can_preshow = true,
	events = {sgs.CardFinished},
	view_as_skill = ZhongyongOLVS,
    can_trigger = function(self, event, room, player, data)
		local use = data:toCardUse()
		if use.from and use.from:isAlive() and use.from:hasSkill(self) and use.card and use.card:isKindOf("Slash") then
			--一定不要用player代替use.from！为了获得真正的使用者（谮毁），因为CardUsed到CardFinished之间不会检测使用者的变化从而改变player
			local toGet, toGetOneTime, toGetOneTime_Temp = {}, {}, {}
			
			if use.card:isVirtualCard() then
				toGetOneTime_Temp = sgs.QList2Table(use.card:getSubcards())
			else
				table.insert(toGetOneTime_Temp, use.card:getEffectiveId())
			end
			local all_discard_pile = true
			for _,id in ipairs(toGetOneTime_Temp) do
				if room:getCardPlace(id) ~= sgs.Player_DiscardPile then all_discard_pile = false break end
			end
			if all_discard_pile then table.insert(toGet, table.concat(toGetOneTime_Temp, "+")) end
			
			local jinksReceived = use.from:getTag("ZhongyongOLJinksReceived_" .. use.card:toString()):toString()
			if jinksReceived ~= "" then  --jinksReceived记录方式：-1+闪1子卡1~闪1子卡2+闪2子卡+闪3子卡+……（因为子卡必须全在弃牌堆）
				toGetOneTime_Temp = jinksReceived:split("+")
				toGetOneTime = {}
				for _,jinkIds in ipairs(toGetOneTime_Temp) do
					local all_discard_pile = true  --判断每张不同的闪的所有子卡是否均在弃牌堆
					for _,id in ipairs(jinkIds:split("~")) do
						if room:getCardPlace(tonumber(id)) ~= sgs.Player_DiscardPile then all_discard_pile = false break end
					end
					if all_discard_pile then
						for _,id in ipairs(jinkIds:split("~")) do
							table.insert(toGetOneTime, tonumber(id))
						end
					end
				end
				if next(toGetOneTime) then table.insert(toGet, table.concat(toGetOneTime, "+")) end
			end
			if not next(toGet) then return "" end
			
			for _,p in sgs.qlist(room:getOtherPlayers(use.from)) do
				if not use.to:contains(p) then
					return self:objectName(), use.from
				end
			end
		end
		return ""
	end,
    on_cost = function(self, event, room, player, data, ask_who)
		local use = data:toCardUse()
		local toGet, toGetOneTime, toGetOneTime_Temp = {}, {}, {}
		local ids = sgs.IntList()
			
		if use.card:isVirtualCard() then
			toGetOneTime_Temp = sgs.QList2Table(use.card:getSubcards())
		else
			table.insert(toGetOneTime_Temp, use.card:getEffectiveId())
		end
		local all_discard_pile = true
		for _,id in ipairs(toGetOneTime_Temp) do
			if room:getCardPlace(id) ~= sgs.Player_DiscardPile then all_discard_pile = false break end
		end
		if all_discard_pile then table.insert(toGet, table.concat(toGetOneTime_Temp, "+")) end
		
		local jinksReceived = use.from:getTag("ZhongyongOLJinksReceived_" .. use.card:toString()):toString()
		if jinksReceived ~= "" then  --jinksReceived记录方式：-1+闪1子卡1~闪1子卡2+闪2子卡+闪3子卡+……（因为子卡必须全在弃牌堆）
			toGetOneTime_Temp = jinksReceived:split("+")
			toGetOneTime = {}
			for _,jinkIds in ipairs(toGetOneTime_Temp) do
				local all_discard_pile = true  --判断每张不同的闪的所有子卡是否均在弃牌堆
				for _,id in ipairs(jinkIds:split("~")) do
					if room:getCardPlace(tonumber(id)) ~= sgs.Player_DiscardPile then all_discard_pile = false break end
				end
				if all_discard_pile then
					for _,id in ipairs(jinkIds:split("~")) do
						table.insert(toGetOneTime, tonumber(id))
					end
				end
			end
			if next(toGetOneTime) then table.insert(toGet, table.concat(toGetOneTime, "+")) end
		end
		if not next(toGet) then return "" end
		
		local list = sgs.SPlayerList()
		for _,p in sgs.qlist(room:getOtherPlayers(use.from)) do
			if not use.to:contains(p) then
				list:append(p)
				room:setPlayerFlag(p, "ZhongyongOLAvailable")
			end
		end
		if list:isEmpty() then return false end
		
		room:setPlayerProperty(ask_who, "ZhongyongOLCards", sgs.QVariant(table.concat(toGet, "|")))  --格式：slash1+slash2|jink1+jink2+...
		ask_who:removeTag("ZhongyongOLTarget")
		ask_who:removeTag("ZhongyongOLToGive")
		for _,cardids in ipairs(toGet) do
			for _,id in ipairs(cardids:split("+")) do
				ids:append(tonumber(id))
			end
		end
		room:notifyMoveToPile(ask_who, ids, self:objectName(), sgs.Player_DiscardPile, true, true)
		local invoked = room:askForUseCard(ask_who, "@@ZhongyongOL", "@ZhongyongOL", -1, sgs.Card_MethodNone)
		
		room:notifyMoveToPile(ask_who, ids, self:objectName(), sgs.Player_DiscardPile, false, false)
		room:setPlayerProperty(ask_who, "ZhongyongOLCards", sgs.QVariant())
		for _,p in sgs.qlist(list) do
			room:setPlayerFlag(p, "-ZhongyongOLAvailable")
		end
		if invoked then
			room:broadcastSkillInvoke(self:objectName(), ask_who:inDeputySkills(self) and 2 or 1, ask_who)
			local msg = sgs.LogMessage()
			msg.type, msg.from, msg.arg = "#InvokeSkill", ask_who, self:objectName()
			room:sendLog(msg)
			return true
		end
		return false
	end,
    on_effect = function(self, event, room, player, data, ask_who)
		local target = ask_who:getTag("ZhongyongOLTarget"):toPlayer()
		ask_who:removeTag("ZhongyongOLTarget")
		local skillCard = ask_who:getTag("ZhongyongOLToGive"):toCard()
		ask_who:removeTag("ZhongyongOLToGive")
		if not target or target:isDead() or not skillCard then return end
		
		local red = false
		for _,id in sgs.qlist(skillCard:getSubcards()) do
			if sgs.Sanguosha:getCard(id):isRed() then red = true break end
		end
		local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_GIVE, ask_who:objectName(), self:objectName(), "")
		room:obtainCard(target, skillCard, reason)
		
		if red and target and target:isAlive() and target:objectName()~= ask_who:objectName() then
			local slashlist = sgs.SPlayerList()
			for _,p in sgs.qlist(room:getOtherPlayers(ask_who)) do
				if ask_who:inMyAttackRange(p) and target:canSlash(p, false) then
					slashlist:append(p)
				end
			end
			if slashlist:isEmpty() then return false end
			room:askForUseSlashTo(target, slashlist, "@ZhongyongOL-slash:" .. ask_who:objectName(), false)
		end
	end,
}
ZhongyongOLClear = sgs.CreateTriggerSkill{
	name = "#ZhongyongOL-clear",
	events = {sgs.CardFinished},
	global = true,
	priority = 1,
    on_record = function(self, event, room, player, data)
		local use = data:toCardUse()
		if use.card and use.card:isKindOf("Slash") then
			--use.card:removeTag("ZhongyongOLJinksReceived")
			use.from:removeTag("ZhongyongOLJinksReceived_" .. use.card:toString())
		end
	end,
    can_trigger = function(self, event, room, player, data, ask_who)
		return ""
	end,
}
ZhouCang_OL:addSkill(ZhongyongOL)
ZhouCang_OL:addSkill(ZhongyongOLRecord1)
ZhouCang_OL:addSkill(ZhongyongOLRecord2)
ZhouCang_OL:addSkill(ZhongyongOLRecord3)
ZhouCang_OL:addSkill(ZhongyongOLClear)
sgs.insertRelatedSkills(extensionOLRenew, "ZhongyongOL", "#ZhongyongOL-record1", "#ZhongyongOL-record2", "#ZhongyongOL-record3", "#ZhongyongOL-clear")

----------------------------------------------------------------------------------------------------

--[[ （YC 008） 张让
	武将：ZhangRang_OL
	武将名：张让-OL
	体力上限：3
	武将技能：
		滔乱：若没有角色处于濒死状态，你可将一张牌当任意一张基本牌或普通锦囊牌使用（不能是你以此法使用过的牌），若如此做，你令一名其他角色选择一项：1. 将与此牌类别不同的一张牌交给你；2. 令你失去1点体力，然后令“滔乱”于此回合内无效。
	状态：验证通过
]]--
ZhangRang_OL = sgs.General(extensionOLRenew, "ZhangRang_OL", "qun", 3, true, true)

--[[
	技能名：滔乱
	技能：TaoluanOL
	描述：若没有角色处于濒死状态，你可将一张牌当任意一张基本牌或普通锦囊牌使用（不能是你以此法使用过的牌），若如此做，你令一名其他角色选择一项：1. 将与此牌类别不同的一张牌交给你；2. 令你失去1点体力，然后令“滔乱”于此回合内无效。
	状态：验证通过
	注：不要和风包于吉或张让双将！！（因为guhuo_box_allowed_elemet的问题，目前技能中是给张让专用的）
]]--
addTaoluanOLHistory = function(player, card)
	local pattern = card:objectName()
	local patterns = {pattern}
	if pattern == "fire_slash" or pattern == "thunder_slash" or pattern == "slash" then
		if not table.contains(patterns, "slash") then table.insert(patterns, "slash") end
		if not table.contains(patterns, "fire_slash") then table.insert(patterns, "fire_slash") end
		if not table.contains(patterns, "thunder_slash") then table.insert(patterns, "thunder_slash") end
	end
	if pattern == "nullification" or pattern == "heg_nullification" then
		if not table.contains(patterns, "nullification") then table.insert(patterns, "nullification") end
		if not table.contains(patterns, "heg_nullification") then table.insert(patterns, "heg_nullification") end
	end
	local room = player:getRoom()
	local allowed_table = player:property("guhuo_box_allowed_elemet"):toString():split("+")
	for _,pat in pairs(patterns) do
		table.removeAll(allowed_table, pat)
	end
	room:setPlayerProperty(player, "guhuo_box_allowed_elemet", sgs.QVariant(table.concat(allowed_table, "+")))
	
	local taoluan_cards = player:getTag("TaoluanOLCardsUsing"):toString():split("|")
	table.insert(taoluan_cards, card:toString())
	table.removeAll(taoluan_cards, "")
	player:setTag("TaoluanOLCardsUsing", sgs.QVariant(table.concat(taoluan_cards, "|")))
end
TaoluanOLCard = sgs.CreateSkillCard{
	name = "TaoluanOLCard",
	skill_name = "TaoluanOL",
	will_throw = false,
	filter = function(self, targets, to_select, player)
		local players = sgs.PlayerList()
		if next(targets) ~= nil then
			for i = 1 , #targets do
				players:append(targets[i])
			end
		end
		if sgs.Sanguosha:getCurrentCardUseReason() == sgs.CardUseStruct_CARD_USE_REASON_RESPONSE_USE then
            local card = nil
            if self:getUserString() and self:getUserString() ~= "" then
                card = sgs.Sanguosha:cloneCard(self:getUserString():split("+")[1])
                return card and card:targetFilter(players, to_select, player) and not player:isProhibited(to_select, card, players)
            end
        end
        local _card = sgs.Sanguosha:cloneCard(sgs.Self:getTag("TaoluanOL"):toString())
        if _card == nil or _card:targetFixed() then
            return false
        end
        local card = sgs.Sanguosha:cloneCard(_card)
		card:addSubcards(self:getSubcards())
        card:setCanRecast(false)
        card:deleteLater()
        return card and card:targetFilter(players, to_select, player) and not player:isProhibited(to_select, card, players) and card:isAvailable(player) and not player:isLocked(card)
	end,
	feasible = function(self, targets, player)
		local players = sgs.PlayerList()
		if next(targets) ~= nil then
			for i = 1 , #targets do
				players:append(targets[i])
			end
		end
		if sgs.Sanguosha:getCurrentCardUseReason() == sgs.CardUseStruct_CARD_USE_REASON_RESPONSE_USE then
            local card = nil
            if self:getUserString() and self:getUserString() ~= "" then
                card = sgs.Sanguosha:cloneCard(self:getUserString():split("+")[1])
                return card and card:targetsFeasible(players, player)
            end
        end
		local _card = sgs.Sanguosha:cloneCard(player:getTag("TaoluanOL"):toString())
        if _card == nil then
            return false
        end
		local card = sgs.Sanguosha:cloneCard(_card)
		card:addSubcards(self:getSubcards())
		local can_recast = card:canRecast()
		card:setCanRecast(false)
		card:deleteLater()
		
		if can_recast and not card:isKindOf("FightTogether") then   --知己知彼源码有bug（968行忘加rec &&）  todo：在新版本中已修复，无需单独判断
			if players:length() == 0 then return false end
		end
		return card and card:targetsFeasible(players, player) and card:isAvailable(player) and not player:isLocked(card)
    end,
	on_validate = function(self, card_use)
        local zhangrang = card_use.from
        local room = zhangrang:getRoom()
		
		local to_guhuo = self:getUserString()
        if to_guhuo == "slash" and sgs.Sanguosha:getCurrentCardUseReason() == sgs.CardUseStruct_CARD_USE_REASON_RESPONSE_USE then
			local dat = sgs.QVariant()
			dat:setValue(card_use)
			zhangrang:setTag("TaoluanSlashData", dat)  --for AI
            local guhuo_list = {}
            table.insert(guhuo_list, "slash")
            table.insert(guhuo_list, "normal_slash")
            table.insert(guhuo_list, "thunder_slash")
            table.insert(guhuo_list, "fire_slash")
            to_guhuo = room:askForChoice(zhangrang, "Taoluan_slash", table.concat(guhuo_list, "+"))
			zhangrang:removeTag("TaoluanSlashData")
            zhangrang:setTag("TaoluanSlash", sgs.QVariant(to_guhuo))  --Useless data?  (Maybe for AI)
        end
        local card = sgs.Sanguosha:getCard(self:getSubcards():first())
        local user_str = ""
        if to_guhuo == "slash" then
            if card:isKindOf("Slash") then
                user_str = card:objectName()
            else
                user_str = "slash"
            end
        elseif to_guhuo == "normal_slash" then
            user_str = "slash"
        else
            user_str = to_guhuo
        end
        --zhangrang:setTag("TaoluanSlash", sgs.QVariant(user_str))
		
		local use_card = sgs.Sanguosha:cloneCard(user_str)
        use_card:setSkillName("TaoluanOL")
        use_card:addSubcards(self:getSubcards())
        use_card:setCanRecast(false)
        use_card:setShowSkill("TaoluanOL")
		
		local available = true
		local tos = card_use.to
        for _, to in sgs.qlist(tos) do
            local skill = zhangrang:isProhibited(to, use_card)
            if skill then
				if skill:isVisible() then
					local msg = sgs.LogMessage()
					msg.type = "#SkillAvoid"
					msg.from = to
					msg.arg = skill:objectName()
					msg.arg2 = use_card:objectName()
					room:sendLog(msg)
					room:broadcastSkillInvoke(skill:objectName())
				end
                card_use.to:removeOne(to)
            end
			--[[if zhangrang:isProhibited(to, use_card) then
				available = false
				break
			end]]
        end
		available = available and use_card:isAvailable(zhangrang) and not zhangrang:isLocked(use_card)
		use_card:deleteLater()
		if not available then return nil end
		addTaoluanOLHistory(zhangrang, use_card)
        return use_card
    end,
    on_validate_in_response = function(self, zhangrang)
        local room = zhangrang:getRoom()
        local to_guhuo = ""
        if self:getUserString() == "peach+analeptic" then
			local save_cards = {}
			local allowed = zhangrang:property("guhuo_box_allowed_elemet"):toString():split("+")
			if table.contains(allowed, "peach") then table.insert(save_cards, "peach") end
			if table.contains(allowed, "analeptic") then table.insert(save_cards, "analeptic") end
            to_guhuo = room:askForChoice(zhangrang, "Taoluan_saveself", table.concat(save_cards, "+"))
            --zhangrang:setTag("BowuSaveSelf", sgs.QVariant(to_guhuo))
        elseif self:getUserString() == "slash" then
			local guhuo_list = {}
            table.insert(guhuo_list, "slash")
            table.insert(guhuo_list, "normal_slash")
            table.insert(guhuo_list, "thunder_slash")
            table.insert(guhuo_list, "fire_slash")
            to_guhuo = room:askForChoice(zhangrang, "Taoluan_slash", table.concat(guhuo_list, "+"))
            zhangrang:setTag("TaoluanSlash", sgs.QVariant(to_guhuo))  --Useless data?  (Maybe for AI)
        elseif self:getUserString() == "nullification" then
			to_guhuo = room:askForChoice(zhangrang, "Taoluan_nullification", "nullification+heg_nullification")
        else
            to_guhuo = self:getUserString()
        end
        local card = sgs.Sanguosha:getCard(self:getSubcards():first())
        local user_str = ""
        if to_guhuo == "slash" then
            if card:isKindOf("Slash") then
                user_str = card:objectName()
            else
                user_str = "slash"
            end
        elseif to_guhuo == "normal_slash" then
            user_str = "slash"
        else
            user_str = to_guhuo
        end
        local use_card = sgs.Sanguosha:cloneCard(user_str)
        use_card:setSkillName("TaoluanOL")
        use_card:addSubcards(self:getSubcards())
        use_card:setCanRecast(false)
        use_card:setShowSkill("TaoluanOL")
		use_card:deleteLater()
		if zhangrang:isLocked(use_card) then return nil end
		addTaoluanOLHistory(zhangrang, use_card)
        return use_card
    end
}
TaoluanOLVS = sgs.CreateOneCardViewAsSkill{   
	name = "TaoluanOL",
	filter_pattern = ".",
	response_or_use = true,
	view_as = function(self, cards)
		if sgs.Sanguosha:getCurrentCardUseReason() == sgs.CardUseStruct_CARD_USE_REASON_RESPONSE_USE then
            local card = TaoluanOLCard:clone()
            card:setUserString(sgs.Sanguosha:getCurrentCardUsePattern())
            card:addSubcard(cards)
			local realcard = sgs.Sanguosha:cloneCard(sgs.Sanguosha:getCurrentCardUsePattern():split(":")[1], sgs.Card_SuitToBeDecided, -1)
			card:setTargetFixed(realcard:targetFixed())
            return card
        end
		if sgs.Sanguosha:getCurrentCardUseReason() ~= sgs.CardUseStruct_CARD_USE_REASON_PLAY then return nil end
		local c = sgs.Self:getTag(self:objectName()):toString()
		if c ~= "" then
			local card = TaoluanOLCard:clone()
			card:setUserString(c)
            card:addSubcard(cards)
			local realcard = sgs.Sanguosha:cloneCard(c, sgs.Card_SuitToBeDecided, -1)
			card:setTargetFixed(realcard:targetFixed())
			return card
		end
		return nil
	end,
	enabled_at_play = function(self, player)
		if (player:getMark("TaoluanOLProhibited") > 0) or player:isNude() then return false end
		local players = player:getAliveSiblings()
		players:append(player)
		for _, p in sgs.qlist(players) do
			if p:hasFlag("Global_Dying") then return false end
		end
		
		local allowed = player:property("guhuo_box_allowed_elemet"):toString():split("+")
		for _, name in ipairs(allowed) do
			if name == "" then continue end
			local card = sgs.Sanguosha:cloneCard(name, sgs.Card_SuitToBeDecided, -1)
			if card:isAvailable(player) then
				return true
			end
		end
		return false
	end,
	enabled_at_response = function(self, player, pattern)
		if (player:getMark("TaoluanOLProhibited") > 0) or player:isNude() then return false end
		if (sgs.Sanguosha:getCurrentCardUseReason() ~= sgs.CardUseStruct_CARD_USE_REASON_RESPONSE_USE) then return false end
		local players = player:getAliveSiblings()
		players:append(player)
		for _, p in sgs.qlist(players) do
			if p:hasFlag("Global_Dying") then return false end
		end
		
        if string.sub(pattern, 1, 1) == "." or string.sub(pattern, 1, 1) == "@" then
            return false
        end
        if (pattern == "peach") and (player:getMark("Global_PreventPeach") > 0) then return false end
        if string.find(pattern, "[%u%d]") then return false end--这是个极其肮脏的黑客！！ 因此我们需要去阻止基本牌模式
		local patterns = pattern:split("+")
		local allowed = player:property("guhuo_box_allowed_elemet"):toString():split("+")
		for _,pat in pairs(patterns) do
			if table.contains(allowed, pat) then
				return true
			end
		end
		return false
    end,
	enabled_at_nullification = function(self, player)
		if (player:getMark("TaoluanOLProhibited") > 0) or player:isNude() then return false end
		local players = player:getAliveSiblings()
		players:append(player)
		for _, p in sgs.qlist(players) do
			if p:hasFlag("Global_Dying") then return false end
		end
		
		local allowed = player:property("guhuo_box_allowed_elemet"):toString():split("+")
		return table.contains(allowed, "nullification")
    end
}
TaoluanOL = sgs.CreateTriggerSkill{
	name = "TaoluanOL",
	can_preshow = false,
	events = {sgs.GameStart, sgs.DFDebut, sgs.GeneralShown, sgs.EventAcquireSkill, sgs.EventLoseSkill},
	guhuo_type = "bt",
	view_as_skill = TaoluanOLVS,
	on_record = function(self, event, room, player, data)
		if (event == sgs.EventAcquireSkill and data:toString() == self:objectName()) or (event == sgs.GeneralShown and data:toBool() == player:inHeadSkills(self)) then
			if not (player and player:isAlive() and player:hasSkill(self:objectName())) then return "" end
			if player:getMark("TaoluanOLInitialized") > 0 then return "" end
			local allowed_table = fetchCards("BasicCard,NDTrick", nil, player)
			if next(allowed_table) then
				room:setPlayerProperty(player, "guhuo_box_allowed_elemet", sgs.QVariant(table.concat(allowed_table, "+")))
			end
			room:setPlayerMark(player, "TaoluanOLInitialized", 1)
		elseif (event == sgs.EventLoseSkill and data:toString() == self:objectName()) and not player:ownSkill(self:objectName()) then
			room:setPlayerProperty(player, "guhuo_box_allowed_elemet", sgs.QVariant())  --特别注意：暗置会触发EventLoseSkill，↑所以需要用ownSkill区分
			room:setPlayerMark(player, "TaoluanOLInitialized", 0)
		end
	end,
	can_trigger = function(self, event, room, player, data)  --GameStart必须放到can_trigger，变更副将和飞龙夺凤时会调用这个函数【但是实际上没用，hasSkill】
		if (event == sgs.GameStart) or (event == sgs.DFDebut) then
			if not (player and player:isAlive() and player:hasSkill(self:objectName())) then return "" end
			if player:getMark("TaoluanOLInitialized") > 0 then return "" end
			local allowed_table = fetchCards("BasicCard,NDTrick", nil, player)
			if next(allowed_table) then
				room:setPlayerProperty(player, "guhuo_box_allowed_elemet", sgs.QVariant(table.concat(allowed_table, "+")))
			end
			room:setPlayerMark(player, "TaoluanOLInitialized", 1)
		end
		return ""
	end,
}
TaoluanOLAsk = sgs.CreateTriggerSkill{
	name = "#TaoluanOL-ask",
	events = {sgs.CardFinished},
	frequency = sgs.Skill_Compulsory,
	can_trigger = function(self, event, room, player, data)
		if event == sgs.CardFinished then
			local use = data:toCardUse()
			if not use.card or (use.card:getTypeId() == sgs.Card_TypeSkill) then return "" end
			for _,zhangrang in sgs.qlist(room:getAllPlayers()) do  --考虑到可能改变了使用者
				local taoluan_cards = zhangrang:getTag("TaoluanOLCardsUsing"):toString():split("|")
				if table.contains(taoluan_cards, use.card:toString()) then
					return self:objectName(), zhangrang
				end
			end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		local use = data:toCardUse()
		local types = {"BasicCard", "TrickCard", "EquipCard"}
		table.removeOne(types, types[use.card:getTypeId()])
		local _type = table.concat(types, ",")
		ask_who:setTag("TaoluanOLType", sgs.QVariant(_type))
		local target = room:askForPlayerChosen(ask_who, room:getOtherPlayers(ask_who), "TaoluanOL", "@Taoluan-ask:" .. use.card:objectName())
		if target then
			local msg = sgs.LogMessage()
			msg.type, msg.from, msg.arg = "#TaoluanAsk", ask_who, "TaoluanOL"
			msg.to:append(target)
			room:sendLog(msg)
			local dat = sgs.QVariant()
			dat:setValue(target)
			ask_who:setTag("TaoluanOLTarget", dat)
			return true
		end
		ask_who:removeTag("TaoluanOLType")
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		local use = data:toCardUse()
		local target = ask_who:getTag("TaoluanOLTarget"):toPlayer()
		ask_who:removeTag("TaoluanOLTarget")
		local _type = ask_who:getTag("TaoluanOLType"):toString()
		ask_who:removeTag("TaoluanOLType")
		if not target then return end
		local card
		if not target:isNude() then
			card = room:askForCard(target, _type, "@Taoluan-give:" .. ask_who:objectName() .. "::" .. _type:split(",")[1] .. ":" .. _type:split(",")[2], data, sgs.Card_MethodNone, ask_who)
		end
		if card then
			local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_GIVE, target:objectName(), ask_who:objectName(), "Taoluan", "")
			room:obtainCard(ask_who, card, reason, true)
		else
			room:loseHp(ask_who)
			if ask_who:isAlive() then
				room:addPlayerMark(ask_who, "TaoluanOLProhibited")
			end
		end
	end,
	on_turn_broken = function(self, function_name, event, room, player, data, ask_who)
		ask_who:removeTag("TaoluanOLType")
		ask_who:removeTag("TaoluanOLTarget")
	end
}
TaoluanOLClear = sgs.CreateTriggerSkill{
	name = "#TaoluanOL-clear",
	events = {sgs.EventPhaseStart},
	priority = 8,
	global = true,
	on_record = function(self, event, room, player, data)
		if player:getPhase() ~= sgs.Player_NotActive then return false end
		for _,p in sgs.qlist(room:getAllPlayers()) do
			if p:getMark("TaoluanOLProhibited") > 0 then
				room:setPlayerMark(p, "TaoluanOLProhibited", 0)
			end
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end
}
TaoluanOLClear2 = sgs.CreateTriggerSkill{
	name = "#TaoluanOL-clear2",
	events = {sgs.CardFinished},
	priority = 1,
	global = true,
	on_record = function(self, event, room, player, data)
		local use = data:toCardUse()
		if not use.card or (use.card:getTypeId() == sgs.Card_TypeSkill) then return end
		for _,zhangrang in sgs.qlist(room:getAllPlayers()) do
			local taoluan_cards = zhangrang:getTag("TaoluanOLCardsUsing"):toString():split("|")
			if table.contains(taoluan_cards, use.card:toString()) then
				table.removeAll(taoluan_cards, use.card:toString())
				if next(taoluan_cards) ~= nil then
					zhangrang:setTag("TaoluanOLCardsUsing", sgs.QVariant(table.concat(taoluan_cards, "|")))
				else
					zhangrang:removeTag("TaoluanOLCardsUsing")
				end
			end
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
ZhangRang_OL:addSkill(TaoluanOL)
ZhangRang_OL:addSkill(TaoluanOLAsk)
ZhangRang_OL:addSkill(TaoluanOLClear)
ZhangRang_OL:addSkill(TaoluanOLClear2)
sgs.insertRelatedSkills(extensionOLRenew, "TaoluanOL", "#TaoluanOL-ask", "#TaoluanOL-clear", "#TaoluanOL-clear2")

----------------------------------------------------------------------------------------------------

--[[ （SP 004） 袁术
	武将：YuanShu_OL
	武将名：袁术-OL
	体力上限：4
	武将技能：
		庸肆：锁定技，摸牌阶段开始时，你改为摸X张牌。锁定技，弃牌阶段开始时，你选择一项：1．弃置一张牌；2．失去1点体力。（X为场上势力数） 
		觊玺：锁定技，限定技，你的回合结束时，若你连续三回合没有失去过体力，则你加1点体力上限并回复1点体力，然后选择一项：1．获得技能“妄尊”；2．摸两张牌并获得“弘法”。
	状态：
]]--

----------------------------------------------------------------------------------------------------

--[[ （SP 009） 蔡文姬
	武将：CaiWenJi_OL
	武将名：SP蔡文姬-OL
	体力上限：3
	武将技能：
		陈情：每轮限一次，当一名角色进入濒死状态时，你可以令另一名其他角色摸四张牌，然后弃置四张牌，若其以此法弃置的四张牌花色各不相同，则其视为对处于濒死状态的角色使用一张【桃】。
		默识：结束阶段开始时，你可以将一张手牌当你出牌阶段内使用的第一张基本牌或普通锦囊牌使用，然后你可以将一张手牌当你出牌阶段内使用的第二张基本牌或普通锦囊牌使用。
	状态：
]]--
CaiWenJi_OL = sgs.General(extensionOLRenew, "CaiWenJi_OL", "wei", 3, false)

--[[
	技能名：陈情
	技能：Chenqing
	描述：每轮限一次，当一名角色进入濒死状态时，你可以令另一名其他角色摸四张牌，然后弃置四张牌，若其以此法弃置的四张牌花色各不相同，则其视为对处于濒死状态的角色使用一张【桃】。
	状态：验证通过
]]--
Chenqing = sgs.CreateTriggerSkill{
	name = "Chenqing",
	can_preshow = true,
	events = {sgs.Dying},
	frequency = sgs.Skill_NotFrequent,
	can_trigger = function(self, event, room, player, data)
		if player and player:isAlive() and player:hasSkill(self) and player:getMark("@advise") == 0 then
			local dying = data:toDying()
			if dying.who:isAlive() and dying.who:getHp() < 1 and room:alivePlayerCount() > ((player == dying.who) and 1 or 2) then 
				return self:objectName() 
			end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		local dying = data:toDying()
		local players = room:getOtherPlayers(dying.who)
		players:removeOne(player)
		if players:isEmpty() then return false end
		local target = room:askForPlayerChosen(player, players, self:objectName(), "Chenqing-invoke:" .. dying.who:objectName(), true, true)
		if target then
			local tag = sgs.QVariant()
			tag:setValue(target)
			player:setTag("Chenqing_invoke", tag)
			room:broadcastSkillInvoke(self:objectName(), player)
			return true
		end
		return false
	end,
	on_effect = function(self, event, room, player, data)
		local target = player:getTag("Chenqing_invoke"):toPlayer()
		player:removeTag("Chenqing_invoke")
		room:setPlayerMark(player, "@advise", 1)
		local dying, card = data:toDying()
		target:drawCards(4)
		local card 
		if target:getCardCount(true) <= 4 then
			card = sgs.DummyCard()
			card:addSubcards(target:getCards("he"))
		else
			card = room:askForExchange(target, self:objectName(), 4, 4, "@Chenqing-exchange:" .. player:objectName() .. ":" .. dying.who:objectName(), "", ".")
			if not card then
				local card_ids = sgs.IntList()
				local card_id
				for i = 1, 4 do
					card_id = target:getCards("he"):at(math.random(0, target:getCards("he"):length() - 1)):getEffectiveId()
					while card_ids:contains(card_id) do
						card_id = target:getCards("he"):at(math.random(0, target:getCards("he"):length() - 1)):getEffectiveId()
					end
					card_ids:append(card_id)
				end
				card = sgs.DummyCard(card_ids)
			end
		end
		local suits = {}
		for _,id in sgs.qlist(card:getSubcards()) do
			local c = sgs.Sanguosha:getCard(id)
			if not c then continue end
			local suit = c:getSuit()
			local flag = true
			for _, s in ipairs(suits) do
				if suit == s then
					flag = false
					break
				end
			end
			if flag then table.insert(suits, suit) end
		end
		room:throwCard(card, target)
		card:deleteLater()
		if #suits == 4 and room:getCurrentDyingPlayer() == dying.who then
			local peach = sgs.Sanguosha:cloneCard("peach", sgs.Card_NoSuit, 0)
			peach:setSkillName("_Chenqing")
			if not target:isProhibited(dying.who, peach) and not target:hasFlag("Global_PreventPeach") then
				room:useCard(sgs.CardUseStruct(peach, target, dying.who, false))
			end
		end
		return false 
	end,
}
ChenqingClear = sgs.CreateTriggerSkill{
	name = "#Chenqing-clear",
	events = {sgs.TurnStart},
	priority = 8,
	global = true,
	on_record = function(self, event, room, player, data)  --todo：continuous Seat 1
		if player:getSeat() == 1 and not player:hasFlag("ChenqingExtraTurn") and not room:getTag("ChenqingContinuousSeat1"):toBool() then
			for _,p in sgs.qlist(room:getAllPlayers()) do
				if p:getMark("@advise") > 0 then
					room:setPlayerMark(p, "@advise", 0)
				end
			end
		end
		if player:hasFlag("ChenqingExtraTurn") then
			player:setFlags("-ChenqingExtraTurn")
		elseif player:getSeat() == 1 then
			room:setTag("ChenqingContinuousSeat1", sgs.QVariant(true))  --1号位回合内死亡后2号位回合会连续满足getSeat()==1的条件，但不是新的一轮
		elseif player:getSeat() ~= 1 then
			room:setTag("ChenqingContinuousSeat1", sgs.QVariant(false))
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end
}
ChenqingExtraTurn = sgs.CreateTriggerSkill{
	name = "#Chenqing-extraturn",
	events = {sgs.TurnStart},
	priority = -1,  --此时机在GameRule中的player->play之后，在通过ExtraTurnList获得额外回合玩家之前，可用来检测额外回合
	global = true,
	on_record = function(self, event, room, player, data)
		local extraTurnList = room:getTag("ExtraTurnList"):toStringList()
		local extraTurnPlayerName = extraTurnList[1]
		local extraTurnPlayer = room:findPlayer(extraTurnPlayerName)
		if extraTurnPlayer then
			extraTurnPlayer:setFlags("ChenqingExtraTurn")
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
CaiWenJi_OL:addSkill(Chenqing)
CaiWenJi_OL:addSkill(ChenqingClear)
CaiWenJi_OL:addSkill(ChenqingExtraTurn)
sgs.insertRelatedSkills(extensionOLRenew, "Chenqing", "#Chenqing-clear", "#Chenqing-extraturn")

--[[
	技能名：默识
	技能：Mozhi
	描述：结束阶段开始时，你可以将一张手牌当你出牌阶段内使用的第一张基本牌或普通锦囊牌使用，然后你可以将一张手牌当你出牌阶段内使用的第二张基本牌或普通锦囊牌使用。
	状态：验证通过
]]--
MozhiRecord = sgs.CreateTriggerSkill{
	name = "#Mozhi-record",
	events = {sgs.PreCardUsed, sgs.CardResponded},
	global = true,
	on_record = function(self, event, room, player, data)
		if player:getPhase() == sgs.Player_Play then
			local card
			if event == sgs.PreCardUsed then
				card = data:toCardUse().card
			elseif event == sgs.CardResponded then
				local response = data:toCardResponse()
				card = response.m_isUse and response.m_card
			end
			if card and card:getHandlingMethod() == sgs.Card_MethodUse and (card:isKindOf("BasicCard") or card:isNDTrick()) then
				local list = player:getTag("Mozhi"):toString():split("+")
				table.removeAll(list, "")
				if #list >= 2 then return end
				table.insert(list, card:objectName())
				player:setTag("Mozhi", sgs.QVariant(table.concat(list, "+")))
			end
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
MozhiCard = sgs.CreateSkillCard{
	name = "MozhiCard",
	skill_name = "Mozhi",
	will_throw = false,
	filter = function(self, targets, to_select, player)
		local players = sgs.PlayerList()
		if next(targets) ~= nil then
			for i = 1 , #targets do
				players:append(targets[i])
			end
		end
        local _card = sgs.Sanguosha:cloneCard(player:property("Mozhi"):toString())
        if _card == nil or _card:targetFixed() then
            return false
        end
        local card = sgs.Sanguosha:cloneCard(_card)
		card:addSubcards(self:getSubcards())
        card:setCanRecast(false)
        card:deleteLater()
        return card and card:targetFilter(players, to_select, player) and not player:isProhibited(to_select, card, players) and card:isAvailable(player) and not player:isLocked(card)
	end,
	feasible = function(self, targets, player)
		local players = sgs.PlayerList()
		if next(targets) ~= nil then
			for i = 1 , #targets do
				players:append(targets[i])
			end
		end
		 local _card = sgs.Sanguosha:cloneCard(player:property("Mozhi"):toString())
        if _card == nil then
            return false
        end
		local card = sgs.Sanguosha:cloneCard(_card)
		card:addSubcards(self:getSubcards())
		local can_recast = card:canRecast()
		card:setCanRecast(false)
		card:deleteLater()
		return card and card:targetsFeasible(players, player) and card:isAvailable(player) and not player:isLocked(card)  --2.1.0处理知己知彼bug
    end,
	on_validate = function(self, card_use)
        local source = card_use.from
        local room = source:getRoom()
		
		local user_str = source:property("Mozhi"):toString()
		local use_card = sgs.Sanguosha:cloneCard(user_str)
        use_card:setSkillName("Mozhi")
        use_card:addSubcards(self:getSubcards())
        use_card:setCanRecast(false)
        use_card:setShowSkill("Mozhi")
		
		local available = true
		local tos = card_use.to
        for _, to in sgs.qlist(tos) do
            local skill = source:isProhibited(to, use_card)
            if skill then
				if skill:isVisible() then
					local msg = sgs.LogMessage()
					msg.type = "#SkillAvoid"
					msg.from = to
					msg.arg = skill:objectName()
					msg.arg2 = use_card:objectName()
					room:sendLog(msg)
					room:broadcastSkillInvoke(skill:objectName())
				end
                card_use.to:removeOne(to)
            end
        end
		available = available and use_card:isAvailable(source) and not source:isLocked(use_card)
		use_card:deleteLater()
		if not available then return nil end
        return use_card
    end,
}
MozhiVS = sgs.CreateOneCardViewAsSkill{
	name = "Mozhi",
	response_pattern = "@@Mozhi",
	response_or_use = true,
	view_filter = function(self, card)
		if card:isEquipped() then return false end
		local ori = sgs.Self:property(self:objectName()):toString()
		if ori == "" or ori == "analeptic" then return false end
		local card = sgs.Sanguosha:cloneCard(ori, sgs.Card_SuitToBeDecided, -1)
		card:addSubcard(card)
		return card:isAvailable(sgs.Self)
	end, 
	view_as = function(self, originalCard)
		local ori = sgs.Self:property(self:objectName()):toString()
		if ori == "" or ori == "analeptic" then return nil end
		local realcard = sgs.Sanguosha:cloneCard(ori, sgs.Card_SuitToBeDecided, -1)
		local card = MozhiCard:clone()
		card:setTargetFixed(realcard:targetFixed())
		card:addSubcard(originalCard)
		return card
	end,
}
Mozhi = sgs.CreateTriggerSkill{
	name = "Mozhi",
	view_as_skill = MozhiVS,
	events = {sgs.EventPhaseStart},
	can_trigger = function(self, event, room, player, data)
		if not (player and player:isAlive() and player:hasSkill(self)) then return "" end
		if player:getPhase() == sgs.Player_Finish then
			if player:isKongcheng() and player:getHandPile():isEmpty() then return "" end
			local list = player:getTag(self:objectName()):toString():split("+")
			table.removeAll(list, "")
			if not next(list) or list[1] == "analeptic" then return "" end  --隐藏牌面：你不能发动【默识】使用【酒】。
			local card = sgs.Sanguosha:cloneCard(list[1], sgs.Card_SuitToBeDecided, -1)
			card:setCanRecast(false)
			card:deleteLater()  --待研究是不是这行导致了闪退（在滔乱之类的地方）
			return (card and card:isAvailable(player)) and self:objectName() or ""
		end
	end,
	on_cost = function(self, event, room, player, data)
		local list = player:getTag(self:objectName()):toString():split("+")
		table.removeAll(list, "")
		if not next(list) or list[1] == "analeptic" then return false end
		room:setPlayerProperty(player, self:objectName(), sgs.QVariant(list[1]))
		local invoke = room:askForUseCard(player, "@@Mozhi", "@Mozhi:::" .. list[1])
		room:setPlayerProperty(player, self:objectName(), sgs.QVariant())
		return invoke
	end,
	on_effect = function(self, event, room, player, data)  --仅处理第二张
		if player:isKongcheng() and player:getHandPile():isEmpty() then return false end
		local list = player:getTag(self:objectName()):toString():split("+")
		table.removeAll(list, "")
		if not next(list) or #list < 2 or list[2] == "analeptic" then return false end
		local card = sgs.Sanguosha:cloneCard(list[2], sgs.Card_SuitToBeDecided, -1)
		card:setCanRecast(false)
		card:deleteLater()
		if card and card:isAvailable(player) then  --如果设置了不能使用无色牌的话可能有bug
			room:setPlayerProperty(player, self:objectName(), sgs.QVariant(list[2]))
			room:askForUseCard(player, "@@Mozhi", "@Mozhi:::" .. list[2])
			room:setPlayerProperty(player, self:objectName(), sgs.QVariant())
		end
	end,
	on_turn_broken = function(self, function_name, event, room, player, data, ask_who)
		room:setPlayerProperty(player, self:objectName(), sgs.QVariant())
	end
}
MozhiClear = sgs.CreateTriggerSkill{
	name = "#Mozhi-clear",
	events = {sgs.EventPhaseStart},
	priority = 8,
	global = true,
	on_record = function(self, event, room, player, data)
		if player:getPhase() ~= sgs.Player_RoundStart then return false end
		player:removeTag("Mozhi")
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end
}
CaiWenJi_OL:addSkill(Mozhi)
CaiWenJi_OL:addSkill(MozhiRecord)
CaiWenJi_OL:addSkill(MozhiClear)
sgs.insertRelatedSkills(extensionOLRenew, "Mozhi", "#Mozhi-record", "#Mozhi-clear")

----------------------------------------------------------------------------------------------------

--[[ （SP 011） 马超
	武将：MaChao_OL
	武将名：SP马超-OL
	体力上限：4
	武将技能：
		追击：锁定技，你与体力值不大于你的角色的距离视为1。
		誓仇：你使用【杀】可以多选择一至X名目标（X为你已损失的体力值）。
	状态：
]]--
MaChao_OL = sgs.General(extensionOLRenew, "MaChao_OL", "qun", 4, true)
MaChao_OL:addCompanion("pangde")

--[[
	技能名：追击
	技能：ZhuijiOL
	描述：锁定技，你与体力值不大于你的角色的距离视为1。
	状态：
]]--
ZhuijiOL = sgs.CreateDistanceSkill{
	name = "ZhuijiOL", 
	correct_func = function(self, from, to)
		if from:hasShownSkill(self:objectName()) and from:getHp() >= to:getHp() then
			return -1000
		else
			return 0
		end
	end
}
MaChao_OL:addSkill(ZhuijiOL)

--[[
	技能名：誓仇
	技能：Shichou
	描述：你使用【杀】可以多选择一至X名目标（X为你已损失的体力值）。
	状态：
]]--
Shichou = sgs.CreateTriggerSkill{
	name = "Shichou",
	can_preshow = false,
	frequency = sgs.Skill_NotFrequent,
}
ShichouTargetMod = sgs.CreateTargetModSkill{
	name = "#Shichou-target", 
	extra_target_func = function(self, from)
		if from:hasSkill("Shichou") then
			return from:getLostHp()
		else
			return 0
		end
	end
}
MaChao_OL:addSkill(Shichou)
MaChao_OL:addSkill(ShichouTargetMod)
sgs.insertRelatedSkills(extensionOLRenew, "Shichou", "#Shichou-target")

----------------------------------------------------------------------------------------------------

--[[ （SP 012） 贾诩
	武将：JiaXu_OL
	武将名：SP贾诩-OL
	体力上限：3
	武将技能：
		缜略：锁定技，你使用的普通锦囊牌不能被【无懈可击】响应；你不是延时锦囊牌的合法目标。 
		间书：限定技，出牌阶段，你可以将一张黑色手牌交给一名其他角色，令其与你选择的攻击范围内有其的一名其他角色拼点，拼点赢的角色弃置两张牌，拼点没赢的角色失去1点体力。 
		拥嫡：限定技，当你受到伤害后，你可以令一名其他男性角色加1点体力上限，然后若其与你势力相同且其有武将牌曹操/曹丕/曹叡，其获得“护驾”/“颂威”/“兴衰”。
	状态：
]]--

----------------------------------------------------------------------------------------------------

--[[ （SP 028） 星彩
	武将：XingCai_OL
	武将名：星彩-OL
	体力上限：3
	武将技能：
		甚贤：每名其他角色的回合限一次，当其他角色因弃置而失去基本牌后，你可以摸一张牌。
		枪舞：出牌阶段限一次，你可以进行判定，然后本回合，你使用点数小于判定结果的【杀】无距离限制，你使用点数大于判定结果的【杀】无次数限制且不计入次数限制。
	状态：复制原项目
]]--
XingCai_OL = sgs.General(extensionOLRenew, "XingCai_OL", "shu", 3, false, true)
XingCai_OL:addCompanion("liushan")

--[[
	技能名：甚贤
	技能：ShenxianOL
	描述：每名其他角色的回合限一次，当其他角色因弃置而失去基本牌后，你可以摸一张牌。
	状态：验证通过
]]--
ShenxianOL = sgs.CreateTriggerSkill{
	name = "ShenxianOL",
	can_preshow = true,
	events = {sgs.CardsMoveOneTime},
	frequency = sgs.Skill_Frequent,
 	can_trigger = function(self, event, room, player, data)
		if event == sgs.CardsMoveOneTime then
			if not player or player:isDead() then return "" end
			local move = data:toMoveOneTime()
			if player:getPhase() == sgs.Player_NotActive and move.from and move.from:objectName() ~= player:objectName()
				and (move.from_places:contains(sgs.Player_PlaceHand) or move.from_places:contains(sgs.Player_PlaceEquip))
				and (bit32.band(move.reason.m_reason, sgs.CardMoveReason_S_MASK_BASIC_REASON)) == sgs.CardMoveReason_S_REASON_DISCARD then  --条件B
				local ShenxianStack_str = player:getTag("ShenxianOLStack"):toString()
				if ShenxianStack_str == "" then return end
				local ShenxianStack = ShenxianStack_str:split("|")
				
				if player:hasSkill(self) and room:getCurrent() and (room:getCurrent():getMark(self:objectName()) == 0) and (player:getTag("ShenxianOLPopIndex"):toInt() ~= #ShenxianStack) then
					local ShenxianOneTime_str = ShenxianStack[#ShenxianStack]
					if ShenxianOneTime_str ~= "-1" then return self:objectName() end
				end
			end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		local ShenxianStack_str = player:getTag("ShenxianOLStack"):toString()
		local ShenxianStack = ShenxianStack_str:split("|")
		player:setTag("ShenxianOLPopIndex", sgs.QVariant(#ShenxianStack))
		
		if player:askForSkillInvoke(self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), player)
			return true 
		end
		return false
	end,
	on_effect = function(self, event, room, player, data)
		player:drawCards(1, self:objectName())
		room:getCurrent():setMark(self:objectName(), 1)
	end,
}
ShenxianOLRecord = sgs.CreateTriggerSkill{
	name = "#ShenxianOL-record",
	events = {sgs.BeforeCardsMove, sgs.CardsMoveOneTime},
	priority = 1,
	global = true,
 	on_record = function(self, event, room, player, data)
		if event == sgs.BeforeCardsMove then
			if not (player and player:isAlive()) then return end
			
			local move = data:toMoveOneTime()
			if player:getPhase() == sgs.Player_NotActive and move.from and move.from:objectName() ~= player:objectName()
				and (move.from_places:contains(sgs.Player_PlaceHand) or move.from_places:contains(sgs.Player_PlaceEquip))
				and (bit32.band(move.reason.m_reason, sgs.CardMoveReason_S_MASK_BASIC_REASON)) == sgs.CardMoveReason_S_REASON_DISCARD then  --条件A
				local card_ids = {-1}
				for i, id in sgs.qlist(move.card_ids) do
					if sgs.Sanguosha:getCard(id):getTypeId() == sgs.Card_TypeBasic
						and (move.from_places:at(i) == sgs.Player_PlaceHand or move.from_places:at(i) == sgs.Player_PlaceEquip) then
						table.insert(card_ids, id)
					end
				end
				
				local ShenxianStack_str = player:getTag("ShenxianOLStack"):toString()
				local ShenxianStack = ShenxianStack_str:split("|")
				table.removeAll(ShenxianStack, "")
				table.insert(ShenxianStack, table.concat(card_ids, "+"))
				player:setTag("ShenxianOLStack", sgs.QVariant(table.concat(ShenxianStack, "|")))
			end
		elseif event == sgs.CardsMoveOneTime then
			if not player or player:isDead() then return false end
			local move = data:toMoveOneTime()
			if player:getPhase() == sgs.Player_NotActive and move.from and move.from:objectName() ~= player:objectName()
				and (move.from_places:contains(sgs.Player_PlaceHand) or move.from_places:contains(sgs.Player_PlaceEquip))
				and (bit32.band(move.reason.m_reason, sgs.CardMoveReason_S_MASK_BASIC_REASON)) == sgs.CardMoveReason_S_REASON_DISCARD then  --条件B
				local ShenxianStack_str = player:getTag("ShenxianOLStack"):toString()
				if ShenxianStack_str == "" then return end
				local ShenxianStack = ShenxianStack_str:split("|")
				
				table.remove(ShenxianStack, #ShenxianStack)
				if next(ShenxianStack) then player:setTag("ShenxianOLStack", sgs.QVariant(table.concat(ShenxianStack, "|")))
				else player:removeTag("ShenxianOLStack") end
				player:removeTag("ShenxianOLPopIndex")
			end
		end
	end,
 	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
ShenxianOLClear = sgs.CreateTriggerSkill{
	name = "#ShenxianOL-clear",
	events = {sgs.EventPhaseStart},
	priority = 8,
	global = true,
 	on_record = function(self, event, room, player, data)
		if (event == sgs.EventPhaseStart) and (player:getPhase() == sgs.Player_NotActive) then
			if player:getMark("ShenxianOL") > 0 then
				player:setMark("ShenxianOL", 0)
			end
		end
	end,
 	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
XingCai_OL:addSkill(ShenxianOL)
XingCai_OL:addSkill(ShenxianOLRecord)
XingCai_OL:addSkill(ShenxianOLClear)
sgs.insertRelatedSkills(extensionOLRenew, "ShenxianOL", "#ShenxianOL-record", "#ShenxianOL-clear")

--[[
	技能名：枪舞
	技能：Qiangwu
	描述：出牌阶段限一次，你可以进行判定，然后本回合，你使用点数小于判定结果的【杀】无距离限制，你使用点数大于判定结果的【杀】无次数限制且不计入次数限制。
	状态：与星彩技能相同
]]--
QiangwuCard_XingCai_OL = sgs.CreateQiangwuCard("XingCai_OL")
QiangwuVS_XingCai_OL = sgs.CreateQiangwuVSSkill("XingCai_OL", QiangwuCard_XingCai_OL)
Qiangwu_XingCai_OL = sgs.CreateQiangwuSkill("XingCai_OL", QiangwuVS_XingCai_OL)
QiangwuClear_XingCai_OL = sgs.CreateQiangwuClearSkill("XingCai_OL")
QiangwuTar_XingCai_OL = sgs.CreateQiangwuTarSkill("XingCai_OL")
XingCai_OL:addSkill(Qiangwu_XingCai_OL)
XingCai_OL:addSkill(QiangwuClear_XingCai_OL)
XingCai_OL:addSkill(QiangwuTar_XingCai_OL)
sgs.insertRelatedSkills(extensionOLRenew, "Qiangwu_XingCai_OL", "#Qiangwu-clear_XingCai_OL", "#Qiangwu-target_XingCai_OL")

----------------------------------------------------------------------------------------------------

--[[ （SP 030） 祖茂
	武将：ZuMao_OL
	武将名：祖茂-OL
	体力上限：4
	武将技能：
		引兵：结束阶段开始时，你可以将至少一张非基本牌置于武将牌上；当你受到【杀】或【决斗】的伤害后，你移去一张“引兵”牌。
		绝地：锁定技，准备阶段开始时，你选择一项：1. 移去“引兵”牌，将手牌补至X张（X为你的体力上限）；2. 将“引兵”牌交给一名体力值不大于你的其他角色，若如此做，其回复1点体力，然后摸等量的牌。
	状态：
]]--
ZuMao_OL = sgs.General(extensionOLRenew, "ZuMao_OL", "wu", 4, true, true)
ZuMao_OL:addCompanion("sunjian")

--[[
	技能名：引兵
	技能：Yinbing_ZuMao
	描述：结束阶段开始时，你可以将至少一张非基本牌置于武将牌上；当你受到【杀】或【决斗】的伤害后，你移去一张“引兵”牌。
	状态：复制原项目并调整
]]--
Yinbing_ZuMao_OL = sgs.CreateYinbingSkill("ZuMao_OL")
YinbingThrow_ZuMao_OL = sgs.CreateYinbingThrowSkill("ZuMao_OL")
ZuMao_OL:addSkill(Yinbing_ZuMao_OL)
ZuMao_OL:addSkill(YinbingThrow_ZuMao_OL)
sgs.insertRelatedSkills(extensionOLRenew, "Yinbing_ZuMao_OL", "#Yinbing-throw_ZuMao_OL")

--[[
	技能名：绝地
	技能：JuediOL
	描述：锁定技，准备阶段开始时，你选择一项：1. 移去“引兵”牌，将手牌补至X张（X为你的体力上限）；2. 将“引兵”牌交给一名体力值不大于你的其他角色，若如此做，其回复1点体力，然后摸等量的牌。
	状态：
]]--
JuediOL = sgs.CreatePhaseChangeSkill{
	name = "JuediOL",
	can_preshow = false,
	frequency = sgs.Skill_Compulsory,
	can_trigger = function(self, event, room, player, data)
		if not player or player:isDead() or not player:hasSkill(self) then return false end
		if player:getPhase() == sgs.Player_Start and player:getPile("Yinbing_ZuMao_OL"):length() > 0 then
			return self:objectName()
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		local isComp = player:hasShownSkill(self)
		if isComp then room:sendCompulsoryTriggerLog(player, self:objectName(), false) end  --原本是应该写到on_effect里，但是会有显示顺序问题，这里手动触发
		local targets = sgs.SPlayerList()
		targets:append(player)
		for _,p in sgs.qlist(room:getOtherPlayers(player)) do
			if p:getHp() <= player:getHp() then
				targets:append(p)
			end
		end
		local target = room:askForPlayerChosen(player, targets, self:objectName(), isComp and "JuediOL-invoke" or "JuediOL-invoke-noncomp", not isComp, not isComp)
		if not target and isComp then target = player end
		if target then
			room:broadcastSkillInvoke(self:objectName(), player)
			if target == player then
				player:clearOnePrivatePile("Yinbing_ZuMao_OL")
			else
				local len = player:getPile("Yinbing_ZuMao_OL"):length()
				local dummy = sgs.DummyCard(player:getPile("Yinbing_ZuMao_OL"))
				local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_EXCHANGE_FROM_PILE, player:objectName(), self:objectName(), "")
				room:obtainCard(target, dummy, reason)
				dummy:deleteLater()
				player:setTag("JuediOLDrawNum", sgs.QVariant(len))
			end
			local d = sgs.QVariant()
			d:setValue(target)
			player:setTag("JuediOL_target", d)
			return true
		end
		return false
	end,
	on_phasechange = function(self, player)
		local room = player:getRoom()
		local target = player:getTag("JuediOL_target"):toPlayer()
		player:removeTag("JuediOL_target")
		if not target then return end
		if target ~= player and target:isAlive() then
			local recover = sgs.RecoverStruct()
			recover.who = player
			room:recover(target, recover)
			if target:isDead() then return end
			local len = player:getTag("JuediOLDrawNum"):toInt()
			player:removeTag("JuediOLDrawNum")
			target:drawCards(len, self:objectName())
		else
			if player:isAlive() and player:getHandcardNum() < player:getMaxHp() then
				room:drawCards(player, player:getMaxHp() - player:getHandcardNum(), self:objectName())
			end
		end
	end,
	on_turn_broken = function(self, function_name, event, room, player, data, ask_who)
		player:removeTag("JuediOL_target")
		player:removeTag("JuediOLDrawNum")
	end
}
ZuMao_OL:addSkill(JuediOL)

----------------------------------------------手杀专属----------------------------------------------

extensionMobile = sgs.Package("Mobile", sgs.Package_GeneralPack)

--[[ M.OL 008 祢衡
	武将：MiHeng
	武将名：祢衡
	体力上限：3
	武将技能：
		狂才：出牌阶段开始时，你可以令你此阶段内的出牌时间变为5秒，若如此做，你于此阶段内使用牌无距离限制且无次数限制，且当你于此阶段内使用牌时，你摸一张牌，然后出牌时间-1秒。
		舌剑：弃牌阶段结束时，若你于此阶段弃置过至少一张花色均不同的牌，你可弃置一名其他角色的一张牌。
	状态：验证通过
]]--
MiHeng = sgs.General(extensionMobile, "MiHeng", "qun", 3, true)
MiHeng:addCompanion("kongrong")

--[[
	技能名：狂才
	技能：Kuangcai
	描述：出牌阶段开始时，你可以令你此阶段内的出牌时间变为5秒，若如此做，你于此阶段内使用牌无距离限制且无次数限制，且当你于此阶段内使用牌时，你摸一张牌，然后出牌时间-1秒。
	状态：验证通过
	注：时限目前仅对空闲时间点使用的牌有效，对于响应使用牌（如借刀出闪、濒死出桃，甚至询问技能发动、过拆选牌等等）还是原来的限时
]]--
KuangcaiClock = os.clock()   --浮点型不能用QVariant或Mark存储
Kuangcai = sgs.CreatePhaseChangeSkill{
	name = "Kuangcai",
	can_preshow = true,
	frequency = sgs.Skill_Frequent,
	can_trigger = function(self, event, room, player, data)
		if not player or player:isDead() or not player:hasSkill(self) then return "" end
		if player:getPhase() == sgs.Player_Play then return self:objectName() end
	end,
	on_cost = function(self, event, room, player, data)
		if player:askForSkillInvoke(self:objectName(), data) then
			room:broadcastSkillInvoke(self:objectName(), 1, player)
			return true 
		end
		return false 
	end,
	on_phasechange = function(self, player)
		local room = player:getRoom()
		room:setPlayerFlag(player, "KuangcaiInvoked")
		room:setPlayerMark(player, "KuangcaiTimeLimit", 5)
		room:setPlayerMark(player, "@kuangcai", 5)  --for UI
		return false
	end,
}
KuangcaiDraw = sgs.CreateTriggerSkill{
	name = "#Kuangcai-draw",
	events = {sgs.CardUsed, sgs.CardResponded},
	frequency = sgs.Skill_Wake,
	global = true,
	can_trigger = function(self, event, room, player, data)
		if not player or player:isDead() then return false end
		if not player:hasFlag("KuangcaiInvoked") then return false end
		local card
		if event == sgs.CardUsed then
			card = data:toCardUse().card
		elseif event == sgs.CardResponded then
			local response = data:toCardResponse()
			if response.m_isUse then
				card = response.m_card
			end
		end
		if card and card:getHandlingMethod() == sgs.Card_MethodUse and card:getTypeId() ~= sgs.Card_TypeSkill then
			return self:objectName()
		end
	end,
	on_cost = function(self, event, room, player, data)
		room:broadcastSkillInvoke("Kuangcai", 7 - player:getMark("KuangcaiTimeLimit"), player)
		return true
	end,
	on_effect = function(self, event, room, player, data)
		player:drawCards(1, self:objectName())
		room:removePlayerMark(player, "KuangcaiTimeLimit")
		room:setPlayerMark(player, "@kuangcai", player:getMark("KuangcaiTimeLimit"))
		if player:getMark("KuangcaiTimeLimit") == 0 then
			room:setPlayerFlag(player, "Global_PlayPhaseTerminated")
		end
	end
}
KuangcaiTime = sgs.CreateTriggerSkill{
	name = "#Kuangcai-time",
	events = {sgs.EventPhaseProceeding, sgs.ChoiceMade, sgs.CardFinished, sgs.EventPhaseEnd},
	priority = 1,
	global = true,
	on_record = function(self, event, room, player, data)
		if not (player and player:hasFlag("KuangcaiInvoked") and player:getPhase() == sgs.Player_Play) then return end
		if event == sgs.EventPhaseProceeding then  --出牌阶段开始出牌时，初始化计时
			KuangcaiClock = os.clock()
		elseif event == sgs.ChoiceMade then  --room::activate()中的最后一步，这样来模拟使用牌点击确定的时间
			if player:hasFlag("KuangcaiUsingCard") then  --防止奇葩插入结算
				KuangcaiClock = os.clock()
				return
			end
			if data:toString() == "" then  --只能这样判断是否为CardUseStruct
				if data:toCardUse().card and sgs.Sanguosha:getCurrentCardUseReason() == sgs.CardUseStruct_CARD_USE_REASON_PLAY then  --只考虑出牌阶段空闲时间点
					local time_elapsed = os.clock() - KuangcaiClock
					if time_elapsed > player:getMark("KuangcaiTimeLimit") then
						room:setPlayerFlag(player, "KuangcaiTerminate")
					end
					room:setPlayerFlag(player, "KuangcaiUsingCard")
				end
			end
		elseif event == sgs.CardFinished then   --使用牌的最后一步，重置计时，之后应该就是回到activate()了 （严格来说priority应该为负，但懒得再分一个技能了）
												--即使此牌不是空闲时间点使用的也没关系，之后总会执行空闲时间点使用的那张牌的CardFinished
												--（bug：如果useCard中在validate就返回空退出了则不会走到这里，如蛊惑，进而导致时间判断错误）
			room:setPlayerFlag(player, "-KuangcaiUsingCard")
			KuangcaiClock = os.clock()
		elseif event == sgs.EventPhaseEnd then
			room:setPlayerFlag(player, "-KuangcaiTerminate")
			room:setPlayerFlag(player, "-KuangcaiInvoked")
			room:setPlayerFlag(player, "-KuangcaiUsingCard")
			room:setPlayerMark(player, "KuangcaiTimeLimit", 0)
			room:setPlayerMark(player, "@kuangcai", 0)
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end
}
KuangcaiCancel = sgs.CreateTriggerSkill{
	name = "#Kuangcai-cancel",  --取消此牌（虽然在CardUsed取消一般会更有用，避开onUse里面一长串代码，但是越早越好）
	events = {sgs.PreCardUsed, sgs.BeforeCardsMove},
	priority = 11,
	frequency = sgs.Skill_Wake,
	global = true,
	can_trigger = function(self, event, room, player, data)
		if event == sgs.PreCardUsed then
			if not (player and player:hasFlag("KuangcaiInvoked") and player:getPhase() == sgs.Player_Play) then return end
			if player:hasFlag("KuangcaiTerminate") then
				return self:objectName()
			end
		elseif event == sgs.BeforeCardsMove then
			local move = data:toMoveOneTime()
			for _,id in sgs.qlist(move.card_ids) do
				if sgs.Sanguosha:getCard(id):hasFlag("KuangcaiTerminatedTrick") then
					return self:objectName()
				end
			end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		if event == sgs.PreCardUsed then
			local msg = sgs.LogMessage()
			msg.type, msg.from, msg.arg = "#KuangcaiTerminate", player, player:getMark("KuangcaiTimeLimit")
			room:sendLog(msg)  --国战使用牌的显示在PreCardUsed之前，因此需要加个msg来解释
		end
		return true
	end,
	on_effect = function(self, event, room, player, data)
		if event == sgs.PreCardUsed then
			room:setPlayerFlag(player, "-KuangcaiTerminate")
			room:setPlayerFlag(player, "-KuangcaiInvoked")
			room:setPlayerFlag(player, "-KuangcaiUsingCard")
			room:setPlayerMark(player, "KuangcaiTimeLimit", 0)
			room:setPlayerMark(player, "@kuangcai", 0)
			room:setPlayerFlag(player, "Global_PlayPhaseTerminated")
			local use = data:toCardUse()
			if use.card:isKindOf("DelayedTrick") then
				local subcards = sgs.IntList()
				if use.card:isVirtualCard() then subcards = use.card:getSubcards()
				else subcards:append(use.card:getEffectiveId()) end
				for _,id in sgs.qlist(subcards) do
					room:setCardFlag(id, "KuangcaiTerminatedTrick")
				end
			end
			use.card = sgs.DummyCard()
			use.to = sgs.SPlayerList()
			data:setValue(use)
			return true
		elseif event == sgs.BeforeCardsMove then  --延时锦囊在onUse就移到了判定区，因此必须清空
			local move = data:toMoveOneTime()
			local done = false
			while not done do
				done = true
				for _,id in sgs.qlist(move.card_ids) do
					if sgs.Sanguosha:getCard(id):hasFlag("KuangcaiTerminatedTrick") then
						room:setCardFlag(id, "-KuangcaiTerminatedTrick")
						move.from_places:removeAt(move.card_ids:indexOf(id))
						table.remove(move.from_pile_names, move.card_ids:indexOf(id)+1)
						move.card_ids:removeOne(id)
						data:setValue(move)
						done = false
						break
					end
				end
			end
			if move.card_ids:isEmpty() then return true end
		end
	end,
}
KuangcaiTarget = sgs.CreateTargetModSkill{
	name = "#Kuangcai-target",
	pattern = ".",
	distance_limit_func = function(self, player, card)
		if player:hasFlag("KuangcaiInvoked") then
			return 1000
		else
			return 0
		end
	end,
	residue_func = function(self, player, card)
		if player:hasFlag("KuangcaiInvoked") then
			return 1000
		else
			return 0
		end
	end,
}
MiHeng:addSkill(Kuangcai)
MiHeng:addSkill(KuangcaiDraw)
MiHeng:addSkill(KuangcaiTime)
MiHeng:addSkill(KuangcaiCancel)
MiHeng:addSkill(KuangcaiTarget)
sgs.insertRelatedSkills(extensionMobile, "Kuangcai", "#Kuangcai-draw", "#Kuangcai-time", "#Kuangcai-cancel", "#Kuangcai-target")

--[[
	技能名：舌剑
	技能：Shejian
	描述：弃牌阶段结束时，若你于此阶段弃置过至少一张花色均不同的牌，你可弃置一名其他角色的一张牌。
	状态：验证通过
]]--
ShejianRecord = sgs.CreateTriggerSkill{
	name = "#Shejian-record",
	global = true,
	events = {sgs.BeforeCardsMove, sgs.EventPhaseChanging},
	on_record = function(self, event, room, player, data)
		if event == sgs.EventPhaseChanging and data:toPhaseChange().from == sgs.Player_Discard then
			for _,suit in ipairs({"spade", "club", "heart", "diamond"}) do
				room:setPlayerMark(player, "ShejianSuit" .. suit, 0)
			end
		elseif event == sgs.BeforeCardsMove and player:getPhase() == sgs.Player_Discard then
			local move = data:toMoveOneTime()
			if move.reason.m_playerId == player:objectName() and bit32.band(move.reason.m_reason, sgs.CardMoveReason_S_MASK_BASIC_REASON) == sgs.CardMoveReason_S_REASON_DISCARD and move.to_place == sgs.Player_PlaceTable then  --弃牌必定经过处理区，防止重复记录
				for _, id in sgs.qlist(move.card_ids) do
					room:addPlayerMark(player, "ShejianSuit" .. sgs.Sanguosha:getCard(id):getSuitString())
				end
			end
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
Shejian = sgs.CreateTriggerSkill{
	name = "Shejian",
	can_preshow = true,
	events = {sgs.EventPhaseEnd},
	can_trigger = function(self, event, room, player, data)
		if not (player and player:isAlive() and player:hasSkill(self)) then return "" end
		if event == sgs.EventPhaseEnd and player:getPhase() == sgs.Player_Discard then
			local discarded, can_invoke = false, true
			for _,suit in ipairs({"spade", "club", "heart", "diamond"}) do
				discarded = discarded or (player:getMark("ShejianSuit" .. suit) > 0)
				can_invoke = can_invoke and (player:getMark("ShejianSuit" .. suit) <= 1)
			end
			if discarded and can_invoke then
				for _,p in sgs.qlist(room:getOtherPlayers(player)) do
					if player:canDiscard(p, "he") then
						return self:objectName()
					end
				end
			end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		local targets = sgs.SPlayerList()
		for _,p in sgs.qlist(room:getOtherPlayers(player)) do
			if player:canDiscard(p, "he") then targets:append(p) end
		end
		if targets:isEmpty() then return false end
		local target = room:askForPlayerChosen(player, targets, self:objectName(), "Shejian-invoke", true, true)
		if target then
			room:broadcastSkillInvoke(self:objectName(), player)
			local to_data = sgs.QVariant()
			to_data:setValue(target)
			player:setTag(self:objectName(), to_data)
			return true
		end
		return false 
	end,
	on_effect = function(self, event, room, player, data)
		local target = player:getTag(self:objectName()):toPlayer()
		player:removeTag(self:objectName())
		local card_id = room:askForCardChosen(player, target, "he", self:objectName(), false, sgs.Card_MethodDiscard)
		local reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_DISMANTLE, player:objectName(), target:objectName(), self:objectName(), nil)
		room:throwCard(sgs.Sanguosha:getCard(card_id), reason, target, player)
		return false 
	end,
	on_turn_broken = function(self, function_name, event, room, player, data, ask_who)
		player:removeTag(self:objectName())
	end
}
MiHeng:addSkill(Shejian)
MiHeng:addSkill(ShejianRecord)
sgs.insertRelatedSkills(extensionMobile, "Shejian", "#Shejian-record")

------------------------------------------------☆SP------------------------------------------------

extensionBGM = sgs.Package("BGM", sgs.Package_GeneralPack)

--[[ ☆SP 006 吕蒙
	武将：LyuMeng_BGM
	武将名：吕蒙-☆SP
	体力上限：3
	武将技能：
		探虎：出牌阶段限一次，你可以与一名其他角色拼点：若你赢，你与该角色的距离视为1，且你使用的对其结算的非延时类锦囊牌不能被【无懈可击】响应或抵消，直到回合结束。
		谋断：当你明置此武将牌后，你获得一枚“文/武”标记且“武”朝上；若你的手牌数不大于2，你的标记为“文”朝上；其他角色的回合开始时，若“文”朝上，你可以弃置一张牌，将标记翻至“武”朝上；若“武”朝上，你拥有“激昂”和“谦逊”；若“文”朝上，你拥有“英姿”和“克己”。
	状态：验证通过
]]--
LyuMeng_BGM = sgs.General(extensionBGM, "LyuMeng_BGM", "wu", 3, true)

--[[
	技能名：探虎
	技能：Tanhu
	描述：出牌阶段限一次，你可以与一名其他角色拼点：若你赢，你与该角色的距离视为1，且你使用的对其结算的非延时类锦囊牌不能被【无懈可击】响应或抵消，直到回合结束。
	状态：验证通过
]]--
TanhuCard = sgs.CreateSkillCard{
	name = "TanhuCard", 
	skill_name = "Tanhu",
	filter = function(self, targets, to_select, player)
		return #targets == 0 and not to_select:isKongcheng() and to_select:objectName() ~= player:objectName()
	end,
	extra_cost = function(self, room, use)
		local pd = sgs.PindianStruct()
		pd = use.from:pindianSelect(use.to:first(), "Tanhu")
		local d = sgs.QVariant()
		d:setValue(pd)
		use.from:setTag("Tanhu_pd", d)
	end,
	on_effect = function(self, effect)
		local room = effect.from:getRoom()
		local pd = effect.from:getTag("Tanhu_pd"):toPindian()
		effect.from:removeTag("Tanhu_pd")
		if pd then
			local success = effect.from:pindian(pd)
			if success then
				room:broadcastSkillInvoke("Tanhu", 2, effect.from)
				local list = effect.from:getTag("TanhuInvoke"):toList() or sgs.VariantList()
				local to = sgs.QVariant()
				to:setValue(effect.to)
				if list:contains(to) then return end
				list:append(to)
				effect.from:setTag("TanhuInvoke", sgs.QVariant(list))
				effect.to:setFlags("TanhuTarget")
				if effect.from:isAlive() then
					room:setFixedDistance(effect.from, effect.to, 1)
				end
			end
		end
	end,
}
TanhuVS = sgs.CreateZeroCardViewAsSkill{
	name = "Tanhu",
	view_as = function(self)
		local card = TanhuCard:clone()
		card:setShowSkill(self:objectName())
		card:setSkillName(self:objectName())
		return card
	end, 
	enabled_at_play = function(self, player)
		return not player:hasUsed("#TanhuCard") and not player:isKongcheng()
	end, 
}
Tanhu = sgs.CreateTriggerSkill{
	name = "Tanhu",
	can_preshow = false,
	frequency = sgs.Skill_NotFrequent,
	events = {sgs.EventPhaseStart, sgs.Death},
	priority = 8,
	view_as_skill = TanhuVS,
	on_record = function(self, event, room, player, data)
		if event == sgs.Death then
			local death = data:toDeath()
			if death.who:objectName() ~= player:objectName() then
				local targets_qvar = player:getTag("TanhuInvoke"):toList()
				local target
				for i, target_qvar in sgs.qlist(targets_qvar) do
					target = target_qvar:toPlayer()
					if target and (death.who:objectName() == target:objectName()) then
						target:setFlags("-TanhuTarget")
						room:setFixedDistance(player, target, -1)  --removeFixedDistance未出现在国战
						targets_qvar:removeAt(i)
						break
					end
				end
				if targets_qvar:isEmpty() then player:removeTag("TanhuInvoke")
				else player:setTag("TanhuInvoke", sgs.QVariant(targets_qvar)) end
			end
			return
		end
		if player:getPhase() ~= sgs.Player_NotActive then return end
		local targets_qvar = player:getTag("TanhuInvoke"):toList()
		local target
		for i, target_qvar in sgs.qlist(targets_qvar) do
			target = target_qvar:toPlayer()
			if target then
				target:setFlags("-TanhuTarget")
				room:setFixedDistance(player, target, -1)
			end
		end
		player:removeTag("TanhuInvoke")
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end
}
TanhuCancel = sgs.CreateTriggerSkill{
	name = "#Tanhu-cancel",
	events = {sgs.TrickCardCanceling, sgs.PostCardEffected},
	frequency = sgs.Skill_Wake,
	global = true,
	priority = 10,
	on_record = function(self, event, room, player, data)
		if event == sgs.PostCardEffected then  --国无懈
			local effect = data:toCardEffect()
			if not effect.card:isNDTrick() then return end
			local heg_targets = room:getTag(effect.card:toString() .. "HegNullificationTargets"):toStringList()
			if not heg_targets then return end
			if effect.from and not effect.from:getTag("TanhuInvoke"):toList():isEmpty() then
				local targets_qvar = effect.from:getTag("TanhuInvoke"):toList()
				local target
				for i, target_qvar in sgs.qlist(targets_qvar) do
					target = target_qvar:toPlayer()
					if target and table.contains(heg_targets, target:objectName()) then
						local msg = sgs.LogMessage()
						msg.type, msg.from, msg.arg, msg.arg2 = "#TanhuHegNullification", effect.from, "heg_nullification", effect.card:objectName()
						msg.to:append(target)
						room:sendLog(msg)
						table.removeAll(heg_targets, target:objectName())
					end
				end
				table.removeAll(heg_targets, "")
				local list = sgs.VariantList()
				for _,str in pairs(heg_targets) do
					list:append(sgs.QVariant(str))
				end
				room:setTag(effect.card:toString() .. "HegNullificationTargets", sgs.QVariant(list))
			end
		end
	end,
	can_trigger = function(self, event, room, player, data)
		if event ~= sgs.TrickCardCanceling then return "" end
		local effect = data:toCardEffect()
		if effect.from and not effect.from:getTag("TanhuInvoke"):toList():isEmpty() and effect.to and effect.to:hasFlag("TanhuTarget") then
			local targets_qvar = effect.from:getTag("TanhuInvoke"):toList()
			local dat = sgs.QVariant()
			dat:setValue(effect.to)
			if targets_qvar:contains(dat) then
				return self:objectName(), effect.from
			end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		return true
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		return true
	end
}
LyuMeng_BGM:addSkill(Tanhu)
LyuMeng_BGM:addSkill(TanhuCancel)
sgs.insertRelatedSkills(extensionBGM, "Tanhu", "#Tanhu-cancel")

--[[
	技能名：谋断
	技能：Mouduan
	描述：当你明置此武将牌后，你获得一枚“文/武”标记且“武”朝上；若你的手牌数不大于2，你的标记为“文”朝上；其他角色的回合开始时，若“文”朝上，你可以弃置一张牌，将标记翻至“武”朝上；若“武”朝上，你拥有“激昂”和“谦逊”；若“文”朝上，你拥有“英姿”和“克己”。
	状态：验证通过
]]--
function sgs.CreateJiangSkill(name)
	local jiang_skill = {
		name = "jiang_" .. name,
		events = {sgs.TargetConfirmed, sgs.TargetChosen},
		frequency = sgs.Skill_Frequent,
		can_trigger = function(self, event, room, player, data)
			if not (player and player:isAlive() and player:hasSkill(self)) then return "" end
			local use = data:toCardUse()
			local invoke = (event == sgs.TargetChosen)
			if not invoke then
				invoked = use.to:contains(player)
			end
			if invoke then
				if use.card:isKindOf("Duel") or (use.card:isKindOf("Slash") and use.card:isRed()) then
					return self:objectName()
				end
			end
			return ""
		end,
		on_cost = function(self, event, room, player, data)
			if player:askForSkillInvoke(self) then
				local use = data:toCardUse()
				local index = 1
				if use.from ~= player then index = 2 end
				room:broadcastSkillInvoke(self:objectName(), index, player)
				return true
			end
		end,
		on_effect = function(self, event, room, player, data)
			player:drawCards(1)
			return false
		end,
	}
	return sgs.CreateTriggerSkill(jiang_skill)
end
jiang_LyuMeng_BGM = sgs.CreateJiangSkill("LyuMeng_BGM")
function sgs.CreateQianxunSkill(name)
	local qianxun_skill = {
		name = "qianxun_" .. name,
		events = {sgs.TargetConfirming},
		frequency = sgs.Skill_Compulsory,
		can_trigger = function(self, event, room, player, data)
			if not player or player:isDead() or not player:hasSkill(self:objectName()) then return false end
			local use = data:toCardUse()
			if not use.card or use.card:getTypeId() ~= sgs.Card_TypeTrick or (not use.card:isKindOf("Snatch") and not use.card:isKindOf("Indulgence")) or not use.to:contains(player) then
				return false end
			return self:objectName()
		end,
		on_cost = function(self, event, room, player, data)
			if player:hasShownSkill(self:objectName()) or player:askForSkillInvoke(self:objectName()) then
				room:broadcastSkillInvoke(self:objectName(), player)
				return true
			end
		end,
		on_effect = function(self, event, room, player, data)
			room:sendCompulsoryTriggerLog(player, self:objectName(), true)
			local use = data:toCardUse()
			sgs.Room_cancelTarget(use, player)
			data:setValue(use)
			return false
		end,
	}
	return sgs.CreateTriggerSkill(qianxun_skill)
end
qianxun_LyuMeng_BGM = sgs.CreateQianxunSkill("LyuMeng_BGM")
function sgs.CreateYingziSkill(name)
	local yingzi_skill = {
		name = "yingzi_" .. name,
		frequency = sgs.Skill_Frequent,
		can_preshow = true,
		on_cost = function(self, event, room, player, data)
			if player:askForSkillInvoke(self:objectName()) then
				room:broadcastSkillInvoke(self:objectName(), player)
				return true
			end
		end,
		draw_num_func = function(self,player,n)
			return n + 1
		end,
	}
	return sgs.CreateDrawCardsSkill(yingzi_skill)
end
yingzi_LyuMeng_BGM = sgs.CreateYingziSkill("LyuMeng_BGM")
kejiRecord_LyuMeng_BGM = sgs.CreateKejiRecordSkill("LyuMeng_BGM")
keji_LyuMeng_BGM = sgs.CreateKejiSkill("LyuMeng_BGM")
Mouduan = sgs.CreateTriggerSkill{
	name = "Mouduan",
	can_preshow = true,
	events = {sgs.EventLoseSkill},
	on_record = function(self, event, room, player, data)
		if data:toString() == self:objectName() then
			if player:getMark("@wu") > 0 then
				player:loseAllMarks("@wu")
				room:handleAcquireDetachSkills(player, "-jiang_LyuMeng_BGM|-qianxun_LyuMeng_BGM", true)
			end
			if player:getMark("@wen") > 0 then
				player:loseAllMarks("@wen")
				room:handleAcquireDetachSkills(player, "-yingzi_LyuMeng_BGM|-keji_LyuMeng_BGM", true)
			end
			room:setPlayerMark(player, "MouduanJustDroppedToWen", 0)
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
MouduanStart = sgs.CreateTriggerSkill{
	name = "#Mouduan-start",
	events = {sgs.GeneralShown, sgs.DFDebut},
	frequency = sgs.Skill_Compulsory,
	can_trigger = function(self, event, room, player, data)
		if not (player and player:isAlive() and player:hasSkill("Mouduan")) then return "" end
		if event == sgs.GeneralShown and player:getMark("@wu") + player:getMark("@wen") == 0 then
			return (data:toBool() == player:inHeadSkills("Mouduan")) and self:objectName() or ""
		elseif event == sgs.DFDebut and player:getMark("@wu") + player:getMark("@wen") == 0 then
			return self:objectName()
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		return true
	end,
	on_effect = function(self, event, room, player, data)
		if player:getMark("@wu") == 0 and player:getHandcardNum() > 2 then
			player:gainMark("@wu")
			room:handleAcquireDetachSkills(player, player:inHeadSkills("Mouduan") and "jiang_LyuMeng_BGM|qianxun_LyuMeng_BGM" or "jiang_LyuMeng_BGM!|qianxun_LyuMeng_BGM!")
			if player:getMark("@wen") > 0 then
				player:loseMark("@wen")
				room:handleAcquireDetachSkills(player, "-yingzi_LyuMeng_BGM|-keji_LyuMeng_BGM", true)
			end
		end
		if player:getMark("@wen") == 0 and player:getHandcardNum() <= 2 then
			player:gainMark("@wen")
			room:handleAcquireDetachSkills(player, player:inHeadSkills("Mouduan") and "yingzi_LyuMeng_BGM|keji_LyuMeng_BGM" or "yingzi_LyuMeng_BGM!|keji_LyuMeng_BGM!")
			if player:getMark("@wu") > 0 then
				player:loseMark("@wu")
				room:handleAcquireDetachSkills(player, "-jiang_LyuMeng_BGM|-qianxun_LyuMeng_BGM", true)
			end
		end
		room:setPlayerMark(player, "MouduanJustDroppedToWen", 0)
		return false
	end,
}
MouduanFlip = sgs.CreateTriggerSkill{
	name = "#Mouduan-flip",
	events = {sgs.CardsMoveOneTime},
	frequency = sgs.Skill_Compulsory,
	on_record = function(self, event, room, player, data)
		if not (player and player:isAlive() and player:hasSkill("Mouduan")) then return "" end
		local move = data:toMoveOneTime()
		if move.to and move.to:objectName() == player:objectName() and move.to_place == sgs.Player_PlaceHand and player:getHandcardNum() > 2 and not player:hasShownSkill("Mouduan") then
			room:setPlayerMark(player, "MouduanJustDroppedToWen", 0)				--【todo：改用堆栈判断移动前手牌数，奋激谋断：甘宁将吕蒙周泰的手牌一直
		end																			--  拆到0，吕蒙每次都点取消也就不会on_cost设置Mark，最后一次1拆0的时候
	end,																			--可以先奋激再谋断，但实际并没有从>2减少到<=2】
	can_trigger = function(self, event, room, player, data)
		if not (player and player:isAlive() and player:hasSkill("Mouduan")) then return "" end
		local move = data:toMoveOneTime()
		if move.from and move.from:objectName() == player:objectName() and (player:getMark("@wu") > 0 or player:getMark("@wen") == 0) then
			if move.from_places:contains(sgs.Player_PlaceHand) and player:getHandcardNum() <= 2 then
				if not player:hasShownSkill("Mouduan") and player:getMark("MouduanJustDroppedToWen") > 0 then return "" end
				return self:objectName()
			end
		end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		if not player:hasShownSkill("Mouduan") then room:setPlayerMark(player, "MouduanJustDroppedToWen", 1) end  --防止手牌数从2降到1也询问是否发动
		if player:hasShownSkill(self) or room:askForSkillInvoke(player, "Mouduan", sgs.QVariant("wen")) then
			room:broadcastSkillInvoke("Mouduan", player)
			if player:ownSkill("Mouduan") and not player:hasShownSkill("Mouduan") then
				player:showGeneral(player:inHeadSkills("Mouduan"))
			end
			return true
		end
		return false
	end,
	on_effect = function(self, event, room, player, data)
		if not player:hasFlag("MouduanJustShown") then  --刚刚亮将的情况有MouduanStart处理（防止半体力摸牌判断错误）
			room:sendCompulsoryTriggerLog(player, "Mouduan", true)
			if player:getHandcardNum() > 2 then return end
			if player:getMark("@wen") == 0 then
				player:gainMark("@wen")
				room:handleAcquireDetachSkills(player, player:inHeadSkills("Mouduan") and "yingzi_LyuMeng_BGM|keji_LyuMeng_BGM" or "yingzi_LyuMeng_BGM!|keji_LyuMeng_BGM!")
			end
			if player:getMark("@wu") > 0 then
				player:loseMark("@wu")
				room:handleAcquireDetachSkills(player, "-jiang_LyuMeng_BGM|-qianxun_LyuMeng_BGM", true)
			end
		else
			player:setFlags("-MouduanJustShown")
		end
		return false
	end,
}
MouduanFlipBack = sgs.CreateTriggerSkill{
	name = "#Mouduan-flipback",
	events = {sgs.EventPhaseStart},
	can_trigger = function(self, event, room, player, data)
		if not player or player:getPhase() ~= sgs.Player_RoundStart then return "" end
		local lyumengs = room:findPlayersBySkillName("Mouduan")
		lyumengs:removeOne(player)
		local skill_list, player_list = {},{}
		for _, lyumeng in sgs.qlist(lyumengs) do
			if lyumeng:getMark("@wen") > 0 and lyumeng:canDiscard(lyumeng, "he") then
				table.insert(skill_list, self:objectName())
				table.insert(player_list, lyumeng:objectName())
			end
		end
		return table.concat(skill_list, "|"), table.concat(player_list, "|")
	end,
	on_cost = function(self, event, room, player, data, ask_who)
		if ask_who:canDiscard(ask_who, "he") and room:askForCard(ask_who, "..", "@Mouduan", sgs.QVariant(), "Mouduan") then
			if ask_who:getHandcardNum() > 2 then room:broadcastSkillInvoke("Mouduan", ask_who) end
			if ask_who:ownSkill("Mouduan") and not ask_who:hasShownSkill("Mouduan") then
				ask_who:showGeneral(ask_who:inHeadSkills("Mouduan"))
			end
			return true
		end
	end,
	on_effect = function(self, event, room, player, data, ask_who)
		if ask_who:getHandcardNum() > 2 then
			if ask_who:getMark("@wu") == 0 then
				ask_who:gainMark("@wu")
				room:handleAcquireDetachSkills(ask_who, ask_who:inHeadSkills("Mouduan") and "jiang_LyuMeng_BGM|qianxun_LyuMeng_BGM" or "jiang_LyuMeng_BGM!|qianxun_LyuMeng_BGM!")
			end
			if ask_who:getMark("@wen") > 0 then
				ask_who:loseMark("@wen")
				room:handleAcquireDetachSkills(ask_who, "-yingzi_LyuMeng_BGM|-keji_LyuMeng_BGM", true)
			end
		end
	end,
}
LyuMeng_BGM:addSkill(Mouduan)
LyuMeng_BGM:addSkill(MouduanStart)
LyuMeng_BGM:addSkill(MouduanFlip)
LyuMeng_BGM:addSkill(MouduanFlipBack)
sgs.insertRelatedSkills(extensionBGM, "Mouduan", "#Mouduan-start", "#Mouduan-flip", "#Mouduan-flipback")
local skillList = sgs.SkillList()
if not sgs.Sanguosha:getSkill("jiang_LyuMeng_BGM") then skillList:append(jiang_LyuMeng_BGM) end
if not sgs.Sanguosha:getSkill("qianxun_LyuMeng_BGM") then skillList:append(qianxun_LyuMeng_BGM) end
if not sgs.Sanguosha:getSkill("yingzi_LyuMeng_BGM") then skillList:append(yingzi_LyuMeng_BGM) end
if not sgs.Sanguosha:getSkill("#keji-record_LyuMeng_BGM") then skillList:append(kejiRecord_LyuMeng_BGM) end
if not sgs.Sanguosha:getSkill("keji_LyuMeng_BGM") then skillList:append(keji_LyuMeng_BGM) end
sgs.Sanguosha:addSkills(skillList)
sgs.insertRelatedSkills(extensionLB, "keji_LyuMeng_BGM", "#keji-record_LyuMeng_BGM")
LyuMeng_BGM:addRelateSkill("jiang_LyuMeng_BGM")
LyuMeng_BGM:addRelateSkill("qianxun_LyuMeng_BGM")
LyuMeng_BGM:addRelateSkill("yingzi_LyuMeng_BGM")
LyuMeng_BGM:addRelateSkill("keji_LyuMeng_BGM")

------------------------------------------------怀旧------------------------------------------------

extensionNostalgia = sgs.Package("Nostalgia", sgs.Package_GeneralPack)

--[[ （YJ 104） 关兴张苞
	武将：GuanXingZhangBao_Nos
	武将名：关兴张苞-旧
	体力上限：4
	武将技能：
		父魂：摸牌阶段开始时，你可以放弃摸牌，亮出牌堆顶的两张牌，然后获得之，若亮出的牌颜色不同，你拥有“武圣”和“咆哮”，直到回合结束。
	状态：
]]--
GuanXingZhangBao_Nos = sgs.General(extensionNostalgia, "GuanXingZhangBao_Nos", "shu", 4, true, true)

--[[
	技能名：父魂
	技能：FuhunNos
	描述：摸牌阶段开始时，你可以放弃摸牌，亮出牌堆顶的两张牌，然后获得之，若亮出的牌颜色不同，你拥有“武圣”和“咆哮”，直到回合结束。
	状态：
]]--
wusheng_GuanXingZhangBao_Nos = sgs.CreateWushengSkill("GuanXingZhangBao_Nos")
paoxiao_GuanXingZhangBao_Nos = sgs.CreatePaoxiaoSkill("GuanXingZhangBao_Nos")
paoxiaoArmorNullificaion_GuanXingZhangBao_Nos = sgs.CreatePaoxiaoArmorNullificaionSkill("GuanXingZhangBao_Nos")
FuhunNos = sgs.CreatePhaseChangeSkill{
	name = "FuhunNos",
	can_preshow = true,
	frequency = sgs.Skill_Frequent,
	can_trigger = function(self, event, room, player, data)
		if not player or player:isDead() or not player:hasSkill(self) then return "" end
		if player:getPhase() == sgs.Player_Draw then return self:objectName() end
		return ""
	end,
	on_cost = function(self, event, room, player, data)
		if player:askForSkillInvoke(self:objectName(), data) then
			local skin_id = player:property((player:inHeadSkills(self) and "head" or "deputy") .. "_skin_id"):toInt()
			room:broadcastSkillInvoke(self:objectName(), (skin_id == 1) and 1 or -1, player)
			return true 
		end
		return false 
	end,
	on_phasechange = function(self, player)
		local room = player:getRoom()
		local card1, card2 = room:drawCard(), room:drawCard()
		local ids = sgs.IntList()
		ids:append(card1)
		ids:append(card2)
		local diff = not sgs.Sanguosha:getCard(card1):sameColorWith(sgs.Sanguosha:getCard(card2))
		local move = sgs.CardsMoveStruct()
		move.card_ids = ids
		move.to = player
		move.to_place = sgs.Player_PlaceTable
		move.reason = sgs.CardMoveReason(sgs.CardMoveReason_S_REASON_TURNOVER, player:objectName(), self:objectName(), nil)
		room:moveCardsAtomic(move, true)
		room:getThread():delay()
		
		local dummy = sgs.DummyCard(ids)
		player:obtainCard(dummy)
		dummy:deleteLater()
		local skin_id = player:property((player:inHeadSkills(self) and "head" or "deputy") .. "_skin_id"):toInt()
		if diff then
			if skin_id == 1 then room:broadcastSkillInvoke(self:objectName(), 2, player) end
			room:setPlayerMark(player, "FuhunNosSuccess", 1)
			room:handleAcquireDetachSkills(player, player:inHeadSkills(self) and "wusheng_GuanXingZhangBao_Nos|paoxiao_GuanXingZhangBao_Nos" or "wusheng_GuanXingZhangBao_Nos!|paoxiao_GuanXingZhangBao_Nos!")
		else
			if skin_id == 1 then room:broadcastSkillInvoke(self:objectName(), 3, player) end
		end
		return true
	end,
}
FuhunNosClear = sgs.CreateTriggerSkill{
	name = "#FuhunNos-clear",
	can_preshow = false,
	events = {sgs.EventPhaseStart},
	priority = 8,
	on_record = function(self, event, room, player, data)
		if (player:getPhase() == sgs.Player_NotActive) and (player:getMark("FuhunNosSuccess") > 0) then
			room:setPlayerMark(player, "FuhunNosSuccess", 0)
			room:handleAcquireDetachSkills(player, "-wusheng_GuanXingZhangBao_Nos|-paoxiao_GuanXingZhangBao_Nos", true)
		end
	end,
	can_trigger = function(self, event, room, player, data)
		return ""
	end,
}
GuanXingZhangBao_Nos:addSkill(FuhunNos)
GuanXingZhangBao_Nos:addSkill(FuhunNosClear)
sgs.insertRelatedSkills(extensionNostalgia, "FuhunNos", "#FuhunNos-clear")
local skillList = sgs.SkillList()
if not sgs.Sanguosha:getSkill("wusheng_GuanXingZhangBao_Nos") then skillList:append(wusheng_GuanXingZhangBao_Nos) end
if not sgs.Sanguosha:getSkill("paoxiao_GuanXingZhangBao_Nos") then skillList:append(paoxiao_GuanXingZhangBao_Nos) end
if not sgs.Sanguosha:getSkill("#paoxiao-null_GuanXingZhangBao_Nos") then skillList:append(paoxiaoArmorNullificaion_GuanXingZhangBao_Nos) end
sgs.Sanguosha:addSkills(skillList)
sgs.insertRelatedSkills(extensionNostalgia, "paoxiao_GuanXingZhangBao_Nos", "#paoxiao-null_GuanXingZhangBao_Nos")
GuanXingZhangBao_Nos:addRelateSkill("wusheng_GuanXingZhangBao_Nos")
GuanXingZhangBao_Nos:addRelateSkill("paoxiao_GuanXingZhangBao_Nos")

----------------------------------------------武将替换----------------------------------------------

extensionSPConvert = sgs.Package("from_v2", sgs.Package_GeneralPack)  --空包，允许用户决定是否开启武将替换
--取名是为了AI，使得系统能够读取from_v2-ai.lua文件，因为只会按照扩展包名检索

convert_pairs = {
	"caoren->CaoRen_13|CaoRen_15",
	"zhoutai->ZhouTai_13|ZhouTai_15",
	"caocao->CaoCao_LB|ShenCaoCao|ShenCaoCao_OL",
	"simayi->SiMaYi_LB|ShenSiMaYi",
	"xiahoudun->XiaHouDun_LB",
	"zhangliao->ZhangLiao_LB",
	"xuchu->XuChu_LB",
	"guojia->GuoJia_LB",
	"liubei->LiuBei_LB",
	"guanyu->GuanYu_LB|ShenGuanYu",
	"zhangfei->ZhangFei_LB",
	"zhaoyun->ZhaoYun_LB|ShenZhaoYun",
	"machao->MaChao_LB",
	"ganning->GanNing_LB",
	"lvmeng->LyuMeng_LB|ShenLyuMeng",
	"huanggai->HuangGai_LB",
	"zhouyu->ZhouYu_LB|ShenZhouYu",
	"daqiao->DaQiao_LB",
	"luxun->LuXun_LB",
	"huatuo->HuaTuo_LB",
	"lvbu->LyuBu_LB|ShenLyuBu",
	"huangzhong->HuangZhong_LB",
	"weiyan->WeiYan_LB",
	"zhugeliang->ShenZhuGeLiang",
	"wolong->ShenZhuGeLiang",
	"madai->MaDai_RE",
	"WangYi->WangYi_OL",
	"ZhangRang->ZhangRang_OL",
	"XingCai->XingCai_OL",
	"ZuMao->ZuMao_OL",
	"GuanXingZhangBao->GuanXingZhangBao_Nos",
}
function changeHeroForHegemony(player, to_general, isHead)  --模仿changeToLord（serverplayer.cpp #2012）  --todo：变包版改用setActualGeneral★★★★★★
	local room = player:getRoom()
	local skillList = isHead and player:getHeadSkillList() or player:getDeputySkillList()
	for _,skill in sgs.qlist(skillList) do
		player:loseSkill(skill:objectName())
		local arg = {7, player:objectName(), skill:objectName()}  --S_GAME_EVENT_LOSE_SKILL（尼玛为什么这里是从0开始，拼点那里就是从1开始了？劳资不服啊！！）
		room:doNotify(player, sgs.CommandType.S_COMMAND_LOG_EVENT, json.encode(arg))
		if (skill:getFrequency() == sgs.Skill_Limited) and (not skill:getLimitMark():isEmpty()) then
			room:setPlayerMark(player, skill:getLimitMark(), 0)
		end
	end
	
	local real_generals = room:getTag(player:objectName()):toStringList()
	real_generals[isHead and 1 or 2] = to_general
	local list = sgs.VariantList()
	list:append(sgs.QVariant(real_generals[1]))
	list:append(sgs.QVariant(real_generals[2]))
	room:setTag(player:objectName(), sgs.QVariant(list))  --设置StringList的正解！！！
	
	local general1 = sgs.Sanguosha:getGeneral(real_generals[1])
	local general2 = sgs.Sanguosha:getGeneral(real_generals[2])
	assert((general1 ~= nil) and (general2 ~= nil))
	if general1:isCompanionWith(real_generals[2]) then
		room:setPlayerMark(player, "CompanionEffect", 1)
	else
		room:setPlayerMark(player, "CompanionEffect", 0)
	end
	local doubleMaxHp = general1:getMaxHpHead() + general2:getMaxHpDeputy()
	room:setPlayerMark(player, "HalfMaxHpLeft", math.mod(doubleMaxHp, 2))
	player:setMaxHp(math.floor(doubleMaxHp / 2))
	player:setHp(math.floor(doubleMaxHp / 2))
	room:broadcastProperty(player, "maxhp")
	room:broadcastProperty(player, "hp")
	
	player:setActualGeneral1(general1)
	player:setActualGeneral2(general2)
	room:notifyProperty(player, player, "actual_general1")
	room:notifyProperty(player, player, "actual_general2")
	local arg2 = {11, player:objectName(), to_general, not isHead, false}  --S_GAME_EVENT_CHANGE_HERO
	room:doNotify(player, sgs.CommandType.S_COMMAND_LOG_EVENT, json.encode(arg2))
	--player:setSkillsPreshowed("hd", false)
	--player:notifyPreshow()  --无卵用
	
	for _,skill in sgs.qlist(sgs.Sanguosha:getGeneral(to_general):getVisibleSkillList(true, isHead)) do
		player:addSkill(skill:objectName(), isHead)
		if (skill:getFrequency() == sgs.Skill_Limited) and skill:getLimitMark() and (skill:getLimitMark() ~= "") then
			player:setMark(skill:getLimitMark(), 1)
			local arg3 = {player:objectName(), skill:getLimitMark(), 1}
			room:doNotify(player, sgs.CommandType.S_COMMAND_SET_MARK, json.encode(arg3))
		end
	end
end
function askForSPConvert(player, tos_head, tos_deputy)  --模拟SPConvertSkill（v2 skill.cpp #429）
	local room = player:getRoom()
	
	local function removeInvalidGenerals(tos)
		local choices = {}
		for _,to in ipairs(tos) do
			local gen = sgs.Sanguosha:getGeneral(to)
			if gen and not table.contains(sgs.GetConfig("Banlist/Generals", "")--[[:toStringList()]], to) and not table.contains(sgs.Sanguosha:getBanPackages(), gen:getPackage()) then
				--[[local tab_for_ban = {to, isHead and player:getActualGeneral2Name() or player:getActualGeneral1Name()}
				local banlist = sgs.GetConfig("Banlist/Pairs", "")
				if table.contains(banlist, table.concat(tab_for_ban, "+")) or table.contains(banlist, tab_for_ban[2] ..  "+" .. tab_for_ban[1]) then
					continue
				end]]  --Give up liao....
				
				local repetitive = false
				for _,p in sgs.qlist(player:getRoom():getAllPlayers()) do
					if (p:getActualGeneral1Name() == to) or (p:getActualGeneral2Name() == to) then
						repetitive = true
						break
					end
				end
				if not repetitive then
					table.insert(choices, to)
				end
			end
		end
		return choices
	end

	local choices_head = removeInvalidGenerals(tos_head)
	local choices_deputy = removeInvalidGenerals(tos_deputy)
	if #choices_head + #choices_deputy == 0 then return end
	
	local to_cv_head, to_cv_deputy = "", ""
	local disableDeputy = (not player:getGeneral2())
	
	local ai = player:getAI()
	if ai then
		player:setTag("SPConvertChoicesHead", sgs.QVariant(table.concat(choices_head, "+")))  --for AI
		if not disableDeputy then player:setTag("SPConvertChoicesDeputy", sgs.QVariant(table.concat(choices_deputy, "+"))) end
		if player:askForSkillInvoke("sp_convert") then
			to_cv_head = player:getTag("SPConvertResultHead"):toString()
			if not disableDeputy then to_cv_deputy = player:getTag("SPConvertResultDeputy"):toString() end
			player:removeTag("SPConvertResultHead")
			player:removeTag("SPConvertResultDeputy")
		end
		player:removeTag("SPConvertChoicesHead")
		player:removeTag("SPConvertChoicesDeputy")
		if to_cv_head ~= "" and to_cv_head ~= "cancel" then
			changeHeroForHegemony(player, to_cv_head, true)
		end
		if to_cv_deputy ~= "" and to_cv_deputy ~= "cancel" then
			changeHeroForHegemony(player, to_cv_deputy, false)
		end
	else
		if #choices_head > 0 then
			local data_str = "head:::" ..  table.concat(choices_head, "\\,\\")
			if #choices_head >= 2 then
				data_str = string.gsub(data_str, "\\,\\" .. choices_head[#choices_head], "\\or\\" .. choices_head[#choices_head])
			end
			if player:askForSkillInvoke("sp_convert", sgs.QVariant(data_str)) then
				to_cv_head = (#choices_head == 1) and choices_head[1] or room:askForGeneral(player, table.concat(choices_head, "+"))
			end
		end
		if to_cv_head ~= "" then
			changeHeroForHegemony(player, to_cv_head, true)
		end
		
		if #choices_deputy > 0 and not disableDeputy then
			local data_str = "deputy:::" ..  table.concat(choices_deputy, "\\,\\")
			if #choices_deputy >= 2 then
				data_str = string.gsub(data_str, "\\,\\" .. choices_deputy[#choices_deputy], "\\or\\" .. choices_deputy[#choices_deputy])
			end
			if player:askForSkillInvoke("sp_convert", sgs.QVariant(data_str)) then
				to_cv_deputy = (#choices_deputy == 1) and choices_deputy[1] or room:askForGeneral(player, table.concat(choices_deputy, "+"))
			end
		end
		if to_cv_deputy ~= "" then
			changeHeroForHegemony(player, to_cv_deputy, false)
		end
	end
	
	--[[local data_str = (isHead and "head" or "deputy") .. ":::" ..  table.concat(choices, "\\,\\")
	if #choices >= 2 then
		data_str = string.gsub(data_str, "\\,\\" .. choices[#choices], "\\or\\" .. choices[#choices])
	end
	
	local room = player:getRoom()
	if player:askForSkillInvoke("sp_convert", sgs.QVariant(data_str)) then
		local to_cv = ""
		local ai = player:getAI()
		if ai then
			to_cv = room:askForChoice(player, "sp_convert", table.concat(choices, "+"))
		else
			to_cv = (#choices == 1) and choices[1] or room:askForGeneral(player, table.concat(choices, "+"))
		end
		if to_cv ~= "" then
			changeHeroForHegemony(player, to_cv, isHead)
		end
	end]]
end
SPConvertSkill = sgs.CreateTriggerSkill{
	name = "sp_convert",
	global = true,
	events = {sgs.GameStart},
	priority = 0,  --先进行君主替换
	frequency = sgs.Skill_Frequent,  --解决AI停顿问题
	can_trigger = function(self, event, room, player)  --特别注意：国战第一次触发GameStart是系统触发没有player，而第二次能靠玩家触发GameStart就已经发完牌了，所以只能在第一次player=nil时执行；而即使can_trigger返回技能名，也需要玩家去点击发动，也就导致on_cost和on_effect都是废物，因此只能把一切放到can_trigger
		if table.contains(sgs.Sanguosha:getBanPackages(), "SPConvert") then return end
		if (player ~= nil) then return end
		if room:getTag("SPConvertInvoked"):toBool() then return end
		
		for _,player in sgs.qlist(room:getAllPlayers()) do
			if player:hasShownOneGeneral() then continue end  --守卫剑阁的临时解决方案
			
			local choiceListHead = {}
			local choiceListDeputy = {}
			for _,str in ipairs(convert_pairs) do
				local pair = str:split("->")
				if #pair ~= 2 then continue end
				if pair[1] == player:getActualGeneral1Name() then 
					for _,to in ipairs(pair[2]:split("|")) do
						table.insert(choiceListHead, to)
					end
				end
				if player:getGeneral2() then
					if pair[1] == player:getActualGeneral2Name() then
						for _,to in ipairs(pair[2]:split("|")) do
							table.insert(choiceListDeputy, to)
						end
					end
				end
			end
			
			if #choiceListHead + #choiceListDeputy ~= 0 then
				askForSPConvert(player, choiceListHead, choiceListDeputy)
			end
		end
		room:setTag("SPConvertInvoked", sgs.QVariant(true))
	end,
}
local skills = sgs.SkillList()
if not sgs.Sanguosha:getSkill("sp_convert") then skills:append(SPConvertSkill) end
sgs.Sanguosha:addSkills(skills)


--[[test11 = sgs.CreateTriggerSkill{  --测试用，输出场上所有武将以调试AI问题
	name = "test11",
	global = true,
	events = {sgs.GameStart},
	priority = 20,
	can_trigger = function(self, event, room, player)  
		for _,player in sgs.qlist(room:getAllPlayers()) do
			room:sendCompulsoryTriggerLog(player, player:getActualGeneral1Name() .. " " .. player:getActualGeneral2Name(), false)
		end
		for i = 1, 29 do
			room:sendCompulsoryTriggerLog(room:getAllPlayers():first(), " ", false)
		end
	end,
}
local skills = sgs.SkillList()
if not sgs.Sanguosha:getSkill("test11") then skills:append(test11) end
sgs.Sanguosha:addSkills(skills)]]

----------------------------------------------------------------------------------------------------

return {extensionRenew, extensionLB, extensionLegendLB, extensionGod, extensionYJCM, extensionYJCM2012, extensionYJCM2013, extensionYJCM2014, extensionYJCM2015, extensionYCZH2016, extensionSP, extensionJSP, extensionRE, extensionOL, extensionOLRenew, extensionMobile, extensionBGM, extensionNostalgia, extensionSPConvert}